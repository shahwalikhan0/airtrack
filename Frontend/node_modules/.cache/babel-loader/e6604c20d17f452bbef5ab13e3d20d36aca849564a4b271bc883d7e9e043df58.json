{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.instanceLookup = instanceLookup;\nexports.parseBrowserResponse = parseBrowserResponse;\nvar _dns = _interopRequireDefault(require(\"dns\"));\nvar _abortError = _interopRequireDefault(require(\"./errors/abort-error\"));\nvar _sender = require(\"./sender\");\nvar _withTimeout = require(\"./utils/with-timeout\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nconst SQL_SERVER_BROWSER_PORT = 1434;\nconst TIMEOUT = 2 * 1000;\nconst RETRIES = 3; // There are three bytes at the start of the response, whose purpose is unknown.\n\nconst MYSTERY_HEADER_LENGTH = 3;\n\n// Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\nasync function instanceLookup(options) {\n  const server = options.server;\n  if (typeof server !== 'string') {\n    throw new TypeError('Invalid arguments: \"server\" must be a string');\n  }\n  const instanceName = options.instanceName;\n  if (typeof instanceName !== 'string') {\n    throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n  }\n  const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n  if (typeof timeout !== 'number') {\n    throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n  }\n  const retries = options.retries === undefined ? RETRIES : options.retries;\n  if (typeof retries !== 'number') {\n    throw new TypeError('Invalid arguments: \"retries\" must be a number');\n  }\n  if (options.lookup !== undefined && typeof options.lookup !== 'function') {\n    throw new TypeError('Invalid arguments: \"lookup\" must be a function');\n  }\n  const lookup = options.lookup ?? _dns.default.lookup;\n  if (options.port !== undefined && typeof options.port !== 'number') {\n    throw new TypeError('Invalid arguments: \"port\" must be a number');\n  }\n  const port = options.port ?? SQL_SERVER_BROWSER_PORT;\n  const signal = options.signal;\n  if (signal.aborted) {\n    throw new _abortError.default();\n  }\n  let response;\n  for (let i = 0; i <= retries; i++) {\n    try {\n      response = await (0, _withTimeout.withTimeout)(timeout, async signal => {\n        const request = Buffer.from([0x02]);\n        return await (0, _sender.sendMessage)(options.server, port, lookup, signal, request);\n      }, signal);\n    } catch (err) {\n      // If the current attempt timed out, continue with the next\n      if (!signal.aborted && err instanceof Error && err.name === 'TimeoutError') {\n        continue;\n      }\n      throw err;\n    }\n  }\n  if (!response) {\n    throw new Error('Failed to get response from SQL Server Browser on ' + server);\n  }\n  const message = response.toString('ascii', MYSTERY_HEADER_LENGTH);\n  const foundPort = parseBrowserResponse(message, instanceName);\n  if (!foundPort) {\n    throw new Error('Port for ' + instanceName + ' not found in ' + options.server);\n  }\n  return foundPort;\n}\nfunction parseBrowserResponse(response, instanceName) {\n  let getPort;\n  const instances = response.split(';;');\n  for (let i = 0, len = instances.length; i < len; i++) {\n    const instance = instances[i];\n    const parts = instance.split(';');\n    for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n      const name = parts[p];\n      const value = parts[p + 1];\n      if (name === 'tcp' && getPort) {\n        const port = parseInt(value, 10);\n        return port;\n      }\n      if (name === 'InstanceName') {\n        if (value.toUpperCase() === instanceName.toUpperCase()) {\n          getPort = true;\n        } else {\n          getPort = false;\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["_dns","_interopRequireDefault","require","_abortError","_sender","_withTimeout","SQL_SERVER_BROWSER_PORT","TIMEOUT","RETRIES","MYSTERY_HEADER_LENGTH","instanceLookup","options","server","TypeError","instanceName","timeout","undefined","retries","lookup","default","port","signal","aborted","response","i","withTimeout","request","Buffer","from","sendMessage","err","Error","name","message","toString","foundPort","parseBrowserResponse","getPort","instances","split","len","length","instance","parts","p","partsLen","value","parseInt","toUpperCase"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/tedious/src/instance-lookup.ts"],"sourcesContent":["import dns from 'dns';\nimport { AbortSignal } from 'node-abort-controller';\n\nimport AbortError from './errors/abort-error';\nimport { sendMessage } from './sender';\nimport { withTimeout } from './utils/with-timeout';\n\nconst SQL_SERVER_BROWSER_PORT = 1434;\nconst TIMEOUT = 2 * 1000;\nconst RETRIES = 3;\n// There are three bytes at the start of the response, whose purpose is unknown.\nconst MYSTERY_HEADER_LENGTH = 3;\n\ntype LookupFunction = (hostname: string, options: dns.LookupAllOptions, callback: (err: NodeJS.ErrnoException | null, addresses: dns.LookupAddress[]) => void) => void;\n\n// Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\nexport async function instanceLookup(options: { server: string, instanceName: string, timeout?: number, retries?: number, port?: number, lookup?: LookupFunction, signal: AbortSignal }) {\n  const server = options.server;\n  if (typeof server !== 'string') {\n    throw new TypeError('Invalid arguments: \"server\" must be a string');\n  }\n\n  const instanceName = options.instanceName;\n  if (typeof instanceName !== 'string') {\n    throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n  }\n\n  const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n  if (typeof timeout !== 'number') {\n    throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n  }\n\n  const retries = options.retries === undefined ? RETRIES : options.retries;\n  if (typeof retries !== 'number') {\n    throw new TypeError('Invalid arguments: \"retries\" must be a number');\n  }\n\n  if (options.lookup !== undefined && typeof options.lookup !== 'function') {\n    throw new TypeError('Invalid arguments: \"lookup\" must be a function');\n  }\n  const lookup = options.lookup ?? dns.lookup;\n\n  if (options.port !== undefined && typeof options.port !== 'number') {\n    throw new TypeError('Invalid arguments: \"port\" must be a number');\n  }\n  const port = options.port ?? SQL_SERVER_BROWSER_PORT;\n\n  const signal = options.signal;\n\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  let response;\n\n  for (let i = 0; i <= retries; i++) {\n    try {\n      response = await withTimeout(timeout, async (signal) => {\n        const request = Buffer.from([0x02]);\n        return await sendMessage(options.server, port, lookup, signal, request);\n      }, signal);\n    } catch (err) {\n      // If the current attempt timed out, continue with the next\n      if (!signal.aborted && err instanceof Error && err.name === 'TimeoutError') {\n        continue;\n      }\n\n      throw err;\n    }\n  }\n\n  if (!response) {\n    throw new Error('Failed to get response from SQL Server Browser on ' + server);\n  }\n\n  const message = response.toString('ascii', MYSTERY_HEADER_LENGTH);\n  const foundPort = parseBrowserResponse(message, instanceName);\n\n  if (!foundPort) {\n    throw new Error('Port for ' + instanceName + ' not found in ' + options.server);\n  }\n\n  return foundPort;\n}\n\nexport function parseBrowserResponse(response: string, instanceName: string) {\n  let getPort;\n\n  const instances = response.split(';;');\n  for (let i = 0, len = instances.length; i < len; i++) {\n    const instance = instances[i];\n    const parts = instance.split(';');\n\n    for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n      const name = parts[p];\n      const value = parts[p + 1];\n\n      if (name === 'tcp' && getPort) {\n        const port = parseInt(value, 10);\n        return port;\n      }\n\n      if (name === 'InstanceName') {\n        if (value.toUpperCase() === instanceName.toUpperCase()) {\n          getPort = true;\n        } else {\n          getPort = false;\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}