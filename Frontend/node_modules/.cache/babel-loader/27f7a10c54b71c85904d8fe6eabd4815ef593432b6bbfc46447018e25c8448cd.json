{"ast":null,"code":"'use strict';\n\n/* const FIGURE = {\n  INTERIOR_RING: 0x00,\n  STROKE: 0x01,\n  EXTERIOR_RING: 0x02\n};\n\nconst FIGURE_V2 = {\n  POINT: 0x00,\n  LINE: 0x01,\n  ARC: 0x02,\n  COMPOSITE_CURVE: 0x03\n};\n\nconst SHAPE = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07\n};\n\nconst SHAPE_V2 = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07,\n  CIRCULAR_STRING: 0x08,\n  COMPOUND_CURVE: 0x09,\n  CURVE_POLYGON: 0x0A,\n  FULL_GLOBE: 0x0B\n};\n\nconst SEGMENT = {\n  LINE: 0x00,\n  ARC: 0x01,\n  FIRST_LINE: 0x02,\n  FIRST_ARC: 0x03\n}; */\nclass Point {\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n    this.z = null;\n    this.m = null;\n  }\n}\nconst parsePoints = (buffer, count, isGeometryPoint) => {\n  // s2.1.5 + s2.1.6\n  // The key distinction for parsing is that a GEOGRAPHY POINT is ordered Lat (y) then Long (x),\n  // while a GEOMETRY POINT is ordered x then y.\n  // Further, there are additional range constraints on GEOGRAPHY POINT that are useful for testing that the coordinate order has not been flipped, such as that Lat must be in the range [-90, +90].\n\n  const points = [];\n  if (count < 1) {\n    return points;\n  }\n  if (isGeometryPoint) {\n    // GEOMETRY POINT (s2.1.6): x then y.\n    for (let i = 1; i <= count; i++) {\n      const point = new Point();\n      points.push(point);\n      point.x = buffer.readDoubleLE(buffer.position);\n      point.y = buffer.readDoubleLE(buffer.position + 8);\n      buffer.position += 16;\n    }\n  } else {\n    // GEOGRAPHY POINT (s2.1.5): Lat (y) then Long (x).\n    for (let i = 1; i <= count; i++) {\n      const point = new Point();\n      points.push(point);\n      point.lat = buffer.readDoubleLE(buffer.position);\n      point.lng = buffer.readDoubleLE(buffer.position + 8);\n\n      // For backwards compatibility, preserve the coordinate inversion in x and y.\n      // A future breaking change likely eliminate x and y for geography points in favor of just the lat and lng fields, as they've proven marvelously confusing.\n      // See discussion at: https://github.com/tediousjs/node-mssql/pull/1282#discussion_r677769531\n      point.x = point.lat;\n      point.y = point.lng;\n      buffer.position += 16;\n    }\n  }\n  return points;\n};\nconst parseZ = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n\n  if (points < 1) {\n    return;\n  }\n  points.forEach(point => {\n    point.z = buffer.readDoubleLE(buffer.position);\n    buffer.position += 8;\n  });\n};\nconst parseM = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n\n  if (points < 1) {\n    return;\n  }\n  points.forEach(point => {\n    point.m = buffer.readDoubleLE(buffer.position);\n    buffer.position += 8;\n  });\n};\nconst parseFigures = (buffer, count, properties) => {\n  // s2.1.3\n\n  const figures = [];\n  if (count < 1) {\n    return figures;\n  }\n  if (properties.P) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    });\n  } else if (properties.L) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    });\n  } else {\n    for (let i = 1; i <= count; i++) {\n      figures.push({\n        attribute: buffer.readUInt8(buffer.position),\n        pointOffset: buffer.readInt32LE(buffer.position + 1)\n      });\n      buffer.position += 5;\n    }\n  }\n  return figures;\n};\nconst parseShapes = (buffer, count, properties) => {\n  // s2.1.4\n\n  const shapes = [];\n  if (count < 1) {\n    return shapes;\n  }\n  if (properties.P) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x01\n    });\n  } else if (properties.L) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x02\n    });\n  } else {\n    for (let i = 1; i <= count; i++) {\n      shapes.push({\n        parentOffset: buffer.readInt32LE(buffer.position),\n        figureOffset: buffer.readInt32LE(buffer.position + 4),\n        type: buffer.readUInt8(buffer.position + 8)\n      });\n      buffer.position += 9;\n    }\n  }\n  return shapes;\n};\nconst parseSegments = (buffer, count) => {\n  // s2.1.7\n\n  const segments = [];\n  if (count < 1) {\n    return segments;\n  }\n  for (let i = 1; i <= count; i++) {\n    segments.push({\n      type: buffer.readUInt8(buffer.position)\n    });\n    buffer.position++;\n  }\n  return segments;\n};\nconst parseGeography = (buffer, isUsingGeometryPoints) => {\n  // s2.1.1 + s.2.1.2\n\n  const srid = buffer.readInt32LE(0);\n  if (srid === -1) {\n    return null;\n  }\n  const value = {\n    srid,\n    version: buffer.readUInt8(4)\n  };\n  const flags = buffer.readUInt8(5);\n  buffer.position = 6;\n\n  // console.log(\"srid\", srid)\n  // console.log(\"version\", version)\n\n  const properties = {\n    Z: (flags & 1 << 0) > 0,\n    M: (flags & 1 << 1) > 0,\n    V: (flags & 1 << 2) > 0,\n    P: (flags & 1 << 3) > 0,\n    L: (flags & 1 << 4) > 0\n  };\n  if (value.version === 2) {\n    properties.H = (flags & 1 << 3) > 0;\n  }\n\n  // console.log(\"properties\", properties);\n\n  let numberOfPoints;\n  if (properties.P) {\n    numberOfPoints = 1;\n  } else if (properties.L) {\n    numberOfPoints = 2;\n  } else {\n    numberOfPoints = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  }\n\n  // console.log(\"numberOfPoints\", numberOfPoints)\n\n  value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints);\n  if (properties.Z) {\n    parseZ(buffer, value.points);\n  }\n  if (properties.M) {\n    parseM(buffer, value.points);\n  }\n\n  // console.log(\"points\", points)\n\n  let numberOfFigures;\n  if (properties.P) {\n    numberOfFigures = 1;\n  } else if (properties.L) {\n    numberOfFigures = 1;\n  } else {\n    numberOfFigures = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  }\n\n  // console.log(\"numberOfFigures\", numberOfFigures)\n\n  value.figures = parseFigures(buffer, numberOfFigures, properties);\n\n  // console.log(\"figures\", figures)\n\n  let numberOfShapes;\n  if (properties.P) {\n    numberOfShapes = 1;\n  } else if (properties.L) {\n    numberOfShapes = 1;\n  } else {\n    numberOfShapes = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  }\n\n  // console.log(\"numberOfShapes\", numberOfShapes)\n\n  value.shapes = parseShapes(buffer, numberOfShapes, properties);\n\n  // console.log( \"shapes\", shapes)\n\n  if (value.version === 2 && buffer.position < buffer.length) {\n    const numberOfSegments = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n\n    // console.log(\"numberOfSegments\", numberOfSegments)\n\n    value.segments = parseSegments(buffer, numberOfSegments);\n\n    // console.log(\"segments\", segments)\n  } else {\n    value.segments = [];\n  }\n  return value;\n};\nmodule.exports.PARSERS = {\n  geography(buffer) {\n    return parseGeography(buffer, /* isUsingGeometryPoints: */false);\n  },\n  geometry(buffer) {\n    return parseGeography(buffer, /* isUsingGeometryPoints: */true);\n  }\n};","map":{"version":3,"names":["Point","constructor","x","y","z","m","parsePoints","buffer","count","isGeometryPoint","points","i","point","push","readDoubleLE","position","lat","lng","parseZ","forEach","parseM","parseFigures","properties","figures","P","attribute","pointOffset","L","readUInt8","readInt32LE","parseShapes","shapes","parentOffset","figureOffset","type","parseSegments","segments","parseGeography","isUsingGeometryPoints","srid","value","version","flags","Z","M","V","H","numberOfPoints","readUInt32LE","numberOfFigures","numberOfShapes","length","numberOfSegments","module","exports","PARSERS","geography","geometry"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/mssql/lib/udt.js"],"sourcesContent":["'use strict'\n\n/* const FIGURE = {\n  INTERIOR_RING: 0x00,\n  STROKE: 0x01,\n  EXTERIOR_RING: 0x02\n};\n\nconst FIGURE_V2 = {\n  POINT: 0x00,\n  LINE: 0x01,\n  ARC: 0x02,\n  COMPOSITE_CURVE: 0x03\n};\n\nconst SHAPE = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07\n};\n\nconst SHAPE_V2 = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07,\n  CIRCULAR_STRING: 0x08,\n  COMPOUND_CURVE: 0x09,\n  CURVE_POLYGON: 0x0A,\n  FULL_GLOBE: 0x0B\n};\n\nconst SEGMENT = {\n  LINE: 0x00,\n  ARC: 0x01,\n  FIRST_LINE: 0x02,\n  FIRST_ARC: 0x03\n}; */\n\nclass Point {\n  constructor () {\n    this.x = 0\n    this.y = 0\n    this.z = null\n    this.m = null\n  }\n}\n\nconst parsePoints = (buffer, count, isGeometryPoint) => {\n  // s2.1.5 + s2.1.6\n  // The key distinction for parsing is that a GEOGRAPHY POINT is ordered Lat (y) then Long (x),\n  // while a GEOMETRY POINT is ordered x then y.\n  // Further, there are additional range constraints on GEOGRAPHY POINT that are useful for testing that the coordinate order has not been flipped, such as that Lat must be in the range [-90, +90].\n\n  const points = []\n  if (count < 1) {\n    return points\n  }\n\n  if (isGeometryPoint) {\n    // GEOMETRY POINT (s2.1.6): x then y.\n    for (let i = 1; i <= count; i++) {\n      const point = new Point()\n      points.push(point)\n      point.x = buffer.readDoubleLE(buffer.position)\n      point.y = buffer.readDoubleLE(buffer.position + 8)\n      buffer.position += 16\n    }\n  } else {\n    // GEOGRAPHY POINT (s2.1.5): Lat (y) then Long (x).\n    for (let i = 1; i <= count; i++) {\n      const point = new Point()\n      points.push(point)\n      point.lat = buffer.readDoubleLE(buffer.position)\n      point.lng = buffer.readDoubleLE(buffer.position + 8)\n\n      // For backwards compatibility, preserve the coordinate inversion in x and y.\n      // A future breaking change likely eliminate x and y for geography points in favor of just the lat and lng fields, as they've proven marvelously confusing.\n      // See discussion at: https://github.com/tediousjs/node-mssql/pull/1282#discussion_r677769531\n      point.x = point.lat\n      point.y = point.lng\n\n      buffer.position += 16\n    }\n  }\n\n  return points\n}\n\nconst parseZ = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n\n  if (points < 1) {\n    return\n  }\n\n  points.forEach(point => {\n    point.z = buffer.readDoubleLE(buffer.position)\n    buffer.position += 8\n  })\n}\n\nconst parseM = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n\n  if (points < 1) {\n    return\n  }\n\n  points.forEach(point => {\n    point.m = buffer.readDoubleLE(buffer.position)\n    buffer.position += 8\n  })\n}\n\nconst parseFigures = (buffer, count, properties) => {\n  // s2.1.3\n\n  const figures = []\n  if (count < 1) {\n    return figures\n  }\n\n  if (properties.P) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    })\n  } else if (properties.L) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    })\n  } else {\n    for (let i = 1; i <= count; i++) {\n      figures.push({\n        attribute: buffer.readUInt8(buffer.position),\n        pointOffset: buffer.readInt32LE(buffer.position + 1)\n      })\n\n      buffer.position += 5\n    }\n  }\n\n  return figures\n}\n\nconst parseShapes = (buffer, count, properties) => {\n  // s2.1.4\n\n  const shapes = []\n  if (count < 1) {\n    return shapes\n  }\n\n  if (properties.P) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x01\n    })\n  } else if (properties.L) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x02\n    })\n  } else {\n    for (let i = 1; i <= count; i++) {\n      shapes.push({\n        parentOffset: buffer.readInt32LE(buffer.position),\n        figureOffset: buffer.readInt32LE(buffer.position + 4),\n        type: buffer.readUInt8(buffer.position + 8)\n      })\n\n      buffer.position += 9\n    }\n  }\n\n  return shapes\n}\n\nconst parseSegments = (buffer, count) => {\n  // s2.1.7\n\n  const segments = []\n  if (count < 1) {\n    return segments\n  }\n\n  for (let i = 1; i <= count; i++) {\n    segments.push({ type: buffer.readUInt8(buffer.position) })\n\n    buffer.position++\n  }\n\n  return segments\n}\n\nconst parseGeography = (buffer, isUsingGeometryPoints) => {\n  // s2.1.1 + s.2.1.2\n\n  const srid = buffer.readInt32LE(0)\n  if (srid === -1) {\n    return null\n  }\n\n  const value = {\n    srid,\n    version: buffer.readUInt8(4)\n  }\n\n  const flags = buffer.readUInt8(5)\n  buffer.position = 6\n\n  // console.log(\"srid\", srid)\n  // console.log(\"version\", version)\n\n  const properties = {\n    Z: (flags & (1 << 0)) > 0,\n    M: (flags & (1 << 1)) > 0,\n    V: (flags & (1 << 2)) > 0,\n    P: (flags & (1 << 3)) > 0,\n    L: (flags & (1 << 4)) > 0\n  }\n\n  if (value.version === 2) {\n    properties.H = (flags & (1 << 3)) > 0\n  }\n\n  // console.log(\"properties\", properties);\n\n  let numberOfPoints\n  if (properties.P) {\n    numberOfPoints = 1\n  } else if (properties.L) {\n    numberOfPoints = 2\n  } else {\n    numberOfPoints = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n  }\n\n  // console.log(\"numberOfPoints\", numberOfPoints)\n\n  value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints)\n\n  if (properties.Z) {\n    parseZ(buffer, value.points)\n  }\n\n  if (properties.M) {\n    parseM(buffer, value.points)\n  }\n\n  // console.log(\"points\", points)\n\n  let numberOfFigures\n  if (properties.P) {\n    numberOfFigures = 1\n  } else if (properties.L) {\n    numberOfFigures = 1\n  } else {\n    numberOfFigures = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n  }\n\n  // console.log(\"numberOfFigures\", numberOfFigures)\n\n  value.figures = parseFigures(buffer, numberOfFigures, properties)\n\n  // console.log(\"figures\", figures)\n\n  let numberOfShapes\n  if (properties.P) {\n    numberOfShapes = 1\n  } else if (properties.L) {\n    numberOfShapes = 1\n  } else {\n    numberOfShapes = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n  }\n\n  // console.log(\"numberOfShapes\", numberOfShapes)\n\n  value.shapes = parseShapes(buffer, numberOfShapes, properties)\n\n  // console.log( \"shapes\", shapes)\n\n  if (value.version === 2 && buffer.position < buffer.length) {\n    const numberOfSegments = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n\n    // console.log(\"numberOfSegments\", numberOfSegments)\n\n    value.segments = parseSegments(buffer, numberOfSegments)\n\n    // console.log(\"segments\", segments)\n  } else {\n    value.segments = []\n  }\n\n  return value\n}\n\nmodule.exports.PARSERS = {\n  geography (buffer) {\n    return parseGeography(buffer, /* isUsingGeometryPoints: */false)\n  },\n\n  geometry (buffer) {\n    return parseGeography(buffer, /* isUsingGeometryPoints: */true)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}