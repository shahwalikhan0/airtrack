{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\n/**\n * Checks if the body is a NodeReadable stream which is not supported in Browsers\n */\nfunction isNodeReadableStream(body) {\n  return body && typeof body.pipe === \"function\";\n}\n/**\n * Checks if the body is a ReadableStream supported by browsers\n */\nfunction isReadableStream(body) {\n  return Boolean(body && typeof body.getReader === \"function\" && typeof body.tee === \"function\");\n}\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body) {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  async sendRequest(request) {\n    const url = new URL(request.url);\n    const isInsecure = url.protocol !== \"https:\";\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n    try {\n      return await makeRequest(request);\n    } catch (e) {\n      throw getError(e, request);\n    }\n  }\n}\n/**\n * Sends a request\n */\nasync function makeRequest(request) {\n  const {\n    abortController,\n    abortControllerCleanup\n  } = setupAbortSignal(request);\n  try {\n    const headers = buildFetchHeaders(request.headers);\n    const requestBody = buildRequestBody(request);\n    /**\n     * Developers of the future:\n     * Do not set redirect: \"manual\" as part\n     * of request options.\n     * It will not work as you expect.\n     */\n    const response = await fetch(request.url, {\n      body: requestBody,\n      method: request.method,\n      headers: headers,\n      signal: abortController.signal,\n      credentials: request.withCredentials ? \"include\" : \"same-origin\",\n      cache: \"no-store\"\n    });\n    // If we're uploading a blob, we need to fire the progress event manually\n    if (isBlob(request.body) && request.onUploadProgress) {\n      request.onUploadProgress({\n        loadedBytes: request.body.size\n      });\n    }\n    return buildPipelineResponse(response, request);\n  } finally {\n    if (abortControllerCleanup) {\n      abortControllerCleanup();\n    }\n  }\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(httpResponse, request) {\n  var _a, _b;\n  const headers = buildPipelineHeaders(httpResponse);\n  const response = {\n    request,\n    headers,\n    status: httpResponse.status\n  };\n  const bodyStream = isReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, request.onDownloadProgress) : httpResponse.body;\n  if (\n  // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n  ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n    if (request.enableBrowserStreams) {\n      response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.blobBody = responseStream.blob();\n    }\n  } else {\n    const responseStream = new Response(bodyStream);\n    response.bodyAsText = await responseStream.text();\n  }\n  return response;\n}\nfunction setupAbortSignal(request) {\n  const abortController = new AbortController();\n  // Cleanup function\n  let abortControllerCleanup;\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted.\");\n    }\n    abortListener = event => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      var _a;\n      if (abortListener) {\n        (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n  return {\n    abortController,\n    abortControllerCleanup\n  };\n}\n/**\n * Gets the specific error\n */\nfunction getError(e, request) {\n  var _a;\n  if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n      request\n    });\n  }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n  return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n  return responseHeaders;\n}\nfunction buildRequestBody(request) {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n  return isReadableStream(body) ? buildBodyStream(body, request.onUploadProgress) : body;\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, onProgress) {\n  let loadedBytes = 0;\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(new TransformStream({\n      transform(chunk, controller) {\n        if (chunk === null) {\n          controller.terminate();\n          return;\n        }\n        controller.enqueue(chunk);\n        loadedBytes += chunk.length;\n        if (onProgress) {\n          onProgress({\n            loadedBytes\n          });\n        }\n      }\n    }));\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      async pull(controller) {\n        var _a;\n        const {\n          done,\n          value\n        } = await reader.read();\n        // When no more data needs to be consumed, break the reading\n        if (done || !value) {\n          // Close the stream\n          controller.close();\n          reader.releaseLock();\n          return;\n        }\n        loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;\n        // Enqueue the next data chunk into our target stream\n        controller.enqueue(value);\n        if (onProgress) {\n          onProgress({\n            loadedBytes\n          });\n        }\n      }\n    });\n  }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n  return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}","map":{"version":3,"names":["AbortError","RestError","createHttpHeaders","isNodeReadableStream","body","pipe","isReadableStream","Boolean","getReader","tee","isBlob","Blob","FetchHttpClient","sendRequest","request","url","URL","isInsecure","protocol","allowInsecureConnection","Error","proxySettings","makeRequest","e","getError","abortController","abortControllerCleanup","setupAbortSignal","headers","buildFetchHeaders","requestBody","buildRequestBody","response","fetch","method","signal","credentials","withCredentials","cache","onUploadProgress","loadedBytes","size","buildPipelineResponse","httpResponse","buildPipelineHeaders","status","bodyStream","buildBodyStream","onDownloadProgress","_a","streamResponseStatusCodes","has","Number","POSITIVE_INFINITY","_b","enableBrowserStreams","browserStreamBody","undefined","responseStream","Response","blobBody","blob","bodyAsText","text","AbortController","abortListener","abortSignal","aborted","event","type","abort","addEventListener","removeEventListener","timeout","setTimeout","name","message","code","REQUEST_SEND_ERROR","pipelineHeaders","Headers","value","append","responseHeaders","set","readableStream","onProgress","isTransformStreamSupported","pipeThrough","TransformStream","transform","chunk","controller","terminate","enqueue","length","reader","ReadableStream","pull","done","read","close","releaseLock","createFetchHttpClient","self"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/@azure/core-rest-pipeline/src/fetchHttpClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport {\n  HttpClient,\n  HttpHeaders as PipelineHeaders,\n  PipelineRequest,\n  PipelineResponse,\n  TransferProgressEvent,\n} from \"./interfaces\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\n\n/**\n * Checks if the body is a NodeReadable stream which is not supported in Browsers\n */\nfunction isNodeReadableStream(body: any): body is NodeJS.ReadableStream {\n  return body && typeof body.pipe === \"function\";\n}\n\n/**\n * Checks if the body is a ReadableStream supported by browsers\n */\nfunction isReadableStream(body: unknown): body is ReadableStream {\n  return Boolean(\n    body &&\n      typeof (body as ReadableStream).getReader === \"function\" &&\n      typeof (body as ReadableStream).tee === \"function\"\n  );\n}\n\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body: unknown): body is Blob {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient implements HttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    const url = new URL(request.url);\n    const isInsecure = url.protocol !== \"https:\";\n\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    try {\n      return await makeRequest(request);\n    } catch (e: any) {\n      throw getError(e, request);\n    }\n  }\n}\n\n/**\n * Sends a request\n */\nasync function makeRequest(request: PipelineRequest): Promise<PipelineResponse> {\n  const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n\n  try {\n    const headers = buildFetchHeaders(request.headers);\n    const requestBody = buildRequestBody(request);\n\n    /**\n     * Developers of the future:\n     * Do not set redirect: \"manual\" as part\n     * of request options.\n     * It will not work as you expect.\n     */\n    const response = await fetch(request.url, {\n      body: requestBody,\n      method: request.method,\n      headers: headers,\n      signal: abortController.signal,\n      credentials: request.withCredentials ? \"include\" : \"same-origin\",\n      cache: \"no-store\",\n    });\n    // If we're uploading a blob, we need to fire the progress event manually\n    if (isBlob(request.body) && request.onUploadProgress) {\n      request.onUploadProgress({ loadedBytes: request.body.size });\n    }\n    return buildPipelineResponse(response, request);\n  } finally {\n    if (abortControllerCleanup) {\n      abortControllerCleanup();\n    }\n  }\n}\n\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(httpResponse: Response, request: PipelineRequest) {\n  const headers = buildPipelineHeaders(httpResponse);\n  const response: PipelineResponse = {\n    request,\n    headers,\n    status: httpResponse.status,\n  };\n\n  const bodyStream = isReadableStream(httpResponse.body)\n    ? buildBodyStream(httpResponse.body, request.onDownloadProgress)\n    : httpResponse.body;\n\n  if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||\n    request.streamResponseStatusCodes?.has(response.status)\n  ) {\n    if (request.enableBrowserStreams) {\n      response.browserStreamBody = bodyStream ?? undefined;\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.blobBody = responseStream.blob();\n    }\n  } else {\n    const responseStream = new Response(bodyStream);\n\n    response.bodyAsText = await responseStream.text();\n  }\n\n  return response;\n}\n\nfunction setupAbortSignal(request: PipelineRequest): {\n  abortController: AbortController;\n  abortControllerCleanup: (() => void) | undefined;\n} {\n  const abortController = new AbortController();\n\n  // Cleanup function\n  let abortControllerCleanup: (() => void) | undefined;\n\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener: ((event: any) => void) | undefined;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted.\");\n    }\n\n    abortListener = (event: Event) => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      if (abortListener) {\n        request.abortSignal?.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n\n  return { abortController, abortControllerCleanup };\n}\n\n/**\n * Gets the specific error\n */\nfunction getError(e: RestError, request: PipelineRequest): RestError {\n  if (e && e?.name === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: e?.code ?? RestError.REQUEST_SEND_ERROR,\n      request,\n    });\n  }\n}\n\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders: PipelineHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n\n  return headers;\n}\n\nfunction buildPipelineHeaders(httpResponse: Response): PipelineHeaders {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n\n  return responseHeaders;\n}\n\nfunction buildRequestBody(request: PipelineRequest) {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n\n  return isReadableStream(body) ? buildBodyStream(body, request.onUploadProgress) : body;\n}\n\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(\n  readableStream: ReadableStream<Uint8Array>,\n  onProgress?: (progress: TransferProgressEvent) => void\n): ReadableStream<Uint8Array> {\n  let loadedBytes = 0;\n\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          if (chunk === null) {\n            controller.terminate();\n            return;\n          }\n\n          controller.enqueue(chunk);\n          loadedBytes += chunk.length;\n          if (onProgress) {\n            onProgress({ loadedBytes });\n          }\n        },\n      })\n    );\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      async pull(controller) {\n        const { done, value } = await reader.read();\n        // When no more data needs to be consumed, break the reading\n        if (done || !value) {\n          // Close the stream\n          controller.close();\n          reader.releaseLock();\n          return;\n        }\n\n        loadedBytes += value?.length ?? 0;\n\n        // Enqueue the next data chunk into our target stream\n        controller.enqueue(value);\n\n        if (onProgress) {\n          onProgress({ loadedBytes });\n        }\n      },\n    });\n  }\n}\n\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient(): HttpClient {\n  return new FetchHttpClient();\n}\n\nfunction isTransformStreamSupported(readableStream: ReadableStream): boolean {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}