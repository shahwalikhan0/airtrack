{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options) {\n  const {\n    scopes,\n    getAccessToken,\n    request\n  } = options;\n  const getTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions\n  };\n  const accessToken = await getAccessToken(scopes, getTokenOptions);\n  if (accessToken) {\n    options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n  }\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(options) {\n  var _a;\n  const {\n    credential,\n    scopes,\n    challengeCallbacks\n  } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = Object.assign({\n    authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge\n  }, challengeCallbacks);\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential ? createTokenCycler(credential /* , options */) : () => Promise.resolve(null);\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    async sendRequest(request, next) {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n      }\n      await callbacks.authorizeRequest({\n        scopes: Array.isArray(scopes) ? scopes : [scopes],\n        request,\n        getAccessToken,\n        logger\n      });\n      let response;\n      let error;\n      try {\n        response = await next(request);\n      } catch (err) {\n        error = err;\n        response = err.response;\n      }\n      if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {\n        // processes challenge\n        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          response,\n          getAccessToken,\n          logger\n        });\n        if (shouldSendRequest) {\n          return next(request);\n        }\n      }\n      if (error) {\n        throw error;\n      } else {\n        return response;\n      }\n    }\n  };\n}","map":{"version":3,"names":["createTokenCycler","logger","coreLogger","bearerTokenAuthenticationPolicyName","defaultAuthorizeRequest","options","scopes","getAccessToken","request","getTokenOptions","abortSignal","tracingOptions","accessToken","headers","set","token","getChallenge","response","challenge","get","status","bearerTokenAuthenticationPolicy","credential","challengeCallbacks","callbacks","Object","assign","authorizeRequest","_a","authorizeRequestOnChallenge","Promise","resolve","name","sendRequest","next","url","toLowerCase","startsWith","Error","Array","isArray","error","err","shouldSendRequest"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/@azure/core-rest-pipeline/src/policies/bearerTokenAuthenticationPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport { AzureLogger } from \"@azure/logger\";\nimport { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n\n/**\n * Options sent to the authorizeRequest callback\n */\nexport interface AuthorizeRequestOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options sent to the authorizeRequestOnChallenge callback\n */\nexport interface AuthorizeRequestOnChallengeOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * Response containing the challenge.\n   */\n  response: PipelineResponse;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options to override the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n */\nexport interface ChallengeCallbacks {\n  /**\n   * Allows for the authorization of the main request of this policy before it's sent.\n   */\n  authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;\n  /**\n   * Allows to handle authentication challenges and to re-authorize the request.\n   * The response containing the challenge is `options.response`.\n   * If this method returns true, the underlying request will be sent once again.\n   * The request may be modified before being sent.\n   */\n  authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;\n}\n\n/**\n * Options to configure the bearerTokenAuthenticationPolicy\n */\nexport interface BearerTokenAuthenticationPolicyOptions {\n  /**\n   * The TokenCredential implementation that can supply the bearer token.\n   */\n  credential?: TokenCredential;\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string | string[];\n  /**\n   * Allows for the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n   * If provided, it must contain at least the `authorizeRequestOnChallenge` method.\n   * If provided, after a request is sent, if it has a challenge, it can be processed to re-send the original request with the relevant challenge information.\n   */\n  challengeCallbacks?: ChallengeCallbacks;\n  /**\n   * A logger can be sent for debugging purposes.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options: AuthorizeRequestOptions): Promise<void> {\n  const { scopes, getAccessToken, request } = options;\n  const getTokenOptions: GetTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions,\n  };\n  const accessToken = await getAccessToken(scopes, getTokenOptions);\n\n  if (accessToken) {\n    options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n  }\n}\n\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response: PipelineResponse): string | undefined {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(\n  options: BearerTokenAuthenticationPolicyOptions\n): PipelinePolicy {\n  const { credential, scopes, challengeCallbacks } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = {\n    authorizeRequest: challengeCallbacks?.authorizeRequest ?? defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge,\n    // keep all other properties\n    ...challengeCallbacks,\n  };\n\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential\n    ? createTokenCycler(credential /* , options */)\n    : () => Promise.resolve(null);\n\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\n          \"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\"\n        );\n      }\n\n      await callbacks.authorizeRequest({\n        scopes: Array.isArray(scopes) ? scopes : [scopes],\n        request,\n        getAccessToken,\n        logger,\n      });\n\n      let response: PipelineResponse;\n      let error: Error | undefined;\n      try {\n        response = await next(request);\n      } catch (err: any) {\n        error = err;\n        response = err.response;\n      }\n\n      if (\n        callbacks.authorizeRequestOnChallenge &&\n        response?.status === 401 &&\n        getChallenge(response)\n      ) {\n        // processes challenge\n        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          response,\n          getAccessToken,\n          logger,\n        });\n\n        if (shouldSendRequest) {\n          return next(request);\n        }\n      }\n\n      if (error) {\n        throw error;\n      } else {\n        return response;\n      }\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}