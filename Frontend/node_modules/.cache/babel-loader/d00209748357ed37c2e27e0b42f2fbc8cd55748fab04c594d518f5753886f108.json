{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sendInParallel = sendInParallel;\nexports.sendMessage = sendMessage;\nvar _dgram = _interopRequireDefault(require(\"dgram\"));\nvar _net = _interopRequireDefault(require(\"net\"));\nvar punycode = _interopRequireWildcard(require(\"punycode\"));\nvar _abortError = _interopRequireDefault(require(\"./errors/abort-error\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nasync function sendInParallel(addresses, port, request, signal) {\n  if (signal.aborted) {\n    throw new _abortError.default();\n  }\n  return await new Promise((resolve, reject) => {\n    const sockets = [];\n    let errorCount = 0;\n    const onError = err => {\n      errorCount++;\n      if (errorCount === addresses.length) {\n        signal.removeEventListener('abort', onAbort);\n        clearSockets();\n        reject(err);\n      }\n    };\n    const onMessage = message => {\n      signal.removeEventListener('abort', onAbort);\n      clearSockets();\n      resolve(message);\n    };\n    const onAbort = () => {\n      clearSockets();\n      reject(new _abortError.default());\n    };\n    const clearSockets = () => {\n      for (const socket of sockets) {\n        socket.removeListener('error', onError);\n        socket.removeListener('message', onMessage);\n        socket.close();\n      }\n    };\n    signal.addEventListener('abort', onAbort, {\n      once: true\n    });\n    for (let j = 0; j < addresses.length; j++) {\n      const udpType = addresses[j].family === 6 ? 'udp6' : 'udp4';\n      const socket = _dgram.default.createSocket(udpType);\n      sockets.push(socket);\n      socket.on('error', onError);\n      socket.on('message', onMessage);\n      socket.send(request, 0, request.length, port, addresses[j].address);\n    }\n  });\n}\nasync function sendMessage(host, port, lookup, signal, request) {\n  if (signal.aborted) {\n    throw new _abortError.default();\n  }\n  let addresses;\n  if (_net.default.isIP(host)) {\n    addresses = [{\n      address: host,\n      family: _net.default.isIPv6(host) ? 6 : 4\n    }];\n  } else {\n    addresses = await new Promise((resolve, reject) => {\n      const onAbort = () => {\n        reject(new _abortError.default());\n      };\n      signal.addEventListener('abort', onAbort);\n      lookup(punycode.toASCII(host), {\n        all: true\n      }, (err, addresses) => {\n        signal.removeEventListener('abort', onAbort);\n        err ? reject(err) : resolve(addresses);\n      });\n    });\n  }\n  return await sendInParallel(addresses, port, request, signal);\n}","map":{"version":3,"names":["_dgram","_interopRequireDefault","require","_net","punycode","_interopRequireWildcard","_abortError","sendInParallel","addresses","port","request","signal","aborted","default","Promise","resolve","reject","sockets","errorCount","onError","err","length","removeEventListener","onAbort","clearSockets","onMessage","message","socket","removeListener","close","addEventListener","once","j","udpType","family","createSocket","push","on","send","address","sendMessage","host","lookup","isIP","isIPv6","toASCII","all"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/tedious/src/sender.ts"],"sourcesContent":["import dgram from 'dgram';\nimport dns from 'dns';\nimport net from 'net';\nimport * as punycode from 'punycode';\nimport { AbortSignal } from 'node-abort-controller';\n\nimport AbortError from './errors/abort-error';\n\ntype LookupFunction = (hostname: string, options: dns.LookupAllOptions, callback: (err: NodeJS.ErrnoException | null, addresses: dns.LookupAddress[]) => void) => void;\n\nexport async function sendInParallel(addresses: dns.LookupAddress[], port: number, request: Buffer, signal: AbortSignal) {\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  return await new Promise<Buffer>((resolve, reject) => {\n    const sockets: dgram.Socket[] = [];\n\n    let errorCount = 0;\n\n    const onError = (err: Error) => {\n      errorCount++;\n\n      if (errorCount === addresses.length) {\n        signal.removeEventListener('abort', onAbort);\n        clearSockets();\n\n        reject(err);\n      }\n    };\n\n    const onMessage = (message: Buffer) => {\n      signal.removeEventListener('abort', onAbort);\n      clearSockets();\n\n      resolve(message);\n    };\n\n    const onAbort = () => {\n      clearSockets();\n\n      reject(new AbortError());\n    };\n\n    const clearSockets = () => {\n      for (const socket of sockets) {\n        socket.removeListener('error', onError);\n        socket.removeListener('message', onMessage);\n        socket.close();\n      }\n    };\n\n    signal.addEventListener('abort', onAbort, { once: true });\n\n    for (let j = 0; j < addresses.length; j++) {\n      const udpType = addresses[j].family === 6 ? 'udp6' : 'udp4';\n\n      const socket = dgram.createSocket(udpType);\n      sockets.push(socket);\n      socket.on('error', onError);\n      socket.on('message', onMessage);\n      socket.send(request, 0, request.length, port, addresses[j].address);\n    }\n  });\n}\n\nexport async function sendMessage(host: string, port: number, lookup: LookupFunction, signal: AbortSignal, request: Buffer) {\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  let addresses: dns.LookupAddress[];\n\n  if (net.isIP(host)) {\n    addresses = [\n      { address: host, family: net.isIPv6(host) ? 6 : 4 }\n    ];\n  } else {\n    addresses = await new Promise<dns.LookupAddress[]>((resolve, reject) => {\n      const onAbort = () => {\n        reject(new AbortError());\n      };\n\n      signal.addEventListener('abort', onAbort);\n\n      lookup(punycode.toASCII(host), { all: true }, (err, addresses) => {\n        signal.removeEventListener('abort', onAbort);\n\n        err ? reject(err) : resolve(addresses);\n      });\n    });\n  }\n\n  return await sendInParallel(addresses, port, request, signal);\n}\n"],"mappings":";;;;;;;AAAA,IAAAA,MAAA,GAAAC,sBAAA,CAAAC,OAAA;AAEA,IAAAC,IAAA,GAAAF,sBAAA,CAAAC,OAAA;AACA,IAAAE,QAAA,GAAAC,uBAAA,CAAAH,OAAA;AAGA,IAAAI,WAAA,GAAAL,sBAAA,CAAAC,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIO,eAAeK,cAAfA,CAA8BC,SAA9B,EAA8DC,IAA9D,EAA4EC,OAA5E,EAA6FC,MAA7F,EAAkH;EACvH,IAAIA,MAAM,CAACC,OAAX,EAAoB;IAClB,MAAM,IAAIN,WAAA,CAAAO,OAAJ,EAAN;EACD;EAED,OAAO,MAAM,IAAIC,OAAJ,CAAoB,CAACC,OAAD,EAAUC,MAAV,KAAqB;IACpD,MAAMC,OAAuB,GAAG,EAAhC;IAEA,IAAIC,UAAU,GAAG,CAAjB;IAEA,MAAMC,OAAO,GAAIC,GAAD,IAAgB;MAC9BF,UAAU;MAEV,IAAIA,UAAU,KAAKV,SAAS,CAACa,MAA7B,EAAqC;QACnCV,MAAM,CAACW,mBAAP,CAA2B,OAA3B,EAAoCC,OAApC;QACAC,YAAY;QAEZR,MAAM,CAACI,GAAD,CAAN;MACD;IACF,CATD;IAWA,MAAMK,SAAS,GAAIC,OAAD,IAAqB;MACrCf,MAAM,CAACW,mBAAP,CAA2B,OAA3B,EAAoCC,OAApC;MACAC,YAAY;MAEZT,OAAO,CAACW,OAAD,CAAP;IACD,CALD;IAOA,MAAMH,OAAO,GAAGA,CAAA,KAAM;MACpBC,YAAY;MAEZR,MAAM,CAAC,IAAIV,WAAA,CAAAO,OAAJ,EAAD,CAAN;IACD,CAJD;IAMA,MAAMW,YAAY,GAAGA,CAAA,KAAM;MACzB,KAAK,MAAMG,MAAX,IAAqBV,OAArB,EAA8B;QAC5BU,MAAM,CAACC,cAAP,CAAsB,OAAtB,EAA+BT,OAA/B;QACAQ,MAAM,CAACC,cAAP,CAAsB,SAAtB,EAAiCH,SAAjC;QACAE,MAAM,CAACE,KAAP;MACD;IACF,CAND;IAQAlB,MAAM,CAACmB,gBAAP,CAAwB,OAAxB,EAAiCP,OAAjC,EAA0C;MAAEQ,IAAI,EAAE;IAAR,CAA1C;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,SAAS,CAACa,MAA9B,EAAsCW,CAAC,EAAvC,EAA2C;MACzC,MAAMC,OAAO,GAAGzB,SAAS,CAACwB,CAAD,CAAT,CAAaE,MAAb,KAAwB,CAAxB,GAA4B,MAA5B,GAAqC,MAArD;MAEA,MAAMP,MAAM,GAAG3B,MAAA,CAAAa,OAAA,CAAMsB,YAAN,CAAmBF,OAAnB,CAAf;MACAhB,OAAO,CAACmB,IAAR,CAAaT,MAAb;MACAA,MAAM,CAACU,EAAP,CAAU,OAAV,EAAmBlB,OAAnB;MACAQ,MAAM,CAACU,EAAP,CAAU,SAAV,EAAqBZ,SAArB;MACAE,MAAM,CAACW,IAAP,CAAY5B,OAAZ,EAAqB,CAArB,EAAwBA,OAAO,CAACW,MAAhC,EAAwCZ,IAAxC,EAA8CD,SAAS,CAACwB,CAAD,CAAT,CAAaO,OAA3D;IACD;EACF,CAhDY,CAAb;AAiDD;AAEM,eAAeC,WAAfA,CAA2BC,IAA3B,EAAyChC,IAAzC,EAAuDiC,MAAvD,EAA+E/B,MAA/E,EAAoGD,OAApG,EAAqH;EAC1H,IAAIC,MAAM,CAACC,OAAX,EAAoB;IAClB,MAAM,IAAIN,WAAA,CAAAO,OAAJ,EAAN;EACD;EAED,IAAIL,SAAJ;EAEA,IAAIL,IAAA,CAAAU,OAAA,CAAI8B,IAAJ,CAASF,IAAT,CAAJ,EAAoB;IAClBjC,SAAS,GAAG,CACV;MAAE+B,OAAO,EAAEE,IAAX;MAAiBP,MAAM,EAAE/B,IAAA,CAAAU,OAAA,CAAI+B,MAAJ,CAAWH,IAAX,IAAmB,CAAnB,GAAuB;IAAhD,CADU,CAAZ;EAGD,CAJD,MAIO;IACLjC,SAAS,GAAG,MAAM,IAAIM,OAAJ,CAAiC,CAACC,OAAD,EAAUC,MAAV,KAAqB;MACtE,MAAMO,OAAO,GAAGA,CAAA,KAAM;QACpBP,MAAM,CAAC,IAAIV,WAAA,CAAAO,OAAJ,EAAD,CAAN;MACD,CAFD;MAIAF,MAAM,CAACmB,gBAAP,CAAwB,OAAxB,EAAiCP,OAAjC;MAEAmB,MAAM,CAACtC,QAAQ,CAACyC,OAAT,CAAiBJ,IAAjB,CAAD,EAAyB;QAAEK,GAAG,EAAE;MAAP,CAAzB,EAAwC,CAAC1B,GAAD,EAAMZ,SAAN,KAAoB;QAChEG,MAAM,CAACW,mBAAP,CAA2B,OAA3B,EAAoCC,OAApC;QAEAH,GAAG,GAAGJ,MAAM,CAACI,GAAD,CAAT,GAAiBL,OAAO,CAACP,SAAD,CAA3B;MACD,CAJK,CAAN;IAKD,CAZiB,CAAlB;EAaD;EAED,OAAO,MAAMD,cAAc,CAACC,SAAD,EAAYC,IAAZ,EAAkBC,OAAlB,EAA2BC,MAA3B,CAA3B;AACD"},"metadata":{},"sourceType":"script","externalDependencies":[]}