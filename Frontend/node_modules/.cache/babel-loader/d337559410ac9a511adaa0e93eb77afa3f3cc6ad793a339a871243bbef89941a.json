{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\nconst CollectionFormatToDelimiterMap = {\n  CSV: \",\",\n  SSV: \" \",\n  Multi: \"Multi\",\n  TSV: \"\\t\",\n  Pipes: \"|\"\n};\nexport function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {\n  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);\n  let isAbsolutePath = false;\n  let requestUrl = replaceAll(baseUri, urlReplacements);\n  if (operationSpec.path) {\n    let path = replaceAll(operationSpec.path, urlReplacements);\n    // QUIRK: sometimes we get a path component like /{nextLink}\n    // which may be a fully formed URL with a leading /. In that case, we should\n    // remove the leading /\n    if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n      path = path.substring(1);\n    }\n    // QUIRK: sometimes we get a path component like {nextLink}\n    // which may be a fully formed URL. In that case, we should\n    // ignore the baseUri.\n    if (isAbsoluteUrl(path)) {\n      requestUrl = path;\n      isAbsolutePath = true;\n    } else {\n      requestUrl = appendPath(requestUrl, path);\n    }\n  }\n  const {\n    queryParams,\n    sequenceParams\n  } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);\n  /**\n   * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n   * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n   * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n   * is still being built so there is nothing to overwrite.\n   */\n  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n  return requestUrl;\n}\nfunction replaceAll(input, replacements) {\n  let result = input;\n  for (const [searchValue, replaceValue] of replacements) {\n    result = result.split(searchValue).join(replaceValue);\n  }\n  return result;\n}\nfunction calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {\n  var _a;\n  const result = new Map();\n  if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {\n    for (const urlParameter of operationSpec.urlParameters) {\n      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);\n      const parameterPathString = getPathStringFromParameter(urlParameter);\n      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);\n      if (!urlParameter.skipEncoding) {\n        urlParameterValue = encodeURIComponent(urlParameterValue);\n      }\n      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);\n    }\n  }\n  return result;\n}\nfunction isAbsoluteUrl(url) {\n  return url.includes(\"://\");\n}\nfunction appendPath(url, pathToAppend) {\n  if (!pathToAppend) {\n    return url;\n  }\n  const parsedUrl = new URL(url);\n  let newPath = parsedUrl.pathname;\n  if (!newPath.endsWith(\"/\")) {\n    newPath = `${newPath}/`;\n  }\n  if (pathToAppend.startsWith(\"/\")) {\n    pathToAppend = pathToAppend.substring(1);\n  }\n  const searchStart = pathToAppend.indexOf(\"?\");\n  if (searchStart !== -1) {\n    const path = pathToAppend.substring(0, searchStart);\n    const search = pathToAppend.substring(searchStart + 1);\n    newPath = newPath + path;\n    if (search) {\n      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n    }\n  } else {\n    newPath = newPath + pathToAppend;\n  }\n  parsedUrl.pathname = newPath;\n  return parsedUrl.toString();\n}\nfunction calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {\n  var _a;\n  const result = new Map();\n  const sequenceParams = new Set();\n  if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {\n    for (const queryParameter of operationSpec.queryParameters) {\n      if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n        sequenceParams.add(queryParameter.mapper.serializedName);\n      }\n      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);\n      if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {\n        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : \"\";\n        if (Array.isArray(queryParameterValue)) {\n          // replace null and undefined\n          queryParameterValue = queryParameterValue.map(item => {\n            if (item === null || item === undefined) {\n              return \"\";\n            }\n            return item;\n          });\n        }\n        if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n          continue;\n        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n        if (!queryParameter.skipEncoding) {\n          if (Array.isArray(queryParameterValue)) {\n            queryParameterValue = queryParameterValue.map(item => {\n              return encodeURIComponent(item);\n            });\n          } else {\n            queryParameterValue = encodeURIComponent(queryParameterValue);\n          }\n        }\n        // Join pipes and CSV *after* encoding, or the server will be upset.\n        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n      }\n    }\n  }\n  return {\n    queryParams: result,\n    sequenceParams\n  };\n}\nfunction simpleParseQueryParams(queryString) {\n  const result = new Map();\n  if (!queryString || queryString[0] !== \"?\") {\n    return result;\n  }\n  // remove the leading ?\n  queryString = queryString.slice(1);\n  const pairs = queryString.split(\"&\");\n  for (const pair of pairs) {\n    const [name, value] = pair.split(\"=\", 2);\n    const existingValue = result.get(name);\n    if (existingValue) {\n      if (Array.isArray(existingValue)) {\n        existingValue.push(value);\n      } else {\n        result.set(name, [existingValue, value]);\n      }\n    } else {\n      result.set(name, value);\n    }\n  }\n  return result;\n}\n/** @internal */\nexport function appendQueryParams(url, queryParams, sequenceParams) {\n  let noOverwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (queryParams.size === 0) {\n    return url;\n  }\n  const parsedUrl = new URL(url);\n  // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n  // can change their meaning to the server, such as in the case of a SAS signature.\n  // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n  const combinedParams = simpleParseQueryParams(parsedUrl.search);\n  for (const [name, value] of queryParams) {\n    const existingValue = combinedParams.get(name);\n    if (Array.isArray(existingValue)) {\n      if (Array.isArray(value)) {\n        existingValue.push(...value);\n        const valueSet = new Set(existingValue);\n        combinedParams.set(name, Array.from(valueSet));\n      } else {\n        existingValue.push(value);\n      }\n    } else if (existingValue) {\n      if (Array.isArray(value)) {\n        value.unshift(existingValue);\n      } else if (sequenceParams.has(name)) {\n        combinedParams.set(name, [existingValue, value]);\n      }\n      if (!noOverwrite) {\n        combinedParams.set(name, value);\n      }\n    } else {\n      combinedParams.set(name, value);\n    }\n  }\n  const searchPieces = [];\n  for (const [name, value] of combinedParams) {\n    if (typeof value === \"string\") {\n      searchPieces.push(`${name}=${value}`);\n    } else if (Array.isArray(value)) {\n      // QUIRK: If we get an array of values, include multiple key/value pairs\n      for (const subValue of value) {\n        searchPieces.push(`${name}=${subValue}`);\n      }\n    } else {\n      searchPieces.push(`${name}=${value}`);\n    }\n  }\n  // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n  parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return parsedUrl.toString();\n}","map":{"version":3,"names":["getOperationArgumentValueFromParameter","getPathStringFromParameter","CollectionFormatToDelimiterMap","CSV","SSV","Multi","TSV","Pipes","getRequestUrl","baseUri","operationSpec","operationArguments","fallbackObject","urlReplacements","calculateUrlReplacements","isAbsolutePath","requestUrl","replaceAll","path","startsWith","substring","isAbsoluteUrl","appendPath","queryParams","sequenceParams","calculateQueryParameters","appendQueryParams","input","replacements","result","searchValue","replaceValue","split","join","Map","_a","urlParameters","length","urlParameter","urlParameterValue","parameterPathString","serializer","serialize","mapper","skipEncoding","encodeURIComponent","set","serializedName","url","includes","pathToAppend","parsedUrl","URL","newPath","pathname","endsWith","searchStart","indexOf","search","toString","Set","queryParameters","queryParameter","type","name","add","queryParameterValue","undefined","required","delimiter","collectionFormat","Array","isArray","map","item","simpleParseQueryParams","queryString","slice","pairs","pair","value","existingValue","get","push","noOverwrite","arguments","size","combinedParams","valueSet","from","unshift","has","searchPieces","subValue"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/@azure/core-client/src/urlHelpers.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationArguments, OperationSpec, QueryCollectionFormat } from \"./interfaces\";\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\n\nconst CollectionFormatToDelimiterMap: { [key in QueryCollectionFormat]: string } = {\n  CSV: \",\",\n  SSV: \" \",\n  Multi: \"Multi\",\n  TSV: \"\\t\",\n  Pipes: \"|\",\n};\n\nexport function getRequestUrl(\n  baseUri: string,\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any }\n): string {\n  const urlReplacements = calculateUrlReplacements(\n    operationSpec,\n    operationArguments,\n    fallbackObject\n  );\n\n  let isAbsolutePath = false;\n\n  let requestUrl = replaceAll(baseUri, urlReplacements);\n  if (operationSpec.path) {\n    let path = replaceAll(operationSpec.path, urlReplacements);\n    // QUIRK: sometimes we get a path component like /{nextLink}\n    // which may be a fully formed URL with a leading /. In that case, we should\n    // remove the leading /\n    if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n      path = path.substring(1);\n    }\n    // QUIRK: sometimes we get a path component like {nextLink}\n    // which may be a fully formed URL. In that case, we should\n    // ignore the baseUri.\n    if (isAbsoluteUrl(path)) {\n      requestUrl = path;\n      isAbsolutePath = true;\n    } else {\n      requestUrl = appendPath(requestUrl, path);\n    }\n  }\n\n  const { queryParams, sequenceParams } = calculateQueryParameters(\n    operationSpec,\n    operationArguments,\n    fallbackObject\n  );\n  /**\n   * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n   * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n   * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n   * is still being built so there is nothing to overwrite.\n   */\n  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n\n  return requestUrl;\n}\n\nfunction replaceAll(input: string, replacements: Map<string, string>): string {\n  let result = input;\n  for (const [searchValue, replaceValue] of replacements) {\n    result = result.split(searchValue).join(replaceValue);\n  }\n  return result;\n}\n\nfunction calculateUrlReplacements(\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any }\n): Map<string, string> {\n  const result = new Map<string, string>();\n  if (operationSpec.urlParameters?.length) {\n    for (const urlParameter of operationSpec.urlParameters) {\n      let urlParameterValue: string = getOperationArgumentValueFromParameter(\n        operationArguments,\n        urlParameter,\n        fallbackObject\n      );\n      const parameterPathString = getPathStringFromParameter(urlParameter);\n      urlParameterValue = operationSpec.serializer.serialize(\n        urlParameter.mapper,\n        urlParameterValue,\n        parameterPathString\n      );\n      if (!urlParameter.skipEncoding) {\n        urlParameterValue = encodeURIComponent(urlParameterValue);\n      }\n      result.set(\n        `{${urlParameter.mapper.serializedName || parameterPathString}}`,\n        urlParameterValue\n      );\n    }\n  }\n  return result;\n}\n\nfunction isAbsoluteUrl(url: string): boolean {\n  return url.includes(\"://\");\n}\n\nfunction appendPath(url: string, pathToAppend?: string): string {\n  if (!pathToAppend) {\n    return url;\n  }\n\n  const parsedUrl = new URL(url);\n  let newPath = parsedUrl.pathname;\n\n  if (!newPath.endsWith(\"/\")) {\n    newPath = `${newPath}/`;\n  }\n\n  if (pathToAppend.startsWith(\"/\")) {\n    pathToAppend = pathToAppend.substring(1);\n  }\n\n  const searchStart = pathToAppend.indexOf(\"?\");\n  if (searchStart !== -1) {\n    const path = pathToAppend.substring(0, searchStart);\n    const search = pathToAppend.substring(searchStart + 1);\n    newPath = newPath + path;\n    if (search) {\n      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n    }\n  } else {\n    newPath = newPath + pathToAppend;\n  }\n\n  parsedUrl.pathname = newPath;\n\n  return parsedUrl.toString();\n}\n\nfunction calculateQueryParameters(\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any }\n): {\n  queryParams: Map<string, string | string[]>;\n  sequenceParams: Set<string>;\n} {\n  const result = new Map<string, string | string[]>();\n  const sequenceParams: Set<string> = new Set<string>();\n\n  if (operationSpec.queryParameters?.length) {\n    for (const queryParameter of operationSpec.queryParameters) {\n      if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n        sequenceParams.add(queryParameter.mapper.serializedName);\n      }\n      let queryParameterValue: string | string[] = getOperationArgumentValueFromParameter(\n        operationArguments,\n        queryParameter,\n        fallbackObject\n      );\n      if (\n        (queryParameterValue !== undefined && queryParameterValue !== null) ||\n        queryParameter.mapper.required\n      ) {\n        queryParameterValue = operationSpec.serializer.serialize(\n          queryParameter.mapper,\n          queryParameterValue,\n          getPathStringFromParameter(queryParameter)\n        );\n\n        const delimiter = queryParameter.collectionFormat\n          ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]\n          : \"\";\n        if (Array.isArray(queryParameterValue)) {\n          // replace null and undefined\n          queryParameterValue = queryParameterValue.map((item) => {\n            if (item === null || item === undefined) {\n              return \"\";\n            }\n\n            return item;\n          });\n        }\n        if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n          continue;\n        } else if (\n          Array.isArray(queryParameterValue) &&\n          (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")\n        ) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n        if (!queryParameter.skipEncoding) {\n          if (Array.isArray(queryParameterValue)) {\n            queryParameterValue = queryParameterValue.map((item: string) => {\n              return encodeURIComponent(item);\n            });\n          } else {\n            queryParameterValue = encodeURIComponent(queryParameterValue);\n          }\n        }\n\n        // Join pipes and CSV *after* encoding, or the server will be upset.\n        if (\n          Array.isArray(queryParameterValue) &&\n          (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")\n        ) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n\n        result.set(\n          queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n          queryParameterValue\n        );\n      }\n    }\n  }\n  return {\n    queryParams: result,\n    sequenceParams,\n  };\n}\n\nfunction simpleParseQueryParams(queryString: string): Map<string, string | string[] | undefined> {\n  const result: Map<string, string | string[] | undefined> = new Map<\n    string,\n    string | string[] | undefined\n  >();\n  if (!queryString || queryString[0] !== \"?\") {\n    return result;\n  }\n\n  // remove the leading ?\n  queryString = queryString.slice(1);\n  const pairs = queryString.split(\"&\");\n\n  for (const pair of pairs) {\n    const [name, value] = pair.split(\"=\", 2);\n    const existingValue = result.get(name);\n    if (existingValue) {\n      if (Array.isArray(existingValue)) {\n        existingValue.push(value);\n      } else {\n        result.set(name, [existingValue, value]);\n      }\n    } else {\n      result.set(name, value);\n    }\n  }\n\n  return result;\n}\n\n/** @internal */\nexport function appendQueryParams(\n  url: string,\n  queryParams: Map<string, string | string[]>,\n  sequenceParams: Set<string>,\n  noOverwrite: boolean = false\n): string {\n  if (queryParams.size === 0) {\n    return url;\n  }\n\n  const parsedUrl = new URL(url);\n\n  // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n  // can change their meaning to the server, such as in the case of a SAS signature.\n  // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n  const combinedParams = simpleParseQueryParams(parsedUrl.search);\n\n  for (const [name, value] of queryParams) {\n    const existingValue = combinedParams.get(name);\n    if (Array.isArray(existingValue)) {\n      if (Array.isArray(value)) {\n        existingValue.push(...value);\n        const valueSet = new Set(existingValue);\n        combinedParams.set(name, Array.from(valueSet));\n      } else {\n        existingValue.push(value);\n      }\n    } else if (existingValue) {\n      if (Array.isArray(value)) {\n        value.unshift(existingValue);\n      } else if (sequenceParams.has(name)) {\n        combinedParams.set(name, [existingValue, value]);\n      }\n      if (!noOverwrite) {\n        combinedParams.set(name, value);\n      }\n    } else {\n      combinedParams.set(name, value);\n    }\n  }\n\n  const searchPieces: string[] = [];\n  for (const [name, value] of combinedParams) {\n    if (typeof value === \"string\") {\n      searchPieces.push(`${name}=${value}`);\n    } else if (Array.isArray(value)) {\n      // QUIRK: If we get an array of values, include multiple key/value pairs\n      for (const subValue of value) {\n        searchPieces.push(`${name}=${subValue}`);\n      }\n    } else {\n      searchPieces.push(`${name}=${value}`);\n    }\n  }\n\n  // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n  parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return parsedUrl.toString();\n}\n"],"mappings":"AAAA;AACA;AAGA,SAASA,sCAAsC,QAAQ,oBAAoB;AAC3E,SAASC,0BAA0B,QAAQ,oBAAoB;AAE/D,MAAMC,8BAA8B,GAA+C;EACjFC,GAAG,EAAE,GAAG;EACRC,GAAG,EAAE,GAAG;EACRC,KAAK,EAAE,OAAO;EACdC,GAAG,EAAE,IAAI;EACTC,KAAK,EAAE;CACR;AAED,OAAM,SAAUC,aAAaA,CAC3BC,OAAe,EACfC,aAA4B,EAC5BC,kBAAsC,EACtCC,cAAgD;EAEhD,MAAMC,eAAe,GAAGC,wBAAwB,CAC9CJ,aAAa,EACbC,kBAAkB,EAClBC,cAAc,CACf;EAED,IAAIG,cAAc,GAAG,KAAK;EAE1B,IAAIC,UAAU,GAAGC,UAAU,CAACR,OAAO,EAAEI,eAAe,CAAC;EACrD,IAAIH,aAAa,CAACQ,IAAI,EAAE;IACtB,IAAIA,IAAI,GAAGD,UAAU,CAACP,aAAa,CAACQ,IAAI,EAAEL,eAAe,CAAC;IAC1D;IACA;IACA;IACA,IAAIH,aAAa,CAACQ,IAAI,KAAK,aAAa,IAAIA,IAAI,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;MAChED,IAAI,GAAGA,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC;;IAE1B;IACA;IACA;IACA,IAAIC,aAAa,CAACH,IAAI,CAAC,EAAE;MACvBF,UAAU,GAAGE,IAAI;MACjBH,cAAc,GAAG,IAAI;KACtB,MAAM;MACLC,UAAU,GAAGM,UAAU,CAACN,UAAU,EAAEE,IAAI,CAAC;;;EAI7C,MAAM;IAAEK,WAAW;IAAEC;EAAc,CAAE,GAAGC,wBAAwB,CAC9Df,aAAa,EACbC,kBAAkB,EAClBC,cAAc,CACf;EACD;;;;;;EAMAI,UAAU,GAAGU,iBAAiB,CAACV,UAAU,EAAEO,WAAW,EAAEC,cAAc,EAAET,cAAc,CAAC;EAEvF,OAAOC,UAAU;AACnB;AAEA,SAASC,UAAUA,CAACU,KAAa,EAAEC,YAAiC;EAClE,IAAIC,MAAM,GAAGF,KAAK;EAClB,KAAK,MAAM,CAACG,WAAW,EAAEC,YAAY,CAAC,IAAIH,YAAY,EAAE;IACtDC,MAAM,GAAGA,MAAM,CAACG,KAAK,CAACF,WAAW,CAAC,CAACG,IAAI,CAACF,YAAY,CAAC;;EAEvD,OAAOF,MAAM;AACf;AAEA,SAASf,wBAAwBA,CAC/BJ,aAA4B,EAC5BC,kBAAsC,EACtCC,cAAgD;;EAEhD,MAAMiB,MAAM,GAAG,IAAIK,GAAG,EAAkB;EACxC,IAAI,CAAAC,EAAA,GAAAzB,aAAa,CAAC0B,aAAa,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,MAAM,EAAE;IACvC,KAAK,MAAMC,YAAY,IAAI5B,aAAa,CAAC0B,aAAa,EAAE;MACtD,IAAIG,iBAAiB,GAAWvC,sCAAsC,CACpEW,kBAAkB,EAClB2B,YAAY,EACZ1B,cAAc,CACf;MACD,MAAM4B,mBAAmB,GAAGvC,0BAA0B,CAACqC,YAAY,CAAC;MACpEC,iBAAiB,GAAG7B,aAAa,CAAC+B,UAAU,CAACC,SAAS,CACpDJ,YAAY,CAACK,MAAM,EACnBJ,iBAAiB,EACjBC,mBAAmB,CACpB;MACD,IAAI,CAACF,YAAY,CAACM,YAAY,EAAE;QAC9BL,iBAAiB,GAAGM,kBAAkB,CAACN,iBAAiB,CAAC;;MAE3DV,MAAM,CAACiB,GAAG,CACR,IAAIR,YAAY,CAACK,MAAM,CAACI,cAAc,IAAIP,mBAAmB,GAAG,EAChED,iBAAiB,CAClB;;;EAGL,OAAOV,MAAM;AACf;AAEA,SAASR,aAAaA,CAAC2B,GAAW;EAChC,OAAOA,GAAG,CAACC,QAAQ,CAAC,KAAK,CAAC;AAC5B;AAEA,SAAS3B,UAAUA,CAAC0B,GAAW,EAAEE,YAAqB;EACpD,IAAI,CAACA,YAAY,EAAE;IACjB,OAAOF,GAAG;;EAGZ,MAAMG,SAAS,GAAG,IAAIC,GAAG,CAACJ,GAAG,CAAC;EAC9B,IAAIK,OAAO,GAAGF,SAAS,CAACG,QAAQ;EAEhC,IAAI,CAACD,OAAO,CAACE,QAAQ,CAAC,GAAG,CAAC,EAAE;IAC1BF,OAAO,GAAG,GAAGA,OAAO,GAAG;;EAGzB,IAAIH,YAAY,CAAC/B,UAAU,CAAC,GAAG,CAAC,EAAE;IAChC+B,YAAY,GAAGA,YAAY,CAAC9B,SAAS,CAAC,CAAC,CAAC;;EAG1C,MAAMoC,WAAW,GAAGN,YAAY,CAACO,OAAO,CAAC,GAAG,CAAC;EAC7C,IAAID,WAAW,KAAK,CAAC,CAAC,EAAE;IACtB,MAAMtC,IAAI,GAAGgC,YAAY,CAAC9B,SAAS,CAAC,CAAC,EAAEoC,WAAW,CAAC;IACnD,MAAME,MAAM,GAAGR,YAAY,CAAC9B,SAAS,CAACoC,WAAW,GAAG,CAAC,CAAC;IACtDH,OAAO,GAAGA,OAAO,GAAGnC,IAAI;IACxB,IAAIwC,MAAM,EAAE;MACVP,SAAS,CAACO,MAAM,GAAGP,SAAS,CAACO,MAAM,GAAG,GAAGP,SAAS,CAACO,MAAM,IAAIA,MAAM,EAAE,GAAGA,MAAM;;GAEjF,MAAM;IACLL,OAAO,GAAGA,OAAO,GAAGH,YAAY;;EAGlCC,SAAS,CAACG,QAAQ,GAAGD,OAAO;EAE5B,OAAOF,SAAS,CAACQ,QAAQ,EAAE;AAC7B;AAEA,SAASlC,wBAAwBA,CAC/Bf,aAA4B,EAC5BC,kBAAsC,EACtCC,cAAgD;;EAKhD,MAAMiB,MAAM,GAAG,IAAIK,GAAG,EAA6B;EACnD,MAAMV,cAAc,GAAgB,IAAIoC,GAAG,EAAU;EAErD,IAAI,CAAAzB,EAAA,GAAAzB,aAAa,CAACmD,eAAe,cAAA1B,EAAA,uBAAAA,EAAA,CAAEE,MAAM,EAAE;IACzC,KAAK,MAAMyB,cAAc,IAAIpD,aAAa,CAACmD,eAAe,EAAE;MAC1D,IAAIC,cAAc,CAACnB,MAAM,CAACoB,IAAI,CAACC,IAAI,KAAK,UAAU,IAAIF,cAAc,CAACnB,MAAM,CAACI,cAAc,EAAE;QAC1FvB,cAAc,CAACyC,GAAG,CAACH,cAAc,CAACnB,MAAM,CAACI,cAAc,CAAC;;MAE1D,IAAImB,mBAAmB,GAAsBlE,sCAAsC,CACjFW,kBAAkB,EAClBmD,cAAc,EACdlD,cAAc,CACf;MACD,IACGsD,mBAAmB,KAAKC,SAAS,IAAID,mBAAmB,KAAK,IAAI,IAClEJ,cAAc,CAACnB,MAAM,CAACyB,QAAQ,EAC9B;QACAF,mBAAmB,GAAGxD,aAAa,CAAC+B,UAAU,CAACC,SAAS,CACtDoB,cAAc,CAACnB,MAAM,EACrBuB,mBAAmB,EACnBjE,0BAA0B,CAAC6D,cAAc,CAAC,CAC3C;QAED,MAAMO,SAAS,GAAGP,cAAc,CAACQ,gBAAgB,GAC7CpE,8BAA8B,CAAC4D,cAAc,CAACQ,gBAAgB,CAAC,GAC/D,EAAE;QACN,IAAIC,KAAK,CAACC,OAAO,CAACN,mBAAmB,CAAC,EAAE;UACtC;UACAA,mBAAmB,GAAGA,mBAAmB,CAACO,GAAG,CAAEC,IAAI,IAAI;YACrD,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAKP,SAAS,EAAE;cACvC,OAAO,EAAE;;YAGX,OAAOO,IAAI;UACb,CAAC,CAAC;;QAEJ,IAAIZ,cAAc,CAACQ,gBAAgB,KAAK,OAAO,IAAIJ,mBAAmB,CAAC7B,MAAM,KAAK,CAAC,EAAE;UACnF;SACD,MAAM,IACLkC,KAAK,CAACC,OAAO,CAACN,mBAAmB,CAAC,KACjCJ,cAAc,CAACQ,gBAAgB,KAAK,KAAK,IAAIR,cAAc,CAACQ,gBAAgB,KAAK,KAAK,CAAC,EACxF;UACAJ,mBAAmB,GAAGA,mBAAmB,CAACjC,IAAI,CAACoC,SAAS,CAAC;;QAE3D,IAAI,CAACP,cAAc,CAAClB,YAAY,EAAE;UAChC,IAAI2B,KAAK,CAACC,OAAO,CAACN,mBAAmB,CAAC,EAAE;YACtCA,mBAAmB,GAAGA,mBAAmB,CAACO,GAAG,CAAEC,IAAY,IAAI;cAC7D,OAAO7B,kBAAkB,CAAC6B,IAAI,CAAC;YACjC,CAAC,CAAC;WACH,MAAM;YACLR,mBAAmB,GAAGrB,kBAAkB,CAACqB,mBAAmB,CAAC;;;QAIjE;QACA,IACEK,KAAK,CAACC,OAAO,CAACN,mBAAmB,CAAC,KACjCJ,cAAc,CAACQ,gBAAgB,KAAK,KAAK,IAAIR,cAAc,CAACQ,gBAAgB,KAAK,OAAO,CAAC,EAC1F;UACAJ,mBAAmB,GAAGA,mBAAmB,CAACjC,IAAI,CAACoC,SAAS,CAAC;;QAG3DxC,MAAM,CAACiB,GAAG,CACRgB,cAAc,CAACnB,MAAM,CAACI,cAAc,IAAI9C,0BAA0B,CAAC6D,cAAc,CAAC,EAClFI,mBAAmB,CACpB;;;;EAIP,OAAO;IACL3C,WAAW,EAAEM,MAAM;IACnBL;GACD;AACH;AAEA,SAASmD,sBAAsBA,CAACC,WAAmB;EACjD,MAAM/C,MAAM,GAA+C,IAAIK,GAAG,EAG/D;EACH,IAAI,CAAC0C,WAAW,IAAIA,WAAW,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IAC1C,OAAO/C,MAAM;;EAGf;EACA+C,WAAW,GAAGA,WAAW,CAACC,KAAK,CAAC,CAAC,CAAC;EAClC,MAAMC,KAAK,GAAGF,WAAW,CAAC5C,KAAK,CAAC,GAAG,CAAC;EAEpC,KAAK,MAAM+C,IAAI,IAAID,KAAK,EAAE;IACxB,MAAM,CAACd,IAAI,EAAEgB,KAAK,CAAC,GAAGD,IAAI,CAAC/C,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC;IACxC,MAAMiD,aAAa,GAAGpD,MAAM,CAACqD,GAAG,CAAClB,IAAI,CAAC;IACtC,IAAIiB,aAAa,EAAE;MACjB,IAAIV,KAAK,CAACC,OAAO,CAACS,aAAa,CAAC,EAAE;QAChCA,aAAa,CAACE,IAAI,CAACH,KAAK,CAAC;OAC1B,MAAM;QACLnD,MAAM,CAACiB,GAAG,CAACkB,IAAI,EAAE,CAACiB,aAAa,EAAED,KAAK,CAAC,CAAC;;KAE3C,MAAM;MACLnD,MAAM,CAACiB,GAAG,CAACkB,IAAI,EAAEgB,KAAK,CAAC;;;EAI3B,OAAOnD,MAAM;AACf;AAEA;AACA,OAAM,SAAUH,iBAAiBA,CAC/BsB,GAAW,EACXzB,WAA2C,EAC3CC,cAA2B,EACC;EAAA,IAA5B4D,WAAA,GAAAC,SAAA,CAAAhD,MAAA,QAAAgD,SAAA,QAAAlB,SAAA,GAAAkB,SAAA,MAAuB,KAAK;EAE5B,IAAI9D,WAAW,CAAC+D,IAAI,KAAK,CAAC,EAAE;IAC1B,OAAOtC,GAAG;;EAGZ,MAAMG,SAAS,GAAG,IAAIC,GAAG,CAACJ,GAAG,CAAC;EAE9B;EACA;EACA;EACA,MAAMuC,cAAc,GAAGZ,sBAAsB,CAACxB,SAAS,CAACO,MAAM,CAAC;EAE/D,KAAK,MAAM,CAACM,IAAI,EAAEgB,KAAK,CAAC,IAAIzD,WAAW,EAAE;IACvC,MAAM0D,aAAa,GAAGM,cAAc,CAACL,GAAG,CAAClB,IAAI,CAAC;IAC9C,IAAIO,KAAK,CAACC,OAAO,CAACS,aAAa,CAAC,EAAE;MAChC,IAAIV,KAAK,CAACC,OAAO,CAACQ,KAAK,CAAC,EAAE;QACxBC,aAAa,CAACE,IAAI,CAAC,GAAGH,KAAK,CAAC;QAC5B,MAAMQ,QAAQ,GAAG,IAAI5B,GAAG,CAACqB,aAAa,CAAC;QACvCM,cAAc,CAACzC,GAAG,CAACkB,IAAI,EAAEO,KAAK,CAACkB,IAAI,CAACD,QAAQ,CAAC,CAAC;OAC/C,MAAM;QACLP,aAAa,CAACE,IAAI,CAACH,KAAK,CAAC;;KAE5B,MAAM,IAAIC,aAAa,EAAE;MACxB,IAAIV,KAAK,CAACC,OAAO,CAACQ,KAAK,CAAC,EAAE;QACxBA,KAAK,CAACU,OAAO,CAACT,aAAa,CAAC;OAC7B,MAAM,IAAIzD,cAAc,CAACmE,GAAG,CAAC3B,IAAI,CAAC,EAAE;QACnCuB,cAAc,CAACzC,GAAG,CAACkB,IAAI,EAAE,CAACiB,aAAa,EAAED,KAAK,CAAC,CAAC;;MAElD,IAAI,CAACI,WAAW,EAAE;QAChBG,cAAc,CAACzC,GAAG,CAACkB,IAAI,EAAEgB,KAAK,CAAC;;KAElC,MAAM;MACLO,cAAc,CAACzC,GAAG,CAACkB,IAAI,EAAEgB,KAAK,CAAC;;;EAInC,MAAMY,YAAY,GAAa,EAAE;EACjC,KAAK,MAAM,CAAC5B,IAAI,EAAEgB,KAAK,CAAC,IAAIO,cAAc,EAAE;IAC1C,IAAI,OAAOP,KAAK,KAAK,QAAQ,EAAE;MAC7BY,YAAY,CAACT,IAAI,CAAC,GAAGnB,IAAI,IAAIgB,KAAK,EAAE,CAAC;KACtC,MAAM,IAAIT,KAAK,CAACC,OAAO,CAACQ,KAAK,CAAC,EAAE;MAC/B;MACA,KAAK,MAAMa,QAAQ,IAAIb,KAAK,EAAE;QAC5BY,YAAY,CAACT,IAAI,CAAC,GAAGnB,IAAI,IAAI6B,QAAQ,EAAE,CAAC;;KAE3C,MAAM;MACLD,YAAY,CAACT,IAAI,CAAC,GAAGnB,IAAI,IAAIgB,KAAK,EAAE,CAAC;;;EAIzC;EACA7B,SAAS,CAACO,MAAM,GAAGkC,YAAY,CAACvD,MAAM,GAAG,IAAIuD,YAAY,CAAC3D,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE;EAC1E,OAAOkB,SAAS,CAACQ,QAAQ,EAAE;AAC7B"},"metadata":{},"sourceType":"module","externalDependencies":[]}