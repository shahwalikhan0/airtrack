{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants\";\nimport { tracingClient } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nconst noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options) {\n  // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n  // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n  if (isNode) {\n    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n  }\n  // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient {\n  constructor(options) {\n    var _a, _b;\n    const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;\n    const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;\n    const baseUri = getIdentityClientAuthorityHost(options);\n    if (!baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n    super(Object.assign(Object.assign({\n      requestContentType: \"application/json; charset=utf-8\",\n      retryOptions: {\n        maxRetries: 3\n      }\n    }, options), {\n      userAgentOptions: {\n        userAgentPrefix\n      },\n      baseUri\n    }));\n    this.authorityHost = baseUri;\n    this.abortControllers = new Map();\n    this.allowLoggingAccountIdentifiers = (_b = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b === void 0 ? void 0 : _b.allowLoggingAccountIdentifiers;\n  }\n  async sendTokenRequest(request, expiresOnParser) {\n    logger.info(`IdentityClient: sending token request to [${request.url}]`);\n    const response = await this.sendRequest(request);\n    expiresOnParser = expiresOnParser || (responseBody => {\n      return Date.now() + responseBody.expires_in * 1000;\n    });\n    if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n      const parsedBody = JSON.parse(response.bodyAsText);\n      if (!parsedBody.access_token) {\n        return null;\n      }\n      this.logIdentifiers(response);\n      const token = {\n        accessToken: {\n          token: parsedBody.access_token,\n          expiresOnTimestamp: expiresOnParser(parsedBody)\n        },\n        refreshToken: parsedBody.refresh_token\n      };\n      logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n      return token;\n    } else {\n      const error = new AuthenticationError(response.status, response.bodyAsText);\n      logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n      throw error;\n    }\n  }\n  async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser) {\n    let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    if (refreshToken === undefined) {\n      return null;\n    }\n    logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n    const refreshParams = {\n      grant_type: \"refresh_token\",\n      client_id: clientId,\n      refresh_token: refreshToken,\n      scope: scopes\n    };\n    if (clientSecret !== undefined) {\n      refreshParams.client_secret = clientSecret;\n    }\n    const query = new URLSearchParams(refreshParams);\n    return tracingClient.withSpan(\"IdentityClient.refreshAccessToken\", options, async updatedOptions => {\n      try {\n        const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n        const request = createPipelineRequest({\n          url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,\n          method: \"POST\",\n          body: query.toString(),\n          abortSignal: options.abortSignal,\n          headers: createHttpHeaders({\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n          }),\n          tracingOptions: updatedOptions.tracingOptions\n        });\n        const response = await this.sendTokenRequest(request, expiresOnParser);\n        logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n        return response;\n      } catch (err) {\n        if (err.name === AuthenticationErrorName && err.errorResponse.error === \"interaction_required\") {\n          // It's likely that the refresh token has expired, so\n          // return null so that the credential implementation will\n          // initiate the authentication flow again.\n          logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n          return null;\n        } else {\n          logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n          throw err;\n        }\n      }\n    });\n  }\n  // Here is a custom layer that allows us to abort requests that go through MSAL,\n  // since MSAL doesn't allow us to pass options all the way through.\n  generateAbortSignal(correlationId) {\n    var _this = this;\n    const controller = new AbortController();\n    const controllers = this.abortControllers.get(correlationId) || [];\n    controllers.push(controller);\n    this.abortControllers.set(correlationId, controllers);\n    const existingOnAbort = controller.signal.onabort;\n    controller.signal.onabort = function () {\n      _this.abortControllers.set(correlationId, undefined);\n      if (existingOnAbort) {\n        existingOnAbort(...arguments);\n      }\n    };\n    return controller.signal;\n  }\n  abortRequests(correlationId) {\n    const key = correlationId || noCorrelationId;\n    const controllers = [...(this.abortControllers.get(key) || []),\n    // MSAL passes no correlation ID to the get requests...\n    ...(this.abortControllers.get(noCorrelationId) || [])];\n    if (!controllers.length) {\n      return;\n    }\n    for (const controller of controllers) {\n      controller.abort();\n    }\n    this.abortControllers.set(key, undefined);\n  }\n  getCorrelationId(options) {\n    var _a;\n    const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map(part => part.split(\"=\")).find(_ref => {\n      let [key] = _ref;\n      return key === \"client-request-id\";\n    });\n    return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n  }\n  // The MSAL network module methods follow\n  async sendGetRequestAsync(url, options) {\n    const request = createPipelineRequest({\n      url,\n      method: \"GET\",\n      body: options === null || options === void 0 ? void 0 : options.body,\n      headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n      abortSignal: this.generateAbortSignal(noCorrelationId)\n    });\n    const response = await this.sendRequest(request);\n    this.logIdentifiers(response);\n    return {\n      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n      headers: response.headers.toJSON(),\n      status: response.status\n    };\n  }\n  async sendPostRequestAsync(url, options) {\n    const request = createPipelineRequest({\n      url,\n      method: \"POST\",\n      body: options === null || options === void 0 ? void 0 : options.body,\n      headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n      // MSAL doesn't send the correlation ID on the get requests.\n      abortSignal: this.generateAbortSignal(this.getCorrelationId(options))\n    });\n    const response = await this.sendRequest(request);\n    this.logIdentifiers(response);\n    return {\n      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n      headers: response.headers.toJSON(),\n      status: response.status\n    };\n  }\n  /**\n   * If allowLoggingAccountIdentifiers was set on the constructor options\n   * we try to log the account identifiers by parsing the received access token.\n   *\n   * The account identifiers we try to log are:\n   * - `appid`: The application or Client Identifier.\n   * - `upn`: User Principal Name.\n   *   - It might not be available in some authentication scenarios.\n   *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n   * - `tid`: Tenant Identifier.\n   * - `oid`: Object Identifier of the authenticated user.\n   */\n  logIdentifiers(response) {\n    if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n      return;\n    }\n    const unavailableUpn = \"No User Principal Name available\";\n    try {\n      const parsed = response.parsedBody || JSON.parse(response.bodyAsText);\n      const accessToken = parsed.access_token;\n      if (!accessToken) {\n        // Without an access token allowLoggingAccountIdentifiers isn't useful.\n        return;\n      }\n      const base64Metadata = accessToken.split(\".\")[1];\n      const {\n        appid,\n        upn,\n        tid,\n        oid\n      } = JSON.parse(Buffer.from(base64Metadata, \"base64\").toString(\"utf8\"));\n      logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);\n    } catch (e) {\n      logger.warning(\"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\", e.message);\n    }\n  }\n}","map":{"version":3,"names":["ServiceClient","isNode","createHttpHeaders","createPipelineRequest","AbortController","AuthenticationError","AuthenticationErrorName","getIdentityTokenEndpointSuffix","DefaultAuthorityHost","SDK_VERSION","tracingClient","logger","noCorrelationId","getIdentityClientAuthorityHost","options","authorityHost","process","env","AZURE_AUTHORITY_HOST","IdentityClient","constructor","packageDetails","userAgentPrefix","_a","userAgentOptions","baseUri","startsWith","Error","Object","assign","requestContentType","retryOptions","maxRetries","abortControllers","Map","allowLoggingAccountIdentifiers","_b","loggingOptions","sendTokenRequest","request","expiresOnParser","info","url","response","sendRequest","responseBody","Date","now","expires_in","bodyAsText","status","parsedBody","JSON","parse","access_token","logIdentifiers","token","accessToken","expiresOnTimestamp","refreshToken","refresh_token","error","warning","errorResponse","errorDescription","refreshAccessToken","tenantId","clientId","scopes","clientSecret","arguments","length","undefined","refreshParams","grant_type","client_id","scope","client_secret","query","URLSearchParams","withSpan","updatedOptions","urlSuffix","method","body","toString","abortSignal","headers","Accept","tracingOptions","err","name","generateAbortSignal","correlationId","_this","controller","controllers","get","push","set","existingOnAbort","signal","onabort","abortRequests","key","abort","getCorrelationId","parameter","split","map","part","find","_ref","sendGetRequestAsync","toJSON","sendPostRequestAsync","unavailableUpn","parsed","base64Metadata","appid","upn","tid","oid","Buffer","from","e","message"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/@azure/identity/src/client/identityClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { INetworkModule, NetworkRequestOptions, NetworkResponse } from \"@azure/msal-common\";\nimport { AccessToken, GetTokenOptions } from \"@azure/core-auth\";\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport {\n  PipelineRequest,\n  PipelineResponse,\n  createHttpHeaders,\n  createPipelineRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { AbortController, AbortSignalLike } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants\";\nimport { tracingClient } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nimport { TokenCredentialOptions } from \"../tokenCredentialOptions\";\n\nconst noCorrelationId = \"noCorrelationId\";\n\n/**\n * An internal type used to communicate details of a token request's\n * response that should not be sent back as part of the access token.\n */\nexport interface TokenResponse {\n  /**\n   * The AccessToken to be returned from getToken.\n   */\n  accessToken: AccessToken;\n\n  /**\n   * The refresh token if the 'offline_access' scope was used.\n   */\n  refreshToken?: string;\n}\n\n/**\n * Internal type roughly matching the raw responses of the authentication endpoints.\n *\n * @internal\n */\nexport interface TokenResponseParsedBody {\n  token?: string;\n  access_token?: string;\n  refresh_token?: string;\n  expires_in: number;\n  expires_on?: number | string;\n}\n\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options?: TokenCredentialOptions): string {\n  // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n  let authorityHost = options?.authorityHost;\n\n  // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n  if (isNode) {\n    authorityHost = authorityHost ?? process.env.AZURE_AUTHORITY_HOST;\n  }\n\n  // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n  return authorityHost ?? DefaultAuthorityHost;\n}\n\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient implements INetworkModule {\n  public authorityHost: string;\n  private allowLoggingAccountIdentifiers?: boolean;\n  private abortControllers: Map<string, AbortController[] | undefined>;\n\n  constructor(options?: TokenCredentialOptions) {\n    const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;\n    const userAgentPrefix = options?.userAgentOptions?.userAgentPrefix\n      ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`\n      : `${packageDetails}`;\n\n    const baseUri = getIdentityClientAuthorityHost(options);\n    if (!baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n\n    super({\n      requestContentType: \"application/json; charset=utf-8\",\n      retryOptions: {\n        maxRetries: 3,\n      },\n      ...options,\n      userAgentOptions: {\n        userAgentPrefix,\n      },\n      baseUri,\n    });\n\n    this.authorityHost = baseUri;\n    this.abortControllers = new Map();\n    this.allowLoggingAccountIdentifiers = options?.loggingOptions?.allowLoggingAccountIdentifiers;\n  }\n\n  async sendTokenRequest(\n    request: PipelineRequest,\n    expiresOnParser?: (responseBody: TokenResponseParsedBody) => number\n  ): Promise<TokenResponse | null> {\n    logger.info(`IdentityClient: sending token request to [${request.url}]`);\n    const response = await this.sendRequest(request);\n\n    expiresOnParser =\n      expiresOnParser ||\n      ((responseBody: TokenResponseParsedBody) => {\n        return Date.now() + responseBody.expires_in * 1000;\n      });\n\n    if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n      const parsedBody: TokenResponseParsedBody = JSON.parse(response.bodyAsText);\n\n      if (!parsedBody.access_token) {\n        return null;\n      }\n\n      this.logIdentifiers(response);\n\n      const token = {\n        accessToken: {\n          token: parsedBody.access_token,\n          expiresOnTimestamp: expiresOnParser(parsedBody),\n        },\n        refreshToken: parsedBody.refresh_token,\n      };\n\n      logger.info(\n        `IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`\n      );\n      return token;\n    } else {\n      const error = new AuthenticationError(response.status, response.bodyAsText);\n      logger.warning(\n        `IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`\n      );\n      throw error;\n    }\n  }\n\n  async refreshAccessToken(\n    tenantId: string,\n    clientId: string,\n    scopes: string,\n    refreshToken: string | undefined,\n    clientSecret: string | undefined,\n    expiresOnParser?: (responseBody: TokenResponseParsedBody) => number,\n    options: GetTokenOptions = {}\n  ): Promise<TokenResponse | null> {\n    if (refreshToken === undefined) {\n      return null;\n    }\n    logger.info(\n      `IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`\n    );\n\n    const refreshParams = {\n      grant_type: \"refresh_token\",\n      client_id: clientId,\n      refresh_token: refreshToken,\n      scope: scopes,\n    };\n\n    if (clientSecret !== undefined) {\n      (refreshParams as any).client_secret = clientSecret;\n    }\n\n    const query = new URLSearchParams(refreshParams);\n\n    return tracingClient.withSpan(\n      \"IdentityClient.refreshAccessToken\",\n      options,\n      async (updatedOptions) => {\n        try {\n          const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n          const request = createPipelineRequest({\n            url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,\n            method: \"POST\",\n            body: query.toString(),\n            abortSignal: options.abortSignal,\n            headers: createHttpHeaders({\n              Accept: \"application/json\",\n              \"Content-Type\": \"application/x-www-form-urlencoded\",\n            }),\n            tracingOptions: updatedOptions.tracingOptions,\n          });\n\n          const response = await this.sendTokenRequest(request, expiresOnParser);\n          logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n          return response;\n        } catch (err: any) {\n          if (\n            err.name === AuthenticationErrorName &&\n            err.errorResponse.error === \"interaction_required\"\n          ) {\n            // It's likely that the refresh token has expired, so\n            // return null so that the credential implementation will\n            // initiate the authentication flow again.\n            logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n            return null;\n          } else {\n            logger.warning(\n              `IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`\n            );\n            throw err;\n          }\n        }\n      }\n    );\n  }\n\n  // Here is a custom layer that allows us to abort requests that go through MSAL,\n  // since MSAL doesn't allow us to pass options all the way through.\n\n  generateAbortSignal(correlationId: string): AbortSignalLike {\n    const controller = new AbortController();\n    const controllers = this.abortControllers.get(correlationId) || [];\n    controllers.push(controller);\n    this.abortControllers.set(correlationId, controllers);\n    const existingOnAbort = controller.signal.onabort;\n    controller.signal.onabort = (...params) => {\n      this.abortControllers.set(correlationId, undefined);\n      if (existingOnAbort) {\n        existingOnAbort(...params);\n      }\n    };\n    return controller.signal;\n  }\n\n  abortRequests(correlationId?: string): void {\n    const key = correlationId || noCorrelationId;\n    const controllers = [\n      ...(this.abortControllers.get(key) || []),\n      // MSAL passes no correlation ID to the get requests...\n      ...(this.abortControllers.get(noCorrelationId) || []),\n    ];\n    if (!controllers.length) {\n      return;\n    }\n    for (const controller of controllers) {\n      controller.abort();\n    }\n    this.abortControllers.set(key, undefined);\n  }\n\n  getCorrelationId(options?: NetworkRequestOptions): string {\n    const parameter = options?.body\n      ?.split(\"&\")\n      .map((part) => part.split(\"=\"))\n      .find(([key]) => key === \"client-request-id\");\n    return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n  }\n\n  // The MSAL network module methods follow\n\n  async sendGetRequestAsync<T>(\n    url: string,\n    options?: NetworkRequestOptions\n  ): Promise<NetworkResponse<T>> {\n    const request = createPipelineRequest({\n      url,\n      method: \"GET\",\n      body: options?.body,\n      headers: createHttpHeaders(options?.headers),\n      abortSignal: this.generateAbortSignal(noCorrelationId),\n    });\n\n    const response = await this.sendRequest(request);\n\n    this.logIdentifiers(response);\n\n    return {\n      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n      headers: response.headers.toJSON(),\n      status: response.status,\n    };\n  }\n\n  async sendPostRequestAsync<T>(\n    url: string,\n    options?: NetworkRequestOptions\n  ): Promise<NetworkResponse<T>> {\n    const request = createPipelineRequest({\n      url,\n      method: \"POST\",\n      body: options?.body,\n      headers: createHttpHeaders(options?.headers),\n      // MSAL doesn't send the correlation ID on the get requests.\n      abortSignal: this.generateAbortSignal(this.getCorrelationId(options)),\n    });\n\n    const response = await this.sendRequest(request);\n\n    this.logIdentifiers(response);\n\n    return {\n      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n      headers: response.headers.toJSON(),\n      status: response.status,\n    };\n  }\n\n  /**\n   * If allowLoggingAccountIdentifiers was set on the constructor options\n   * we try to log the account identifiers by parsing the received access token.\n   *\n   * The account identifiers we try to log are:\n   * - `appid`: The application or Client Identifier.\n   * - `upn`: User Principal Name.\n   *   - It might not be available in some authentication scenarios.\n   *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n   * - `tid`: Tenant Identifier.\n   * - `oid`: Object Identifier of the authenticated user.\n   */\n  private logIdentifiers(response: PipelineResponse): void {\n    if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n      return;\n    }\n    const unavailableUpn = \"No User Principal Name available\";\n    try {\n      const parsed = (response as any).parsedBody || JSON.parse(response.bodyAsText);\n      const accessToken = parsed.access_token;\n      if (!accessToken) {\n        // Without an access token allowLoggingAccountIdentifiers isn't useful.\n        return;\n      }\n      const base64Metadata = accessToken.split(\".\")[1];\n      const { appid, upn, tid, oid } = JSON.parse(\n        Buffer.from(base64Metadata, \"base64\").toString(\"utf8\")\n      );\n\n      logger.info(\n        `[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${\n          upn || unavailableUpn\n        }. Object ID (user): ${oid}`\n      );\n    } catch (e: any) {\n      logger.warning(\n        \"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\",\n        e.message\n      );\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}