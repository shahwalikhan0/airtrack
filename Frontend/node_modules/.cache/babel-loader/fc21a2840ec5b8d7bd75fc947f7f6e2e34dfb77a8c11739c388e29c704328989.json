{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as msalCommon from \"@azure/msal-common\";\nimport { isNode } from \"@azure/core-util\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { formatError, formatSuccess } from \"../util/logging\";\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../errors\";\nimport { DefaultAuthorityHost, DefaultTenantId } from \"../constants\";\n/**\n * Latest AuthenticationRecord version\n * @internal\n */\nconst LatestAuthenticationRecordVersion = \"1.0\";\n/**\n * Ensures the validity of the MSAL token\n * @internal\n */\nexport function ensureValidMsalToken(scopes, logger, msalToken, getTokenOptions) {\n  const error = message => {\n    logger.getToken.info(message);\n    return new AuthenticationRequiredError({\n      scopes: Array.isArray(scopes) ? scopes : [scopes],\n      getTokenOptions,\n      message\n    });\n  };\n  if (!msalToken) {\n    throw error(\"No response\");\n  }\n  if (!msalToken.expiresOn) {\n    throw error(`Response had no \"expiresOn\" property.`);\n  }\n  if (!msalToken.accessToken) {\n    throw error(`Response had no \"accessToken\" property.`);\n  }\n}\n/**\n * Generates a valid authority by combining a host with a tenantId.\n * @internal\n */\nexport function getAuthority(tenantId, host) {\n  if (!host) {\n    host = DefaultAuthorityHost;\n  }\n  if (new RegExp(`${tenantId}/?$`).test(host)) {\n    return host;\n  }\n  if (host.endsWith(\"/\")) {\n    return host + tenantId;\n  } else {\n    return `${host}/${tenantId}`;\n  }\n}\n/**\n * Generates the known authorities.\n * If the Tenant Id is `adfs`, the authority can't be validated since the format won't match the expected one.\n * For that reason, we have to force MSAL to disable validating the authority\n * by sending it within the known authorities in the MSAL configuration.\n * @internal\n */\nexport function getKnownAuthorities(tenantId, authorityHost) {\n  if (tenantId === \"adfs\" && authorityHost) {\n    return [authorityHost];\n  }\n  return [];\n}\n/**\n * Generates a logger that can be passed to the MSAL clients.\n * @param logger - The logger of the credential.\n * @internal\n */\nexport const defaultLoggerCallback = function (logger) {\n  let platform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isNode ? \"Node\" : \"Browser\";\n  return (level, message, containsPii) => {\n    if (containsPii) {\n      return;\n    }\n    switch (level) {\n      case msalCommon.LogLevel.Error:\n        logger.info(`MSAL ${platform} V2 error: ${message}`);\n        return;\n      case msalCommon.LogLevel.Info:\n        logger.info(`MSAL ${platform} V2 info message: ${message}`);\n        return;\n      case msalCommon.LogLevel.Verbose:\n        logger.info(`MSAL ${platform} V2 verbose message: ${message}`);\n        return;\n      case msalCommon.LogLevel.Warning:\n        logger.info(`MSAL ${platform} V2 warning: ${message}`);\n        return;\n    }\n  };\n};\n/**\n * The common utility functions for the MSAL clients.\n * Defined as a class so that the classes extending this one can have access to its methods and protected properties.\n *\n * It keeps track of a logger and an in-memory copy of the AuthenticationRecord.\n *\n * @internal\n */\nexport class MsalBaseUtilities {\n  constructor(options) {\n    this.logger = options.logger;\n    this.account = options.authenticationRecord;\n  }\n  /**\n   * Generates a UUID\n   */\n  generateUuid() {\n    return uuidv4();\n  }\n  /**\n   * Handles the MSAL authentication result.\n   * If the result has an account, we update the local account reference.\n   * If the token received is invalid, an error will be thrown depending on what's missing.\n   */\n  handleResult(scopes, clientId, result, getTokenOptions) {\n    if (result === null || result === void 0 ? void 0 : result.account) {\n      this.account = msalToPublic(clientId, result.account);\n    }\n    ensureValidMsalToken(scopes, this.logger, result, getTokenOptions);\n    this.logger.getToken.info(formatSuccess(scopes));\n    return {\n      token: result.accessToken,\n      expiresOnTimestamp: result.expiresOn.getTime()\n    };\n  }\n  /**\n   * Handles MSAL errors.\n   */\n  handleError(scopes, error, getTokenOptions) {\n    if (error.name === \"AuthError\" || error.name === \"ClientAuthError\" || error.name === \"BrowserAuthError\") {\n      const msalError = error;\n      switch (msalError.errorCode) {\n        case \"endpoints_resolution_error\":\n          this.logger.info(formatError(scopes, error.message));\n          return new CredentialUnavailableError(error.message);\n        case \"device_code_polling_cancelled\":\n          return new AbortError(\"The authentication has been aborted by the caller.\");\n        case \"consent_required\":\n        case \"interaction_required\":\n        case \"login_required\":\n          this.logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));\n          break;\n        default:\n          this.logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));\n          break;\n      }\n    }\n    if (error.name === \"ClientConfigurationError\" || error.name === \"BrowserConfigurationAuthError\" || error.name === \"AbortError\") {\n      return error;\n    }\n    return new AuthenticationRequiredError({\n      scopes,\n      getTokenOptions,\n      message: error.message\n    });\n  }\n}\n// transformations.ts\nexport function publicToMsal(account) {\n  const [environment] = account.authority.match(/([a-z]*\\.[a-z]*\\.[a-z]*)/) || [];\n  return Object.assign(Object.assign({}, account), {\n    localAccountId: account.homeAccountId,\n    environment\n  });\n}\nexport function msalToPublic(clientId, account) {\n  const record = {\n    authority: getAuthority(account.tenantId, account.environment),\n    homeAccountId: account.homeAccountId,\n    tenantId: account.tenantId || DefaultTenantId,\n    username: account.username,\n    clientId,\n    version: LatestAuthenticationRecordVersion\n  };\n  return record;\n}\n/**\n * Serializes an `AuthenticationRecord` into a string.\n *\n * The output of a serialized authentication record will contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * To later convert this string to a serialized `AuthenticationRecord`, please use the exported function `deserializeAuthenticationRecord()`.\n */\nexport function serializeAuthenticationRecord(record) {\n  return JSON.stringify(record);\n}\n/**\n * Deserializes a previously serialized authentication record from a string into an object.\n *\n * The input string must contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * If the version we receive is unsupported, an error will be thrown.\n *\n * At the moment, the only available version is: \"1.0\", which is always set when the authentication record is serialized.\n *\n * @param serializedRecord - Authentication record previously serialized into string.\n * @returns AuthenticationRecord.\n */\nexport function deserializeAuthenticationRecord(serializedRecord) {\n  const parsed = JSON.parse(serializedRecord);\n  if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {\n    throw Error(\"Unsupported AuthenticationRecord version\");\n  }\n  return parsed;\n}","map":{"version":3,"names":["msalCommon","isNode","AbortError","v4","uuidv4","formatError","formatSuccess","AuthenticationRequiredError","CredentialUnavailableError","DefaultAuthorityHost","DefaultTenantId","LatestAuthenticationRecordVersion","ensureValidMsalToken","scopes","logger","msalToken","getTokenOptions","error","message","getToken","info","Array","isArray","expiresOn","accessToken","getAuthority","tenantId","host","RegExp","test","endsWith","getKnownAuthorities","authorityHost","defaultLoggerCallback","platform","arguments","length","undefined","level","containsPii","LogLevel","Error","Info","Verbose","Warning","MsalBaseUtilities","constructor","options","account","authenticationRecord","generateUuid","handleResult","clientId","result","msalToPublic","token","expiresOnTimestamp","getTime","handleError","name","msalError","errorCode","publicToMsal","environment","authority","match","Object","assign","localAccountId","homeAccountId","record","username","version","serializeAuthenticationRecord","JSON","stringify","deserializeAuthenticationRecord","serializedRecord","parsed","parse"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/@azure/identity/src/msal/utils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as msalCommon from \"@azure/msal-common\";\nimport { isNode } from \"@azure/core-util\";\nimport { AccessToken, GetTokenOptions } from \"@azure/core-auth\";\nimport { AbortError } from \"@azure/abort-controller\";\n\nimport { v4 as uuidv4 } from \"uuid\";\nimport { CredentialLogger, formatError, formatSuccess } from \"../util/logging\";\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../errors\";\nimport { DefaultAuthorityHost, DefaultTenantId } from \"../constants\";\nimport { AuthenticationRecord, MsalAccountInfo, MsalResult, MsalToken } from \"./types\";\nimport { MsalFlowOptions } from \"./flows\";\n\n/**\n * Latest AuthenticationRecord version\n * @internal\n */\nconst LatestAuthenticationRecordVersion = \"1.0\";\n\n/**\n * Ensures the validity of the MSAL token\n * @internal\n */\nexport function ensureValidMsalToken(\n  scopes: string | string[],\n  logger: CredentialLogger,\n  msalToken?: MsalToken,\n  getTokenOptions?: GetTokenOptions\n): void {\n  const error = (message: string): Error => {\n    logger.getToken.info(message);\n    return new AuthenticationRequiredError({\n      scopes: Array.isArray(scopes) ? scopes : [scopes],\n      getTokenOptions,\n      message,\n    });\n  };\n  if (!msalToken) {\n    throw error(\"No response\");\n  }\n  if (!msalToken.expiresOn) {\n    throw error(`Response had no \"expiresOn\" property.`);\n  }\n  if (!msalToken.accessToken) {\n    throw error(`Response had no \"accessToken\" property.`);\n  }\n}\n\n/**\n * Generates a valid authority by combining a host with a tenantId.\n * @internal\n */\nexport function getAuthority(tenantId: string, host?: string): string {\n  if (!host) {\n    host = DefaultAuthorityHost;\n  }\n  if (new RegExp(`${tenantId}/?$`).test(host)) {\n    return host;\n  }\n  if (host.endsWith(\"/\")) {\n    return host + tenantId;\n  } else {\n    return `${host}/${tenantId}`;\n  }\n}\n\n/**\n * Generates the known authorities.\n * If the Tenant Id is `adfs`, the authority can't be validated since the format won't match the expected one.\n * For that reason, we have to force MSAL to disable validating the authority\n * by sending it within the known authorities in the MSAL configuration.\n * @internal\n */\nexport function getKnownAuthorities(tenantId: string, authorityHost: string): string[] {\n  if (tenantId === \"adfs\" && authorityHost) {\n    return [authorityHost];\n  }\n  return [];\n}\n\n/**\n * Generates a logger that can be passed to the MSAL clients.\n * @param logger - The logger of the credential.\n * @internal\n */\nexport const defaultLoggerCallback: (\n  logger: CredentialLogger,\n  platform?: \"Node\" | \"Browser\"\n) => msalCommon.ILoggerCallback =\n  (logger: CredentialLogger, platform: \"Node\" | \"Browser\" = isNode ? \"Node\" : \"Browser\") =>\n  (level, message, containsPii): void => {\n    if (containsPii) {\n      return;\n    }\n    switch (level) {\n      case msalCommon.LogLevel.Error:\n        logger.info(`MSAL ${platform} V2 error: ${message}`);\n        return;\n      case msalCommon.LogLevel.Info:\n        logger.info(`MSAL ${platform} V2 info message: ${message}`);\n        return;\n      case msalCommon.LogLevel.Verbose:\n        logger.info(`MSAL ${platform} V2 verbose message: ${message}`);\n        return;\n      case msalCommon.LogLevel.Warning:\n        logger.info(`MSAL ${platform} V2 warning: ${message}`);\n        return;\n    }\n  };\n\n/**\n * The common utility functions for the MSAL clients.\n * Defined as a class so that the classes extending this one can have access to its methods and protected properties.\n *\n * It keeps track of a logger and an in-memory copy of the AuthenticationRecord.\n *\n * @internal\n */\nexport class MsalBaseUtilities {\n  protected logger: CredentialLogger;\n  protected account: AuthenticationRecord | undefined;\n\n  constructor(options: MsalFlowOptions) {\n    this.logger = options.logger;\n    this.account = options.authenticationRecord;\n  }\n\n  /**\n   * Generates a UUID\n   */\n  generateUuid(): string {\n    return uuidv4();\n  }\n\n  /**\n   * Handles the MSAL authentication result.\n   * If the result has an account, we update the local account reference.\n   * If the token received is invalid, an error will be thrown depending on what's missing.\n   */\n  protected handleResult(\n    scopes: string | string[],\n    clientId: string,\n    result?: MsalResult,\n    getTokenOptions?: GetTokenOptions\n  ): AccessToken {\n    if (result?.account) {\n      this.account = msalToPublic(clientId, result.account);\n    }\n    ensureValidMsalToken(scopes, this.logger, result, getTokenOptions);\n    this.logger.getToken.info(formatSuccess(scopes));\n    return {\n      token: result!.accessToken!,\n      expiresOnTimestamp: result!.expiresOn!.getTime(),\n    };\n  }\n\n  /**\n   * Handles MSAL errors.\n   */\n  protected handleError(scopes: string[], error: Error, getTokenOptions?: GetTokenOptions): Error {\n    if (\n      error.name === \"AuthError\" ||\n      error.name === \"ClientAuthError\" ||\n      error.name === \"BrowserAuthError\"\n    ) {\n      const msalError = error as msalCommon.AuthError;\n      switch (msalError.errorCode) {\n        case \"endpoints_resolution_error\":\n          this.logger.info(formatError(scopes, error.message));\n          return new CredentialUnavailableError(error.message);\n        case \"device_code_polling_cancelled\":\n          return new AbortError(\"The authentication has been aborted by the caller.\");\n        case \"consent_required\":\n        case \"interaction_required\":\n        case \"login_required\":\n          this.logger.info(\n            formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`)\n          );\n          break;\n        default:\n          this.logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));\n          break;\n      }\n    }\n    if (\n      error.name === \"ClientConfigurationError\" ||\n      error.name === \"BrowserConfigurationAuthError\" ||\n      error.name === \"AbortError\"\n    ) {\n      return error;\n    }\n    return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });\n  }\n}\n\n// transformations.ts\n\nexport function publicToMsal(account: AuthenticationRecord): msalCommon.AccountInfo {\n  const [environment] = account.authority.match(/([a-z]*\\.[a-z]*\\.[a-z]*)/) || [];\n  return {\n    ...account,\n    localAccountId: account.homeAccountId,\n    environment,\n  };\n}\n\nexport function msalToPublic(clientId: string, account: MsalAccountInfo): AuthenticationRecord {\n  const record = {\n    authority: getAuthority(account.tenantId, account.environment),\n    homeAccountId: account.homeAccountId,\n    tenantId: account.tenantId || DefaultTenantId,\n    username: account.username,\n    clientId,\n    version: LatestAuthenticationRecordVersion,\n  };\n  return record;\n}\n\n/**\n * Serializes an `AuthenticationRecord` into a string.\n *\n * The output of a serialized authentication record will contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * To later convert this string to a serialized `AuthenticationRecord`, please use the exported function `deserializeAuthenticationRecord()`.\n */\nexport function serializeAuthenticationRecord(record: AuthenticationRecord): string {\n  return JSON.stringify(record);\n}\n\n/**\n * Deserializes a previously serialized authentication record from a string into an object.\n *\n * The input string must contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * If the version we receive is unsupported, an error will be thrown.\n *\n * At the moment, the only available version is: \"1.0\", which is always set when the authentication record is serialized.\n *\n * @param serializedRecord - Authentication record previously serialized into string.\n * @returns AuthenticationRecord.\n */\nexport function deserializeAuthenticationRecord(serializedRecord: string): AuthenticationRecord {\n  const parsed: AuthenticationRecord & { version?: string } = JSON.parse(serializedRecord);\n\n  if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {\n    throw Error(\"Unsupported AuthenticationRecord version\");\n  }\n\n  return parsed;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}