{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTracingClient } from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants\";\nimport { getUserAgentValue } from \"../util/userAgent\";\nimport { logger } from \"../log\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError\";\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n  const tracingClient = tryCreateTracingClient();\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request, next) {\n      var _a, _b;\n      if (!tracingClient || !((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext)) {\n        return next(request);\n      }\n      const {\n        span,\n        tracingContext\n      } = (_b = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {};\n      if (!span || !tracingContext) {\n        return next(request);\n      }\n      try {\n        const response = await tracingClient.withContext(tracingContext, next, request);\n        tryProcessResponse(span, response);\n        return response;\n      } catch (err) {\n        tryProcessError(span, err);\n        throw err;\n      }\n    }\n  };\n}\nfunction tryCreateTracingClient() {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION\n    });\n  } catch (e) {\n    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\nfunction tryCreateSpan(tracingClient, request, userAgent) {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    const {\n      span,\n      updatedOptions\n    } = tracingClient.startSpan(`HTTP ${request.method}`, {\n      tracingOptions: request.tracingOptions\n    }, {\n      spanKind: \"client\",\n      spanAttributes: {\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId\n      }\n    });\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n    if (userAgent) {\n      span.setAttribute(\"http.user_agent\", userAgent);\n    }\n    // set headers\n    const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);\n    for (const [key, value] of Object.entries(headers)) {\n      request.headers.set(key, value);\n    }\n    return {\n      span,\n      tracingContext: updatedOptions.tracingOptions.tracingContext\n    };\n  } catch (e) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\nfunction tryProcessError(span, error) {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\nfunction tryProcessResponse(span, response) {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    span.setStatus({\n      status: \"success\"\n    });\n    span.end();\n  } catch (e) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}","map":{"version":3,"names":["createTracingClient","SDK_VERSION","getUserAgentValue","logger","getErrorMessage","isError","isRestError","tracingPolicyName","tracingPolicy","options","arguments","length","undefined","userAgent","userAgentPrefix","tracingClient","tryCreateTracingClient","name","sendRequest","request","next","_a","tracingOptions","tracingContext","span","_b","tryCreateSpan","response","withContext","tryProcessResponse","err","tryProcessError","namespace","packageName","packageVersion","e","warning","updatedOptions","startSpan","method","spanKind","spanAttributes","url","requestId","isRecording","end","setAttribute","headers","createRequestHeaders","key","value","Object","entries","set","error","setStatus","status","statusCode","serviceRequestId","get"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/@azure/core-rest-pipeline/src/policies/tracingPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  TracingClient,\n  TracingContext,\n  TracingSpan,\n  createTracingClient,\n} from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants\";\nimport { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { getUserAgentValue } from \"../util/userAgent\";\nimport { logger } from \"../log\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError\";\n\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n\n/**\n * Options to configure the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * String prefix to add to the user agent logged as metadata\n   * on the generated Span.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n  const tracingClient = tryCreateTracingClient();\n\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!tracingClient || !request.tracingOptions?.tracingContext) {\n        return next(request);\n      }\n\n      const { span, tracingContext } = tryCreateSpan(tracingClient, request, userAgent) ?? {};\n\n      if (!span || !tracingContext) {\n        return next(request);\n      }\n\n      try {\n        const response = await tracingClient.withContext(tracingContext, next, request);\n        tryProcessResponse(span, response);\n        return response;\n      } catch (err: any) {\n        tryProcessError(span, err);\n        throw err;\n      }\n    },\n  };\n}\n\nfunction tryCreateTracingClient(): TracingClient | undefined {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION,\n    });\n  } catch (e: unknown) {\n    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryCreateSpan(\n  tracingClient: TracingClient,\n  request: PipelineRequest,\n  userAgent?: string\n): { span: TracingSpan; tracingContext: TracingContext } | undefined {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    const { span, updatedOptions } = tracingClient.startSpan(\n      `HTTP ${request.method}`,\n      { tracingOptions: request.tracingOptions },\n      {\n        spanKind: \"client\",\n        spanAttributes: {\n          \"http.method\": request.method,\n          \"http.url\": request.url,\n          requestId: request.requestId,\n        },\n      }\n    );\n\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n\n    if (userAgent) {\n      span.setAttribute(\"http.user_agent\", userAgent);\n    }\n\n    // set headers\n    const headers = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions.tracingContext\n    );\n    for (const [key, value] of Object.entries(headers)) {\n      request.headers.set(key, value);\n    }\n    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };\n  } catch (e: any) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryProcessError(span: TracingSpan, error: unknown): void {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined,\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n\nfunction tryProcessResponse(span: TracingSpan, response: PipelineResponse): void {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    span.setStatus({\n      status: \"success\",\n    });\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n"],"mappings":"AAAA;AACA;AAEA,SAIEA,mBAAmB,QACd,qBAAqB;AAC5B,SAASC,WAAW,QAAQ,cAAc;AAG1C,SAASC,iBAAiB,QAAQ,mBAAmB;AACrD,SAASC,MAAM,QAAQ,QAAQ;AAC/B,SAASC,eAAe,EAAEC,OAAO,QAAQ,kBAAkB;AAC3D,SAASC,WAAW,QAAQ,cAAc;AAE1C;;;AAGA,OAAO,MAAMC,iBAAiB,GAAG,eAAe;AAchD;;;;;;AAMA,OAAM,SAAUC,aAAaA,CAAA,EAAmC;EAAA,IAAlCC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAgC,EAAE;EAC9D,MAAMG,SAAS,GAAGX,iBAAiB,CAACO,OAAO,CAACK,eAAe,CAAC;EAC5D,MAAMC,aAAa,GAAGC,sBAAsB,EAAE;EAE9C,OAAO;IACLC,IAAI,EAAEV,iBAAiB;IACvB,MAAMW,WAAWA,CAACC,OAAwB,EAAEC,IAAiB;;MAC3D,IAAI,CAACL,aAAa,IAAI,EAAC,CAAAM,EAAA,GAAAF,OAAO,CAACG,cAAc,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,cAAc,GAAE;QAC7D,OAAOH,IAAI,CAACD,OAAO,CAAC;;MAGtB,MAAM;QAAEK,IAAI;QAAED;MAAc,CAAE,GAAG,CAAAE,EAAA,GAAAC,aAAa,CAACX,aAAa,EAAEI,OAAO,EAAEN,SAAS,CAAC,cAAAY,EAAA,cAAAA,EAAA,GAAI,EAAE;MAEvF,IAAI,CAACD,IAAI,IAAI,CAACD,cAAc,EAAE;QAC5B,OAAOH,IAAI,CAACD,OAAO,CAAC;;MAGtB,IAAI;QACF,MAAMQ,QAAQ,GAAG,MAAMZ,aAAa,CAACa,WAAW,CAACL,cAAc,EAAEH,IAAI,EAAED,OAAO,CAAC;QAC/EU,kBAAkB,CAACL,IAAI,EAAEG,QAAQ,CAAC;QAClC,OAAOA,QAAQ;OAChB,CAAC,OAAOG,GAAQ,EAAE;QACjBC,eAAe,CAACP,IAAI,EAAEM,GAAG,CAAC;QAC1B,MAAMA,GAAG;;IAEb;GACD;AACH;AAEA,SAASd,sBAAsBA,CAAA;EAC7B,IAAI;IACF,OAAOhB,mBAAmB,CAAC;MACzBgC,SAAS,EAAE,EAAE;MACbC,WAAW,EAAE,2BAA2B;MACxCC,cAAc,EAAEjC;KACjB,CAAC;GACH,CAAC,OAAOkC,CAAU,EAAE;IACnBhC,MAAM,CAACiC,OAAO,CAAC,0CAA0ChC,eAAe,CAAC+B,CAAC,CAAC,EAAE,CAAC;IAC9E,OAAOvB,SAAS;;AAEpB;AAEA,SAASc,aAAaA,CACpBX,aAA4B,EAC5BI,OAAwB,EACxBN,SAAkB;EAElB,IAAI;IACF;IACA,MAAM;MAAEW,IAAI;MAAEa;IAAc,CAAE,GAAGtB,aAAa,CAACuB,SAAS,CACtD,QAAQnB,OAAO,CAACoB,MAAM,EAAE,EACxB;MAAEjB,cAAc,EAAEH,OAAO,CAACG;IAAc,CAAE,EAC1C;MACEkB,QAAQ,EAAE,QAAQ;MAClBC,cAAc,EAAE;QACd,aAAa,EAAEtB,OAAO,CAACoB,MAAM;QAC7B,UAAU,EAAEpB,OAAO,CAACuB,GAAG;QACvBC,SAAS,EAAExB,OAAO,CAACwB;;KAEtB,CACF;IAED;IACA,IAAI,CAACnB,IAAI,CAACoB,WAAW,EAAE,EAAE;MACvBpB,IAAI,CAACqB,GAAG,EAAE;MACV,OAAOjC,SAAS;;IAGlB,IAAIC,SAAS,EAAE;MACbW,IAAI,CAACsB,YAAY,CAAC,iBAAiB,EAAEjC,SAAS,CAAC;;IAGjD;IACA,MAAMkC,OAAO,GAAGhC,aAAa,CAACiC,oBAAoB,CAChDX,cAAc,CAACf,cAAc,CAACC,cAAc,CAC7C;IACD,KAAK,MAAM,CAAC0B,GAAG,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACL,OAAO,CAAC,EAAE;MAClD5B,OAAO,CAAC4B,OAAO,CAACM,GAAG,CAACJ,GAAG,EAAEC,KAAK,CAAC;;IAEjC,OAAO;MAAE1B,IAAI;MAAED,cAAc,EAAEc,cAAc,CAACf,cAAc,CAACC;IAAc,CAAE;GAC9E,CAAC,OAAOY,CAAM,EAAE;IACfhC,MAAM,CAACiC,OAAO,CAAC,qDAAqDhC,eAAe,CAAC+B,CAAC,CAAC,EAAE,CAAC;IACzF,OAAOvB,SAAS;;AAEpB;AAEA,SAASmB,eAAeA,CAACP,IAAiB,EAAE8B,KAAc;EACxD,IAAI;IACF9B,IAAI,CAAC+B,SAAS,CAAC;MACbC,MAAM,EAAE,OAAO;MACfF,KAAK,EAAEjD,OAAO,CAACiD,KAAK,CAAC,GAAGA,KAAK,GAAG1C;KACjC,CAAC;IACF,IAAIN,WAAW,CAACgD,KAAK,CAAC,IAAIA,KAAK,CAACG,UAAU,EAAE;MAC1CjC,IAAI,CAACsB,YAAY,CAAC,kBAAkB,EAAEQ,KAAK,CAACG,UAAU,CAAC;;IAEzDjC,IAAI,CAACqB,GAAG,EAAE;GACX,CAAC,OAAOV,CAAM,EAAE;IACfhC,MAAM,CAACiC,OAAO,CAAC,qDAAqDhC,eAAe,CAAC+B,CAAC,CAAC,EAAE,CAAC;;AAE7F;AAEA,SAASN,kBAAkBA,CAACL,IAAiB,EAAEG,QAA0B;EACvE,IAAI;IACFH,IAAI,CAACsB,YAAY,CAAC,kBAAkB,EAAEnB,QAAQ,CAAC6B,MAAM,CAAC;IACtD,MAAME,gBAAgB,GAAG/B,QAAQ,CAACoB,OAAO,CAACY,GAAG,CAAC,iBAAiB,CAAC;IAChE,IAAID,gBAAgB,EAAE;MACpBlC,IAAI,CAACsB,YAAY,CAAC,kBAAkB,EAAEY,gBAAgB,CAAC;;IAEzDlC,IAAI,CAAC+B,SAAS,CAAC;MACbC,MAAM,EAAE;KACT,CAAC;IACFhC,IAAI,CAACqB,GAAG,EAAE;GACX,CAAC,OAAOV,CAAM,EAAE;IACfhC,MAAM,CAACiC,OAAO,CAAC,qDAAqDhC,eAAe,CAAC+B,CAAC,CAAC,EAAE,CAAC;;AAE7F"},"metadata":{},"sourceType":"module","externalDependencies":[]}