{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n  DefaultScope: \"/.default\",\n  /**\n   * Defines constants for use with HTTP headers.\n   */\n  HeaderConstants: {\n    /**\n     * The Authorization header.\n     */\n    AUTHORIZATION: \"authorization\"\n  }\n};\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport const authorizeRequestOnTenantChallenge = async challengeOptions => {\n  const requestOptions = requestToOptions(challengeOptions.request);\n  const challenge = getChallenge(challengeOptions.response);\n  if (challenge) {\n    const challengeInfo = parseChallenge(challenge);\n    const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n    const tenantId = extractTenantId(challengeInfo);\n    const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), {\n      tenantId\n    }));\n    if (!accessToken) {\n      return false;\n    }\n    challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);\n    return true;\n  }\n  return false;\n};\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo) {\n  const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n  const pathSegments = parsedAuthUri.pathname.split(\"/\");\n  const tenantId = pathSegments[1];\n  return tenantId;\n}\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(challengeOptions, challengeInfo) {\n  if (!challengeInfo.resource_uri) {\n    return challengeOptions.scopes;\n  }\n  const challengeScopes = new URL(challengeInfo.resource_uri);\n  challengeScopes.pathname = Constants.DefaultScope;\n  return [challengeScopes.toString()];\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge) {\n  const bearerChallenge = challenge.slice(\"Bearer \".length);\n  const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter(x => x);\n  const keyValuePairs = challengeParts.map(keyValue => (_ref => {\n    let [key, value] = _ref;\n    return {\n      [key]: value\n    };\n  })(keyValue.trim().split(\"=\")));\n  // Key-value pairs to plain object:\n  return keyValuePairs.reduce((a, b) => Object.assign(Object.assign({}, a), b), {});\n}\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request) {\n  return {\n    abortSignal: request.abortSignal,\n    requestOptions: {\n      timeout: request.timeout\n    },\n    tracingOptions: request.tracingOptions\n  };\n}","map":{"version":3,"names":["Constants","DefaultScope","HeaderConstants","AUTHORIZATION","authorizeRequestOnTenantChallenge","challengeOptions","requestOptions","requestToOptions","request","challenge","getChallenge","response","challengeInfo","parseChallenge","challengeScopes","buildScopes","tenantId","extractTenantId","accessToken","getAccessToken","Object","assign","headers","set","token","parsedAuthUri","URL","authorization_uri","pathSegments","pathname","split","resource_uri","scopes","toString","get","status","bearerChallenge","slice","length","challengeParts","trim","filter","x","keyValuePairs","map","keyValue","_ref","key","value","reduce","a","b","abortSignal","timeout","tracingOptions"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/@azure/core-client/src/authorizeRequestOnTenantChallenge.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AuthorizeRequestOnChallengeOptions,\n  PipelineRequest,\n  PipelineResponse,\n} from \"@azure/core-rest-pipeline\";\n\nimport { GetTokenOptions } from \"@azure/core-auth\";\n\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n  DefaultScope: \"/.default\",\n  /**\n   * Defines constants for use with HTTP headers.\n   */\n  HeaderConstants: {\n    /**\n     * The Authorization header.\n     */\n    AUTHORIZATION: \"authorization\",\n  },\n};\n\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport const authorizeRequestOnTenantChallenge: (\n  challengeOptions: AuthorizeRequestOnChallengeOptions\n) => Promise<boolean> = async (challengeOptions) => {\n  const requestOptions = requestToOptions(challengeOptions.request);\n  const challenge = getChallenge(challengeOptions.response);\n  if (challenge) {\n    const challengeInfo: Challenge = parseChallenge(challenge);\n    const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n    const tenantId = extractTenantId(challengeInfo);\n    const accessToken = await challengeOptions.getAccessToken(challengeScopes, {\n      ...requestOptions,\n      tenantId,\n    });\n\n    if (!accessToken) {\n      return false;\n    }\n\n    challengeOptions.request.headers.set(\n      Constants.HeaderConstants.AUTHORIZATION,\n      `Bearer ${accessToken.token}`\n    );\n    return true;\n  }\n  return false;\n};\n\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo: Challenge): string {\n  const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n  const pathSegments = parsedAuthUri.pathname.split(\"/\");\n  const tenantId = pathSegments[1];\n\n  return tenantId;\n}\n\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(\n  challengeOptions: AuthorizeRequestOnChallengeOptions,\n  challengeInfo: Challenge\n): string[] {\n  if (!challengeInfo.resource_uri) {\n    return challengeOptions.scopes;\n  }\n\n  const challengeScopes = new URL(challengeInfo.resource_uri);\n  challengeScopes.pathname = Constants.DefaultScope;\n  return [challengeScopes.toString()];\n}\n\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response: PipelineResponse): string | undefined {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n\n/**\n * Challenge structure\n */\ninterface Challenge {\n  authorization_uri: string;\n  resource_uri?: string;\n}\n\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge: string): Challenge {\n  const bearerChallenge = challenge.slice(\"Bearer \".length);\n  const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter((x) => x);\n  const keyValuePairs = challengeParts.map((keyValue) =>\n    (([key, value]) => ({ [key]: value }))(keyValue.trim().split(\"=\"))\n  );\n  // Key-value pairs to plain object:\n  return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {} as Challenge);\n}\n\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request: PipelineRequest): GetTokenOptions {\n  return {\n    abortSignal: request.abortSignal,\n    requestOptions: {\n      timeout: request.timeout,\n    },\n    tracingOptions: request.tracingOptions,\n  };\n}\n"],"mappings":"AAAA;AACA;AAUA;;;AAGA,MAAMA,SAAS,GAAG;EAChBC,YAAY,EAAE,WAAW;EACzB;;;EAGAC,eAAe,EAAE;IACf;;;IAGAC,aAAa,EAAE;;CAElB;AAED;;;;;AAKA,OAAO,MAAMC,iCAAiC,GAEtB,MAAOC,gBAAgB,IAAI;EACjD,MAAMC,cAAc,GAAGC,gBAAgB,CAACF,gBAAgB,CAACG,OAAO,CAAC;EACjE,MAAMC,SAAS,GAAGC,YAAY,CAACL,gBAAgB,CAACM,QAAQ,CAAC;EACzD,IAAIF,SAAS,EAAE;IACb,MAAMG,aAAa,GAAcC,cAAc,CAACJ,SAAS,CAAC;IAC1D,MAAMK,eAAe,GAAGC,WAAW,CAACV,gBAAgB,EAAEO,aAAa,CAAC;IACpE,MAAMI,QAAQ,GAAGC,eAAe,CAACL,aAAa,CAAC;IAC/C,MAAMM,WAAW,GAAG,MAAMb,gBAAgB,CAACc,cAAc,CAACL,eAAe,EAAAM,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACpEf,cAAc;MACjBU;IAAQ,GACR;IAEF,IAAI,CAACE,WAAW,EAAE;MAChB,OAAO,KAAK;;IAGdb,gBAAgB,CAACG,OAAO,CAACc,OAAO,CAACC,GAAG,CAClCvB,SAAS,CAACE,eAAe,CAACC,aAAa,EACvC,UAAUe,WAAW,CAACM,KAAK,EAAE,CAC9B;IACD,OAAO,IAAI;;EAEb,OAAO,KAAK;AACd,CAAC;AAED;;;;;AAKA,SAASP,eAAeA,CAACL,aAAwB;EAC/C,MAAMa,aAAa,GAAG,IAAIC,GAAG,CAACd,aAAa,CAACe,iBAAiB,CAAC;EAC9D,MAAMC,YAAY,GAAGH,aAAa,CAACI,QAAQ,CAACC,KAAK,CAAC,GAAG,CAAC;EACtD,MAAMd,QAAQ,GAAGY,YAAY,CAAC,CAAC,CAAC;EAEhC,OAAOZ,QAAQ;AACjB;AAEA;;;;;AAKA,SAASD,WAAWA,CAClBV,gBAAoD,EACpDO,aAAwB;EAExB,IAAI,CAACA,aAAa,CAACmB,YAAY,EAAE;IAC/B,OAAO1B,gBAAgB,CAAC2B,MAAM;;EAGhC,MAAMlB,eAAe,GAAG,IAAIY,GAAG,CAACd,aAAa,CAACmB,YAAY,CAAC;EAC3DjB,eAAe,CAACe,QAAQ,GAAG7B,SAAS,CAACC,YAAY;EACjD,OAAO,CAACa,eAAe,CAACmB,QAAQ,EAAE,CAAC;AACrC;AAEA;;;;AAIA,SAASvB,YAAYA,CAACC,QAA0B;EAC9C,MAAMF,SAAS,GAAGE,QAAQ,CAACW,OAAO,CAACY,GAAG,CAAC,kBAAkB,CAAC;EAC1D,IAAIvB,QAAQ,CAACwB,MAAM,KAAK,GAAG,IAAI1B,SAAS,EAAE;IACxC,OAAOA,SAAS;;EAElB;AACF;AAUA;;;;;;AAMA,SAASI,cAAcA,CAACJ,SAAiB;EACvC,MAAM2B,eAAe,GAAG3B,SAAS,CAAC4B,KAAK,CAAC,SAAS,CAACC,MAAM,CAAC;EACzD,MAAMC,cAAc,GAAG,GAAGH,eAAe,CAACI,IAAI,EAAE,GAAG,CAACV,KAAK,CAAC,GAAG,CAAC,CAACW,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAAC;EAC/E,MAAMC,aAAa,GAAGJ,cAAc,CAACK,GAAG,CAAEC,QAAQ,IAChD,CAACC,IAAA;IAAA,IAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,GAAAF,IAAA;IAAA,OAAM;MAAE,CAACC,GAAG,GAAGC;IAAK,CAAE;EAAA,CAAC,EAAEH,QAAQ,CAACL,IAAI,EAAE,CAACV,KAAK,CAAC,GAAG,CAAC,CAAC,CACnE;EACD;EACA,OAAOa,aAAa,CAACM,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK/B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAM6B,CAAC,GAAKC,CAAC,CAAG,EAAE,EAAe,CAAC;AAC1E;AAEA;;;AAGA,SAAS5C,gBAAgBA,CAACC,OAAwB;EAChD,OAAO;IACL4C,WAAW,EAAE5C,OAAO,CAAC4C,WAAW;IAChC9C,cAAc,EAAE;MACd+C,OAAO,EAAE7C,OAAO,CAAC6C;KAClB;IACDC,cAAc,EAAE9C,OAAO,CAAC8C;GACzB;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}