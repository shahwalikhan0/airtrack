{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/shahwalikhan/Desktop/my-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/shahwalikhan/Desktop/my-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/shahwalikhan/Desktop/my-app/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/shahwalikhan/Desktop/my-app/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/shahwalikhan/Desktop/my-app/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/shahwalikhan/Desktop/my-app/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/shahwalikhan/Desktop/my-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar tds = require('tedious');\nvar debug = require('debug')('mssql:tedi');\nvar BaseRequest = require('../base/request');\nvar RequestError = require('../error/request-error');\nvar _require = require('../utils'),\n  IDS = _require.IDS,\n  objectHasProperty = _require.objectHasProperty;\nvar _require2 = require('../datatypes'),\n  TYPES = _require2.TYPES,\n  DECLARATIONS = _require2.DECLARATIONS,\n  declare = _require2.declare,\n  cast = _require2.cast;\nvar Table = require('../table');\nvar _require3 = require('../udt'),\n  UDT = _require3.PARSERS;\nvar _require4 = require('../shared'),\n  valueHandler = _require4.valueHandler;\nvar JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';\nvar XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B';\nvar N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n};\nvar getTediousType = function getTediousType(type) {\n  switch (type) {\n    case TYPES.VarChar:\n      return tds.TYPES.VarChar;\n    case TYPES.NVarChar:\n      return tds.TYPES.NVarChar;\n    case TYPES.Text:\n      return tds.TYPES.Text;\n    case TYPES.Int:\n      return tds.TYPES.Int;\n    case TYPES.BigInt:\n      return tds.TYPES.BigInt;\n    case TYPES.TinyInt:\n      return tds.TYPES.TinyInt;\n    case TYPES.SmallInt:\n      return tds.TYPES.SmallInt;\n    case TYPES.Bit:\n      return tds.TYPES.Bit;\n    case TYPES.Float:\n      return tds.TYPES.Float;\n    case TYPES.Decimal:\n      return tds.TYPES.Decimal;\n    case TYPES.Numeric:\n      return tds.TYPES.Numeric;\n    case TYPES.Real:\n      return tds.TYPES.Real;\n    case TYPES.Money:\n      return tds.TYPES.Money;\n    case TYPES.SmallMoney:\n      return tds.TYPES.SmallMoney;\n    case TYPES.Time:\n      return tds.TYPES.Time;\n    case TYPES.Date:\n      return tds.TYPES.Date;\n    case TYPES.DateTime:\n      return tds.TYPES.DateTime;\n    case TYPES.DateTime2:\n      return tds.TYPES.DateTime2;\n    case TYPES.DateTimeOffset:\n      return tds.TYPES.DateTimeOffset;\n    case TYPES.SmallDateTime:\n      return tds.TYPES.SmallDateTime;\n    case TYPES.UniqueIdentifier:\n      return tds.TYPES.UniqueIdentifier;\n    case TYPES.Xml:\n      return tds.TYPES.NVarChar;\n    case TYPES.Char:\n      return tds.TYPES.Char;\n    case TYPES.NChar:\n      return tds.TYPES.NChar;\n    case TYPES.NText:\n      return tds.TYPES.NVarChar;\n    case TYPES.Image:\n      return tds.TYPES.Image;\n    case TYPES.Binary:\n      return tds.TYPES.Binary;\n    case TYPES.VarBinary:\n      return tds.TYPES.VarBinary;\n    case TYPES.UDT:\n    case TYPES.Geography:\n    case TYPES.Geometry:\n      return tds.TYPES.UDT;\n    case TYPES.TVP:\n      return tds.TYPES.TVP;\n    case TYPES.Variant:\n      return tds.TYPES.Variant;\n    default:\n      return type;\n  }\n};\nvar getMssqlType = function getMssqlType(type, length) {\n  if (typeof type !== 'object') return undefined;\n  switch (type) {\n    case tds.TYPES.Char:\n      return TYPES.Char;\n    case tds.TYPES.NChar:\n      return TYPES.NChar;\n    case tds.TYPES.VarChar:\n      return TYPES.VarChar;\n    case tds.TYPES.NVarChar:\n      return TYPES.NVarChar;\n    case tds.TYPES.Text:\n      return TYPES.Text;\n    case tds.TYPES.NText:\n      return TYPES.NText;\n    case tds.TYPES.Int:\n      return TYPES.Int;\n    case tds.TYPES.BigInt:\n      return TYPES.BigInt;\n    case tds.TYPES.TinyInt:\n      return TYPES.TinyInt;\n    case tds.TYPES.SmallInt:\n      return TYPES.SmallInt;\n    case tds.TYPES.Bit:\n      return TYPES.Bit;\n    case tds.TYPES.Float:\n      return TYPES.Float;\n    case tds.TYPES.Real:\n      return TYPES.Real;\n    case tds.TYPES.Money:\n      return TYPES.Money;\n    case tds.TYPES.SmallMoney:\n      return TYPES.SmallMoney;\n    case tds.TYPES.Numeric:\n      return TYPES.Numeric;\n    case tds.TYPES.Decimal:\n      return TYPES.Decimal;\n    case tds.TYPES.DateTime:\n      return TYPES.DateTime;\n    case tds.TYPES.Time:\n      return TYPES.Time;\n    case tds.TYPES.Date:\n      return TYPES.Date;\n    case tds.TYPES.DateTime2:\n      return TYPES.DateTime2;\n    case tds.TYPES.DateTimeOffset:\n      return TYPES.DateTimeOffset;\n    case tds.TYPES.SmallDateTime:\n      return TYPES.SmallDateTime;\n    case tds.TYPES.UniqueIdentifier:\n      return TYPES.UniqueIdentifier;\n    case tds.TYPES.Image:\n      return TYPES.Image;\n    case tds.TYPES.Binary:\n      return TYPES.Binary;\n    case tds.TYPES.VarBinary:\n      return TYPES.VarBinary;\n    case tds.TYPES.Xml:\n      return TYPES.Xml;\n    case tds.TYPES.UDT:\n      return TYPES.UDT;\n    case tds.TYPES.TVP:\n      return TYPES.TVP;\n    case tds.TYPES.Variant:\n      return TYPES.Variant;\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN:\n          return TYPES.Bit;\n        case N_TYPES.NumericN:\n          return TYPES.Numeric;\n        case N_TYPES.DecimalN:\n          return TYPES.Decimal;\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt;\n          if (length === 4) return TYPES.Int;\n          if (length === 2) return TYPES.SmallInt;\n          return TYPES.TinyInt;\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float;\n          return TYPES.Real;\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money;\n          return TYPES.SmallMoney;\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime;\n          return TYPES.SmallDateTime;\n      }\n  }\n};\nvar createColumns = function createColumns(metadata, arrayRowMode) {\n  var out = {};\n  if (arrayRowMode) out = [];\n  for (var index = 0, length = metadata.length; index < length; index++) {\n    var column = metadata[index];\n    var outColumn = {\n      index: index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    };\n    if (column.udtInfo) {\n      outColumn.udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      };\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName];\n      }\n    }\n    if (arrayRowMode) {\n      out.push(outColumn);\n    } else {\n      out[column.colName] = outColumn;\n    }\n  }\n  return out;\n};\nvar valueCorrection = function valueCorrection(value, metadata) {\n  var type = getMssqlType(metadata.type);\n  if (valueHandler.has(type)) {\n    return valueHandler.get(type)(value);\n  } else if (metadata.type === tds.TYPES.UDT && value != null) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value);\n    } else {\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\nvar parameterCorrection = function parameterCorrection(value) {\n  if (value instanceof Table) {\n    var tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    };\n    var _iterator = _createForOfIteratorHelper(value.columns),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var col = _step.value;\n        tvp.columns.push({\n          name: col.name,\n          type: getTediousType(col.type),\n          length: col.length,\n          scale: col.scale,\n          precision: col.precision\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return tvp;\n  } else {\n    return value;\n  }\n};\nvar Request = /*#__PURE__*/function (_BaseRequest) {\n  _inherits(Request, _BaseRequest);\n  var _super = _createSuper(Request);\n  function Request() {\n    _classCallCheck(this, Request);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Request, [{\n    key: \"_batch\",\n    value:\n    /*\n    Execute specified sql batch.\n    */\n\n    function _batch(batch, callback) {\n      this._isBatch = true;\n      this._query(batch, callback);\n    }\n\n    /*\n    Bulk load.\n    */\n  }, {\n    key: \"_bulk\",\n    value: function _bulk(table, options, callback) {\n      var _this = this;\n      _get(_getPrototypeOf(Request.prototype), \"_bulk\", this).call(this, table, options, function (err) {\n        if (err) return callback(err);\n        try {\n          table._makeBulk();\n        } catch (e) {\n          return callback(new RequestError(e, 'EREQUEST'));\n        }\n        if (!table.name) {\n          return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'));\n        }\n        if (table.name.charAt(0) === '@') {\n          return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'));\n        }\n        var errors = [];\n        var errorHandlers = {};\n        var hasReturned = false;\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new RequestError(err, 'EREQUEST');\n          if (_this.stream) {\n            _this.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n                _this.parent.release(connection);\n              }\n              hasReturned = true;\n              callback(err);\n            }\n          }\n\n          // we must collect errors even in stream mode\n          errors.push(err);\n        };\n        var handleInfo = function handleInfo(msg) {\n          _this.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n        _this.parent.acquire(_this, function (err, connection) {\n          var callbackWithRelease = function callbackWithRelease(err) {\n            try {\n              _this.parent.release(connection);\n            } catch (e) {\n              // noop\n            }\n            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n            callback.apply(void 0, [err].concat(args));\n          };\n          if (err) return callbackWithRelease(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this));\n          if (_this.canceled) {\n            debug('request(%d): canceled', IDS.get(_this));\n            return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'));\n          }\n          _this._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this));\n            connection.cancel();\n          };\n\n          // attach handler to handle multiple error messages\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n          var done = function done(err, rowCount) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new RequestError(err, 'EREQUEST');\n              if (_this.stream) _this.emit('error', err);\n              errors.push(err);\n            }\n            delete _this._cancel;\n            var error;\n            if (errors.length && !_this.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n              hasReturned = true;\n              if (_this.stream) {\n                callbackWithRelease(null, rowCount);\n              } else {\n                callbackWithRelease(error, rowCount);\n              }\n            }\n          };\n          var bulk = connection.newBulkLoad(table.path, options, done);\n          var _iterator2 = _createForOfIteratorHelper(table.columns),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var col = _step2.value;\n              bulk.addColumn(col.name, getTediousType(col.type), {\n                nullable: col.nullable,\n                length: col.length,\n                scale: col.scale,\n                precision: col.precision\n              });\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          if (table.create) {\n            var objectid = table.temporary ? \"tempdb..[\".concat(table.name, \"]\") : table.path;\n            var req = new tds.Request(\"if object_id('\".concat(objectid.replace(/'/g, '\\'\\''), \"') is null \").concat(table.declare()), function (err) {\n              if (err) return done(err);\n              connection.execBulkLoad(bulk, table.rows);\n            });\n            _this._setCurrentRequest(req);\n            connection.execSqlBatch(req);\n          } else {\n            connection.execBulkLoad(bulk, table.rows);\n          }\n        });\n      });\n    }\n\n    /*\n    Execute specified sql command.\n    */\n  }, {\n    key: \"_query\",\n    value: function _query(command, callback) {\n      var _this2 = this;\n      _get(_getPrototypeOf(Request.prototype), \"_query\", this).call(this, command, function (err) {\n        if (err) return callback(err);\n        var recordsets = [];\n        var recordsetcolumns = [];\n        var errors = [];\n        var errorHandlers = {};\n        var output = {};\n        var rowsAffected = [];\n        var columns = {};\n        var recordset = [];\n        var batchLastRow = null;\n        var batchHasOutput = false;\n        var isChunkedRecordset = false;\n        var chunksBuffer = null;\n        var hasReturned = false;\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new RequestError(err, 'EREQUEST');\n          if (_this2.stream) {\n            _this2.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n                _this2.parent.release(connection);\n              }\n              hasReturned = true;\n              callback(err);\n            }\n          }\n\n          // we must collect errors even in stream mode\n          errors.push(err);\n        };\n        var handleInfo = function handleInfo(msg) {\n          _this2.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n        _this2.parent.acquire(_this2, function (err, connection, config) {\n          if (err) return callback(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this2));\n          var row;\n          if (_this2.canceled) {\n            debug('request(%d): canceled', IDS.get(_this2));\n            _this2.parent.release(connection);\n            return callback(new RequestError('Canceled.', 'ECANCEL'));\n          }\n          _this2._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this2));\n            connection.cancel();\n          };\n\n          // attach handler to handle multiple error messages\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n          debug('request(%d): query', IDS.get(_this2), command);\n          var req = new tds.Request(command, function (err) {\n            // tedious v15 has started using AggregateErrors to wrap multiple errors into single error objects\n            (err !== null && err !== void 0 && err.errors ? err.errors : [err]).forEach(function (e, i, _ref) {\n              var length = _ref.length;\n              // to make sure we handle no-sql errors as well\n              if (e && (!errors.length || errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message)) {\n                e = new RequestError(e, 'EREQUEST');\n                if (_this2.stream) _this2.emit('error', e);\n                errors.push(e);\n              }\n            });\n\n            // process batch outputs\n            if (batchHasOutput) {\n              if (!_this2.stream) batchLastRow = recordsets.pop()[0];\n              for (var name in batchLastRow) {\n                var value = batchLastRow[name];\n                if (name !== '___return___') {\n                  output[name] = value;\n                }\n              }\n            }\n            delete _this2._cancel;\n            var error;\n            if (errors.length && !_this2.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n              _this2.parent.release(connection);\n              hasReturned = true;\n              if (error) {\n                debug('request(%d): failed', IDS.get(_this2), error);\n              } else {\n                debug('request(%d): completed', IDS.get(_this2));\n              }\n              if (_this2.stream) {\n                callback(null, null, output, rowsAffected, recordsetcolumns);\n              } else {\n                callback(error, recordsets, output, rowsAffected, recordsetcolumns);\n              }\n            }\n          });\n          _this2._setCurrentRequest(req);\n          req.on('columnMetadata', function (metadata) {\n            columns = createColumns(metadata, _this2.arrayRowMode);\n            isChunkedRecordset = false;\n            if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n              isChunkedRecordset = true;\n              chunksBuffer = [];\n            }\n            if (_this2.stream) {\n              if (_this2._isBatch) {\n                // don't stream recordset with output values in batches\n                if (!columns.___return___) {\n                  _this2.emit('recordset', columns);\n                }\n              } else {\n                _this2.emit('recordset', columns);\n              }\n            }\n            if (_this2.arrayRowMode) recordsetcolumns.push(columns);\n          });\n          var doneHandler = function doneHandler(rowCount, more) {\n            if (rowCount != null) {\n              rowsAffected.push(rowCount);\n              if (_this2.stream) {\n                _this2.emit('rowsaffected', rowCount);\n              }\n            }\n            // this function is called even when select only set variables so we should skip adding a new recordset\n            if (Object.keys(columns).length === 0) return;\n            if (isChunkedRecordset) {\n              var concatenatedChunks = chunksBuffer.join('');\n              if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n                try {\n                  if (concatenatedChunks === '') {\n                    row = null;\n                  } else {\n                    row = JSON.parse(concatenatedChunks);\n                  }\n                } catch (ex) {\n                  row = null;\n                  var ex2 = new RequestError(new Error(\"Failed to parse incoming JSON. \".concat(ex.message)), 'EJSON');\n                  if (_this2.stream) _this2.emit('error', ex2);\n\n                  // we must collect errors even in stream mode\n                  errors.push(ex2);\n                }\n              } else {\n                row = {};\n                row[Object.keys(columns)[0]] = concatenatedChunks;\n              }\n              chunksBuffer = null;\n              if (_this2.stream) {\n                _this2.emit('row', row);\n              } else {\n                recordset.push(row);\n              }\n            }\n            if (!_this2.stream) {\n              // all rows of current recordset loaded\n              Object.defineProperty(recordset, 'columns', {\n                enumerable: false,\n                configurable: true,\n                value: columns\n              });\n              Object.defineProperty(recordset, 'toTable', {\n                enumerable: false,\n                configurable: true,\n                value: function value(name) {\n                  return Table.fromRecordset(this, name);\n                }\n              });\n              recordsets.push(recordset);\n            }\n            recordset = [];\n            columns = {};\n          };\n          req.on('doneInProc', doneHandler); // doneInProc handlers are used in both queries and batches\n          req.on('done', doneHandler); // done handlers are used in batches\n\n          req.on('returnValue', function (parameterName, value, metadata) {\n            output[parameterName] = value;\n          });\n          req.on('row', function (columns) {\n            if (!recordset) recordset = [];\n            if (isChunkedRecordset) {\n              return chunksBuffer.push(columns[0].value);\n            }\n            if (_this2.arrayRowMode) {\n              row = [];\n            } else {\n              row = {};\n            }\n            var _iterator3 = _createForOfIteratorHelper(columns),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var col = _step3.value;\n                col.value = valueCorrection(col.value, col.metadata);\n                if (_this2.arrayRowMode) {\n                  row.push(col.value);\n                } else {\n                  var exi = row[col.metadata.colName];\n                  if (exi !== undefined) {\n                    if (exi instanceof Array) {\n                      exi.push(col.value);\n                    } else {\n                      row[col.metadata.colName] = [exi, col.value];\n                    }\n                  } else {\n                    row[col.metadata.colName] = col.value;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            if (_this2.stream) {\n              if (_this2._isBatch) {\n                // dont stream recordset with output values in batches\n                if (row.___return___) {\n                  batchLastRow = row;\n                } else {\n                  _this2.emit('row', row);\n                }\n              } else {\n                _this2.emit('row', row);\n              }\n            } else {\n              recordset.push(row);\n            }\n          });\n          if (_this2._isBatch) {\n            if (Object.keys(_this2.parameters).length) {\n              for (var name in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, name)) {\n                  continue;\n                }\n                var param = _this2.parameters[name];\n                try {\n                  param.value = getTediousType(param.type).validate(param.value, _this2.parent.collation);\n                } catch (e) {\n                  e.message = \"Validation failed for parameter '\".concat(name, \"'. \").concat(e.message);\n                  var _err = new RequestError(e, 'EPARAM');\n                  _this2.parent.release(connection);\n                  return callback(_err);\n                }\n              }\n              var declarations = [];\n              for (var _name in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, _name)) {\n                  continue;\n                }\n                var _param = _this2.parameters[_name];\n                declarations.push(\"@\".concat(_name, \" \").concat(declare(_param.type, _param)));\n              }\n              var assigns = [];\n              for (var _name2 in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, _name2)) {\n                  continue;\n                }\n                var _param2 = _this2.parameters[_name2];\n                assigns.push(\"@\".concat(_name2, \" = \").concat(cast(_param2.value, _param2.type, _param2)));\n              }\n              var selects = [];\n              for (var _name3 in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, _name3)) {\n                  continue;\n                }\n                var _param3 = _this2.parameters[_name3];\n                if (_param3.io === 2) {\n                  selects.push(\"@\".concat(_name3, \" as [\").concat(_name3, \"]\"));\n                }\n              }\n              batchHasOutput = selects.length > 0;\n              req.sqlTextOrProcedure = \"declare \".concat(declarations.join(', '), \";select \").concat(assigns.join(', '), \";\").concat(req.sqlTextOrProcedure, \";\").concat(batchHasOutput ? \"select 1 as [___return___], \".concat(selects.join(', ')) : '');\n            }\n          } else {\n            for (var _name4 in _this2.parameters) {\n              if (!objectHasProperty(_this2.parameters, _name4)) {\n                continue;\n              }\n              var _param4 = _this2.parameters[_name4];\n              if (_param4.io === 1) {\n                req.addParameter(_param4.name, getTediousType(_param4.type), parameterCorrection(_param4.value), {\n                  length: _param4.length,\n                  scale: _param4.scale,\n                  precision: _param4.precision\n                });\n              } else {\n                req.addOutputParameter(_param4.name, getTediousType(_param4.type), parameterCorrection(_param4.value), {\n                  length: _param4.length,\n                  scale: _param4.scale,\n                  precision: _param4.precision\n                });\n              }\n            }\n          }\n          try {\n            connection[_this2._isBatch ? 'execSqlBatch' : 'execSql'](req);\n          } catch (error) {\n            handleError(true, connection, error);\n          }\n        });\n      });\n    }\n\n    /*\n    Execute stored procedure with specified parameters.\n    */\n  }, {\n    key: \"_execute\",\n    value: function _execute(procedure, callback) {\n      var _this3 = this;\n      _get(_getPrototypeOf(Request.prototype), \"_execute\", this).call(this, procedure, function (err) {\n        if (err) return callback(err);\n        var recordsets = [];\n        var recordsetcolumns = [];\n        var errors = [];\n        var errorHandlers = {};\n        var output = {};\n        var rowsAffected = [];\n        var columns = {};\n        var recordset = [];\n        var returnValue = 0;\n        var isChunkedRecordset = false;\n        var chunksBuffer = null;\n        var hasReturned = false;\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new RequestError(err, 'EREQUEST');\n          if (_this3.stream) {\n            _this3.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n                _this3.parent.release(connection);\n              }\n              hasReturned = true;\n              callback(err);\n            }\n          }\n\n          // we must collect errors even in stream mode\n          errors.push(err);\n        };\n        var handleInfo = function handleInfo(msg) {\n          _this3.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n        _this3.parent.acquire(_this3, function (err, connection, config) {\n          if (err) return callback(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this3));\n          var row;\n          if (_this3.canceled) {\n            debug('request(%d): canceled', IDS.get(_this3));\n            _this3.parent.release(connection);\n            return callback(new RequestError('Canceled.', 'ECANCEL'));\n          }\n          _this3._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this3));\n            connection.cancel();\n          };\n\n          // attach handler to handle multiple error messages\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n          if (debug.enabled) {\n            // log stored procedure executions and provided parameters\n            var params = Object.keys(_this3.parameters).map(function (k) {\n              return _this3.parameters[k];\n            });\n            // cut long string parameters short to keep log somewhat clean\n            var logValue = function logValue(s) {\n              return typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s;\n            };\n            // format parameter names as 'my_parameter [sql.Int]'\n            var logName = function logName(param) {\n              return param.name + ' [sql.' + param.type.name + ']';\n            };\n            var logParams = {};\n            params.forEach(function (p) {\n              logParams[logName(p)] = logValue(p.value);\n            });\n            debug('request(%d): execute %s %O', IDS.get(_this3), procedure, logParams);\n          }\n          var req = new tds.Request(procedure, function (err) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new RequestError(err, 'EREQUEST');\n              if (_this3.stream) _this3.emit('error', err);\n              errors.push(err);\n            }\n            delete _this3._cancel;\n            var error;\n            if (errors.length && !_this3.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n              _this3.parent.release(connection);\n              hasReturned = true;\n              if (error) {\n                debug('request(%d): failed', IDS.get(_this3), error);\n              } else {\n                debug('request(%d): complete', IDS.get(_this3));\n              }\n              if (_this3.stream) {\n                callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);\n              } else {\n                callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);\n              }\n            }\n          });\n          _this3._setCurrentRequest(req);\n          req.on('columnMetadata', function (metadata) {\n            columns = createColumns(metadata, _this3.arrayRowMode);\n            isChunkedRecordset = false;\n            if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n              isChunkedRecordset = true;\n              chunksBuffer = [];\n            }\n            if (_this3.stream) _this3.emit('recordset', columns);\n            if (_this3.arrayRowMode) recordsetcolumns.push(columns);\n          });\n          req.on('row', function (columns) {\n            if (!recordset) recordset = [];\n            if (isChunkedRecordset) {\n              return chunksBuffer.push(columns[0].value);\n            }\n            if (_this3.arrayRowMode) {\n              row = [];\n            } else {\n              row = {};\n            }\n            var _iterator4 = _createForOfIteratorHelper(columns),\n              _step4;\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var col = _step4.value;\n                col.value = valueCorrection(col.value, col.metadata);\n                if (_this3.arrayRowMode) {\n                  row.push(col.value);\n                } else {\n                  var exi = row[col.metadata.colName];\n                  if (exi != null) {\n                    if (exi instanceof Array) {\n                      exi.push(col.value);\n                    } else {\n                      row[col.metadata.colName] = [exi, col.value];\n                    }\n                  } else {\n                    row[col.metadata.colName] = col.value;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n            if (_this3.stream) {\n              _this3.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          });\n          req.on('doneInProc', function (rowCount, more) {\n            if (rowCount != null) {\n              rowsAffected.push(rowCount);\n              if (_this3.stream) {\n                _this3.emit('rowsaffected', rowCount);\n              }\n            }\n\n            // filter empty recordsets when NOCOUNT is OFF\n            if (Object.keys(columns).length === 0) return;\n            if (isChunkedRecordset) {\n              if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n                try {\n                  if (chunksBuffer.length === 0) {\n                    row = null;\n                  } else {\n                    row = JSON.parse(chunksBuffer.join(''));\n                  }\n                } catch (ex) {\n                  row = null;\n                  var ex2 = new RequestError(new Error(\"Failed to parse incoming JSON. \".concat(ex.message)), 'EJSON');\n                  if (_this3.stream) _this3.emit('error', ex2);\n\n                  // we must collect errors even in stream mode\n                  errors.push(ex2);\n                }\n              } else {\n                row = {};\n                row[Object.keys(columns)[0]] = chunksBuffer.join('');\n              }\n              chunksBuffer = null;\n              if (_this3.stream) {\n                _this3.emit('row', row);\n              } else {\n                recordset.push(row);\n              }\n            }\n            if (!_this3.stream) {\n              // all rows of current recordset loaded\n              Object.defineProperty(recordset, 'columns', {\n                enumerable: false,\n                configurable: true,\n                value: columns\n              });\n              Object.defineProperty(recordset, 'toTable', {\n                enumerable: false,\n                configurable: true,\n                value: function value(name) {\n                  return Table.fromRecordset(this, name);\n                }\n              });\n              recordsets.push(recordset);\n            }\n            recordset = [];\n            columns = {};\n          });\n          req.on('doneProc', function (rowCount, more, returnStatus) {\n            returnValue = returnStatus;\n          });\n          req.on('returnValue', function (parameterName, value, metadata) {\n            output[parameterName] = value;\n          });\n          for (var name in _this3.parameters) {\n            if (!objectHasProperty(_this3.parameters, name)) {\n              continue;\n            }\n            var param = _this3.parameters[name];\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            }\n          }\n          connection.callProcedure(req);\n        });\n      });\n    }\n  }, {\n    key: \"_pause\",\n    value: function _pause() {\n      _get(_getPrototypeOf(Request.prototype), \"_pause\", this).call(this);\n      if (this._currentRequest) {\n        this._currentRequest.pause();\n      }\n    }\n  }, {\n    key: \"_resume\",\n    value: function _resume() {\n      _get(_getPrototypeOf(Request.prototype), \"_resume\", this).call(this);\n      if (this._currentRequest) {\n        this._currentRequest.resume();\n      }\n    }\n  }]);\n  return Request;\n}(BaseRequest);\nmodule.exports = Request;","map":{"version":3,"names":["_classCallCheck","require","default","_createClass","_get","_getPrototypeOf","_inherits","_createSuper","_createForOfIteratorHelper","tds","debug","BaseRequest","RequestError","_require","IDS","objectHasProperty","_require2","TYPES","DECLARATIONS","declare","cast","Table","_require3","UDT","PARSERS","_require4","valueHandler","JSON_COLUMN_ID","XML_COLUMN_ID","N_TYPES","BitN","DateTimeN","DecimalN","FloatN","IntN","MoneyN","NumericN","getTediousType","type","VarChar","NVarChar","Text","Int","BigInt","TinyInt","SmallInt","Bit","Float","Decimal","Numeric","Real","Money","SmallMoney","Time","Date","DateTime","DateTime2","DateTimeOffset","SmallDateTime","UniqueIdentifier","Xml","Char","NChar","NText","Image","Binary","VarBinary","Geography","Geometry","TVP","Variant","getMssqlType","length","undefined","id","createColumns","metadata","arrayRowMode","out","index","column","outColumn","name","colName","dataLength","scale","precision","nullable","flags","caseSensitive","identity","readOnly","udtInfo","udt","typeName","database","dbname","schema","owningSchema","assembly","assemblyName","push","valueCorrection","value","has","get","parameterCorrection","tvp","columns","rows","_iterator","_step","s","n","done","col","err","e","f","Request","_BaseRequest","_super","apply","arguments","key","_batch","batch","callback","_isBatch","_query","_bulk","table","options","_this","prototype","call","_makeBulk","charAt","errors","errorHandlers","hasReturned","handleError","doReturn","connection","info","Error","message","stream","emit","event","removeListener","parent","release","handleInfo","msg","number","state","class","lineNumber","serverName","procName","acquire","callbackWithRelease","_len","args","Array","_key","concat","canceled","_cancel","cancel","on","infoMessage","errorMessage","bind","error","rowCount","pop","precedingErrors","bulk","newBulkLoad","path","_iterator2","_step2","addColumn","create","objectid","temporary","req","replace","execBulkLoad","_setCurrentRequest","execSqlBatch","command","_this2","recordsets","recordsetcolumns","output","rowsAffected","recordset","batchLastRow","batchHasOutput","isChunkedRecordset","chunksBuffer","config","row","forEach","i","_ref","___return___","doneHandler","more","Object","keys","concatenatedChunks","join","parseJSON","JSON","parse","ex","ex2","defineProperty","enumerable","configurable","fromRecordset","parameterName","_iterator3","_step3","exi","parameters","param","validate","collation","declarations","assigns","selects","io","sqlTextOrProcedure","addParameter","addOutputParameter","_execute","procedure","_this3","returnValue","enabled","params","map","k","logValue","substring","logName","logParams","p","_iterator4","_step4","returnStatus","callProcedure","_pause","_currentRequest","pause","_resume","resume","module","exports"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/mssql/lib/tedious/request.js"],"sourcesContent":["'use strict'\n\nconst tds = require('tedious')\nconst debug = require('debug')('mssql:tedi')\nconst BaseRequest = require('../base/request')\nconst RequestError = require('../error/request-error')\nconst { IDS, objectHasProperty } = require('../utils')\nconst { TYPES, DECLARATIONS, declare, cast } = require('../datatypes')\nconst Table = require('../table')\nconst { PARSERS: UDT } = require('../udt')\nconst { valueHandler } = require('../shared')\n\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B'\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B'\n\nconst N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n}\n\nconst getTediousType = function (type) {\n  switch (type) {\n    case TYPES.VarChar: return tds.TYPES.VarChar\n    case TYPES.NVarChar: return tds.TYPES.NVarChar\n    case TYPES.Text: return tds.TYPES.Text\n    case TYPES.Int: return tds.TYPES.Int\n    case TYPES.BigInt: return tds.TYPES.BigInt\n    case TYPES.TinyInt: return tds.TYPES.TinyInt\n    case TYPES.SmallInt: return tds.TYPES.SmallInt\n    case TYPES.Bit: return tds.TYPES.Bit\n    case TYPES.Float: return tds.TYPES.Float\n    case TYPES.Decimal: return tds.TYPES.Decimal\n    case TYPES.Numeric: return tds.TYPES.Numeric\n    case TYPES.Real: return tds.TYPES.Real\n    case TYPES.Money: return tds.TYPES.Money\n    case TYPES.SmallMoney: return tds.TYPES.SmallMoney\n    case TYPES.Time: return tds.TYPES.Time\n    case TYPES.Date: return tds.TYPES.Date\n    case TYPES.DateTime: return tds.TYPES.DateTime\n    case TYPES.DateTime2: return tds.TYPES.DateTime2\n    case TYPES.DateTimeOffset: return tds.TYPES.DateTimeOffset\n    case TYPES.SmallDateTime: return tds.TYPES.SmallDateTime\n    case TYPES.UniqueIdentifier: return tds.TYPES.UniqueIdentifier\n    case TYPES.Xml: return tds.TYPES.NVarChar\n    case TYPES.Char: return tds.TYPES.Char\n    case TYPES.NChar: return tds.TYPES.NChar\n    case TYPES.NText: return tds.TYPES.NVarChar\n    case TYPES.Image: return tds.TYPES.Image\n    case TYPES.Binary: return tds.TYPES.Binary\n    case TYPES.VarBinary: return tds.TYPES.VarBinary\n    case TYPES.UDT: case TYPES.Geography: case TYPES.Geometry: return tds.TYPES.UDT\n    case TYPES.TVP: return tds.TYPES.TVP\n    case TYPES.Variant: return tds.TYPES.Variant\n    default: return type\n  }\n}\n\nconst getMssqlType = function (type, length) {\n  if (typeof type !== 'object') return undefined\n\n  switch (type) {\n    case tds.TYPES.Char: return TYPES.Char\n    case tds.TYPES.NChar: return TYPES.NChar\n    case tds.TYPES.VarChar: return TYPES.VarChar\n    case tds.TYPES.NVarChar: return TYPES.NVarChar\n    case tds.TYPES.Text: return TYPES.Text\n    case tds.TYPES.NText: return TYPES.NText\n    case tds.TYPES.Int: return TYPES.Int\n    case tds.TYPES.BigInt: return TYPES.BigInt\n    case tds.TYPES.TinyInt: return TYPES.TinyInt\n    case tds.TYPES.SmallInt: return TYPES.SmallInt\n    case tds.TYPES.Bit: return TYPES.Bit\n    case tds.TYPES.Float: return TYPES.Float\n    case tds.TYPES.Real: return TYPES.Real\n    case tds.TYPES.Money: return TYPES.Money\n    case tds.TYPES.SmallMoney: return TYPES.SmallMoney\n    case tds.TYPES.Numeric: return TYPES.Numeric\n    case tds.TYPES.Decimal: return TYPES.Decimal\n    case tds.TYPES.DateTime: return TYPES.DateTime\n    case tds.TYPES.Time: return TYPES.Time\n    case tds.TYPES.Date: return TYPES.Date\n    case tds.TYPES.DateTime2: return TYPES.DateTime2\n    case tds.TYPES.DateTimeOffset: return TYPES.DateTimeOffset\n    case tds.TYPES.SmallDateTime: return TYPES.SmallDateTime\n    case tds.TYPES.UniqueIdentifier: return TYPES.UniqueIdentifier\n    case tds.TYPES.Image: return TYPES.Image\n    case tds.TYPES.Binary: return TYPES.Binary\n    case tds.TYPES.VarBinary: return TYPES.VarBinary\n    case tds.TYPES.Xml: return TYPES.Xml\n    case tds.TYPES.UDT: return TYPES.UDT\n    case tds.TYPES.TVP: return TYPES.TVP\n    case tds.TYPES.Variant: return TYPES.Variant\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN: return TYPES.Bit\n        case N_TYPES.NumericN: return TYPES.Numeric\n        case N_TYPES.DecimalN: return TYPES.Decimal\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt\n          if (length === 4) return TYPES.Int\n          if (length === 2) return TYPES.SmallInt\n          return TYPES.TinyInt\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float\n          return TYPES.Real\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money\n          return TYPES.SmallMoney\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime\n          return TYPES.SmallDateTime\n      }\n  }\n}\n\nconst createColumns = function (metadata, arrayRowMode) {\n  let out = {}\n  if (arrayRowMode) out = []\n  for (let index = 0, length = metadata.length; index < length; index++) {\n    const column = metadata[index]\n    const outColumn = {\n      index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    }\n\n    if (column.udtInfo) {\n      outColumn.udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      }\n\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName]\n      }\n    }\n\n    if (arrayRowMode) {\n      out.push(outColumn)\n    } else {\n      out[column.colName] = outColumn\n    }\n  }\n\n  return out\n}\n\nconst valueCorrection = function (value, metadata) {\n  const type = getMssqlType(metadata.type)\n  if (valueHandler.has(type)) {\n    return valueHandler.get(type)(value)\n  } else if ((metadata.type === tds.TYPES.UDT) && (value != null)) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value)\n    } else {\n      return value\n    }\n  } else {\n    return value\n  }\n}\n\nconst parameterCorrection = function (value) {\n  if (value instanceof Table) {\n    const tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    }\n\n    for (const col of value.columns) {\n      tvp.columns.push({\n        name: col.name,\n        type: getTediousType(col.type),\n        length: col.length,\n        scale: col.scale,\n        precision: col.precision\n      })\n    }\n\n    return tvp\n  } else {\n    return value\n  }\n}\n\nclass Request extends BaseRequest {\n  /*\n  Execute specified sql batch.\n  */\n\n  _batch (batch, callback) {\n    this._isBatch = true\n    this._query(batch, callback)\n  }\n\n  /*\n  Bulk load.\n  */\n\n  _bulk (table, options, callback) {\n    super._bulk(table, options, err => {\n      if (err) return callback(err)\n\n      try {\n        table._makeBulk()\n      } catch (e) {\n        return callback(new RequestError(e, 'EREQUEST'))\n      }\n\n      if (!table.name) {\n        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'))\n      }\n\n      if (table.name.charAt(0) === '@') {\n        return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'))\n      }\n\n      const errors = []\n      const errorHandlers = {}\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection) => {\n        const callbackWithRelease = (err, ...args) => {\n          try {\n            this.parent.release(connection)\n          } catch (e) {\n            // noop\n          }\n          callback(err, ...args)\n        }\n        if (err) return callbackWithRelease(err)\n\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this))\n          return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this))\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        const done = (err, rowCount) => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\n            err = new RequestError(err, 'EREQUEST')\n            if (this.stream) this.emit('error', err)\n            errors.push(err)\n          }\n\n          delete this._cancel\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            hasReturned = true\n\n            if (this.stream) {\n              callbackWithRelease(null, rowCount)\n            } else {\n              callbackWithRelease(error, rowCount)\n            }\n          }\n        }\n\n        const bulk = connection.newBulkLoad(table.path, options, done)\n\n        for (const col of table.columns) {\n          bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision })\n        }\n\n        if (table.create) {\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\n            if (err) return done(err)\n\n            connection.execBulkLoad(bulk, table.rows)\n          })\n          this._setCurrentRequest(req)\n\n          connection.execSqlBatch(req)\n        } else {\n          connection.execBulkLoad(bulk, table.rows)\n        }\n      })\n    })\n  }\n\n  /*\n  Execute specified sql command.\n  */\n\n  _query (command, callback) {\n    super._query(command, err => {\n      if (err) return callback(err)\n\n      const recordsets = []\n      const recordsetcolumns = []\n      const errors = []\n      const errorHandlers = {}\n      const output = {}\n      const rowsAffected = []\n\n      let columns = {}\n      let recordset = []\n      let batchLastRow = null\n      let batchHasOutput = false\n      let isChunkedRecordset = false\n      let chunksBuffer = null\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err)\n\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\n\n        let row\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this))\n          this.parent.release(connection)\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this))\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        debug('request(%d): query', IDS.get(this), command)\n\n        const req = new tds.Request(command, err => {\n          // tedious v15 has started using AggregateErrors to wrap multiple errors into single error objects\n          (err?.errors ? err.errors : [err]).forEach((e, i, { length }) => {\n            // to make sure we handle no-sql errors as well\n            if (e && (!errors.length || (errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message))) {\n              e = new RequestError(e, 'EREQUEST')\n              if (this.stream) this.emit('error', e)\n              errors.push(e)\n            }\n          })\n\n          // process batch outputs\n          if (batchHasOutput) {\n            if (!this.stream) batchLastRow = recordsets.pop()[0]\n\n            for (const name in batchLastRow) {\n              const value = batchLastRow[name]\n              if (name !== '___return___') {\n                output[name] = value\n              }\n            }\n          }\n\n          delete this._cancel\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            this.parent.release(connection)\n            hasReturned = true\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error)\n            } else {\n              debug('request(%d): completed', IDS.get(this))\n            }\n\n            if (this.stream) {\n              callback(null, null, output, rowsAffected, recordsetcolumns)\n            } else {\n              callback(error, recordsets, output, rowsAffected, recordsetcolumns)\n            }\n          }\n        })\n\n        this._setCurrentRequest(req)\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode)\n\n          isChunkedRecordset = false\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true\n            chunksBuffer = []\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // don't stream recordset with output values in batches\n              if (!columns.___return___) {\n                this.emit('recordset', columns)\n              }\n            } else {\n              this.emit('recordset', columns)\n            }\n          }\n          if (this.arrayRowMode) recordsetcolumns.push(columns)\n        })\n\n        const doneHandler = (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount)\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount)\n            }\n          }\n          // this function is called even when select only set variables so we should skip adding a new recordset\n          if (Object.keys(columns).length === 0) return\n\n          if (isChunkedRecordset) {\n            const concatenatedChunks = chunksBuffer.join('')\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (concatenatedChunks === '') {\n                  row = null\n                } else {\n                  row = JSON.parse(concatenatedChunks)\n                }\n              } catch (ex) {\n                row = null\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\n\n                if (this.stream) this.emit('error', ex2)\n\n                // we must collect errors even in stream mode\n                errors.push(ex2)\n              }\n            } else {\n              row = {}\n              row[Object.keys(columns)[0]] = concatenatedChunks\n            }\n\n            chunksBuffer = null\n\n            if (this.stream) {\n              this.emit('row', row)\n            } else {\n              recordset.push(row)\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            })\n\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value (name) { return Table.fromRecordset(this, name) }\n            })\n\n            recordsets.push(recordset)\n          }\n\n          recordset = []\n          columns = {}\n        }\n\n        req.on('doneInProc', doneHandler) // doneInProc handlers are used in both queries and batches\n        req.on('done', doneHandler) // done handlers are used in batches\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value\n        })\n\n        req.on('row', columns => {\n          if (!recordset) recordset = []\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value)\n          }\n\n          if (this.arrayRowMode) {\n            row = []\n          } else {\n            row = {}\n          }\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata)\n\n            if (this.arrayRowMode) {\n              row.push(col.value)\n            } else {\n              const exi = row[col.metadata.colName]\n              if (exi !== undefined) {\n                if (exi instanceof Array) {\n                  exi.push(col.value)\n                } else {\n                  row[col.metadata.colName] = [exi, col.value]\n                }\n              } else {\n                row[col.metadata.colName] = col.value\n              }\n            }\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // dont stream recordset with output values in batches\n              if (row.___return___) {\n                batchLastRow = row\n              } else {\n                this.emit('row', row)\n              }\n            } else {\n              this.emit('row', row)\n            }\n          } else {\n            recordset.push(row)\n          }\n        })\n\n        if (this._isBatch) {\n          if (Object.keys(this.parameters).length) {\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n\n              try {\n                param.value = getTediousType(param.type).validate(param.value, this.parent.collation)\n              } catch (e) {\n                e.message = `Validation failed for parameter '${name}'. ${e.message}`\n                const err = new RequestError(e, 'EPARAM')\n\n                this.parent.release(connection)\n                return callback(err)\n              }\n            }\n\n            const declarations = []\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n              declarations.push(`@${name} ${declare(param.type, param)}`)\n            }\n\n            const assigns = []\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`)\n            }\n\n            const selects = []\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n              if (param.io === 2) {\n                selects.push(`@${name} as [${name}]`)\n              }\n            }\n\n            batchHasOutput = selects.length > 0\n\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? (`select 1 as [___return___], ${selects.join(', ')}`) : ''}`\n          }\n        } else {\n          for (const name in this.parameters) {\n            if (!objectHasProperty(this.parameters, name)) {\n              continue\n            }\n            const param = this.parameters[name]\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n            }\n          }\n        }\n\n        try {\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req)\n        } catch (error) {\n          handleError(true, connection, error)\n        }\n      })\n    })\n  }\n\n  /*\n  Execute stored procedure with specified parameters.\n  */\n\n  _execute (procedure, callback) {\n    super._execute(procedure, err => {\n      if (err) return callback(err)\n\n      const recordsets = []\n      const recordsetcolumns = []\n      const errors = []\n      const errorHandlers = {}\n      const output = {}\n      const rowsAffected = []\n\n      let columns = {}\n      let recordset = []\n      let returnValue = 0\n      let isChunkedRecordset = false\n      let chunksBuffer = null\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err)\n\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\n\n        let row\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this))\n          this.parent.release(connection)\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this))\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        if (debug.enabled) {\n          // log stored procedure executions and provided parameters\n          const params = Object.keys(this.parameters).map(k => this.parameters[k])\n          // cut long string parameters short to keep log somewhat clean\n          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s\n          // format parameter names as 'my_parameter [sql.Int]'\n          const logName = param => param.name + ' [sql.' + param.type.name + ']'\n          const logParams = {}\n          params.forEach(p => { logParams[logName(p)] = logValue(p.value) })\n          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams)\n        }\n\n        const req = new tds.Request(procedure, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\n            err = new RequestError(err, 'EREQUEST')\n            if (this.stream) this.emit('error', err)\n            errors.push(err)\n          }\n\n          delete this._cancel\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            this.parent.release(connection)\n            hasReturned = true\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error)\n            } else {\n              debug('request(%d): complete', IDS.get(this))\n            }\n\n            if (this.stream) {\n              callback(null, null, output, returnValue, rowsAffected, recordsetcolumns)\n            } else {\n              callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns)\n            }\n          }\n        })\n\n        this._setCurrentRequest(req)\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode)\n\n          isChunkedRecordset = false\n          if ((metadata.length === 1) && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true\n            chunksBuffer = []\n          }\n\n          if (this.stream) this.emit('recordset', columns)\n          if (this.arrayRowMode) recordsetcolumns.push(columns)\n        })\n\n        req.on('row', columns => {\n          if (!recordset) recordset = []\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value)\n          }\n\n          if (this.arrayRowMode) {\n            row = []\n          } else {\n            row = {}\n          }\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata)\n\n            if (this.arrayRowMode) {\n              row.push(col.value)\n            } else {\n              const exi = row[col.metadata.colName]\n              if (exi != null) {\n                if (exi instanceof Array) {\n                  exi.push(col.value)\n                } else {\n                  row[col.metadata.colName] = [exi, col.value]\n                }\n              } else {\n                row[col.metadata.colName] = col.value\n              }\n            }\n          }\n\n          if (this.stream) {\n            this.emit('row', row)\n          } else {\n            recordset.push(row)\n          }\n        })\n\n        req.on('doneInProc', (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount)\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount)\n            }\n          }\n\n          // filter empty recordsets when NOCOUNT is OFF\n          if (Object.keys(columns).length === 0) return\n\n          if (isChunkedRecordset) {\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (chunksBuffer.length === 0) {\n                  row = null\n                } else {\n                  row = JSON.parse(chunksBuffer.join(''))\n                }\n              } catch (ex) {\n                row = null\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\n\n                if (this.stream) this.emit('error', ex2)\n\n                // we must collect errors even in stream mode\n                errors.push(ex2)\n              }\n            } else {\n              row = {}\n              row[Object.keys(columns)[0]] = chunksBuffer.join('')\n            }\n\n            chunksBuffer = null\n\n            if (this.stream) {\n              this.emit('row', row)\n            } else {\n              recordset.push(row)\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            })\n\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value (name) { return Table.fromRecordset(this, name) }\n            })\n\n            recordsets.push(recordset)\n          }\n\n          recordset = []\n          columns = {}\n        })\n\n        req.on('doneProc', (rowCount, more, returnStatus) => {\n          returnValue = returnStatus\n        })\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value\n        })\n\n        for (const name in this.parameters) {\n          if (!objectHasProperty(this.parameters, name)) {\n            continue\n          }\n          const param = this.parameters[name]\n          if (param.io === 1) {\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n          } else {\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n          }\n        }\n\n        connection.callProcedure(req)\n      })\n    })\n  }\n\n  _pause () {\n    super._pause()\n    if (this._currentRequest) {\n      this._currentRequest.pause()\n    }\n  }\n\n  _resume () {\n    super._resume()\n    if (this._currentRequest) {\n      this._currentRequest.resume()\n    }\n  }\n}\n\nmodule.exports = Request\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}