{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _nativeDuplexpair = _interopRequireDefault(require(\"native-duplexpair\"));\nvar tls = _interopRequireWildcard(require(\"tls\"));\nvar _events = require(\"events\");\nvar _message = _interopRequireDefault(require(\"./message\"));\nvar _packet = require(\"./packet\");\nvar _incomingMessageStream = _interopRequireDefault(require(\"./incoming-message-stream\"));\nvar _outgoingMessageStream = _interopRequireDefault(require(\"./outgoing-message-stream\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nclass MessageIO extends _events.EventEmitter {\n  constructor(socket, packetSize, debug) {\n    super();\n    this.socket = void 0;\n    this.debug = void 0;\n    this.tlsNegotiationComplete = void 0;\n    this.incomingMessageStream = void 0;\n    this.outgoingMessageStream = void 0;\n    this.securePair = void 0;\n    this.incomingMessageIterator = void 0;\n    this.socket = socket;\n    this.debug = debug;\n    this.tlsNegotiationComplete = false;\n    this.incomingMessageStream = new _incomingMessageStream.default(this.debug);\n    this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();\n    this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {\n      packetSize: packetSize\n    });\n    this.socket.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(this.socket);\n  }\n  packetSize() {\n    if (arguments.length > 0) {\n      const packetSize = arguments.length <= 0 ? undefined : arguments[0];\n      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n      this.outgoingMessageStream.packetSize = packetSize;\n    }\n    if (this.securePair) {\n      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    }\n    return this.outgoingMessageStream.packetSize;\n  } // Negotiate TLS encryption.\n\n  startTls(credentialsDetails, hostname, trustServerCertificate) {\n    if (!credentialsDetails.maxVersion || !['TLSv1.2', 'TLSv1.1', 'TLSv1'].includes(credentialsDetails.maxVersion)) {\n      credentialsDetails.maxVersion = 'TLSv1.2';\n    }\n    const secureContext = tls.createSecureContext(credentialsDetails);\n    return new Promise((resolve, reject) => {\n      const duplexpair = new _nativeDuplexpair.default();\n      const securePair = this.securePair = {\n        cleartext: tls.connect({\n          socket: duplexpair.socket1,\n          servername: hostname,\n          secureContext: secureContext,\n          rejectUnauthorized: !trustServerCertificate\n        }),\n        encrypted: duplexpair.socket2\n      };\n      const onSecureConnect = () => {\n        securePair.encrypted.removeListener('readable', onReadable);\n        securePair.cleartext.removeListener('error', onError);\n        securePair.cleartext.removeListener('secureConnect', onSecureConnect); // If we encounter any errors from this point on,\n        // we just forward them to the actual network socket.\n\n        securePair.cleartext.once('error', err => {\n          this.socket.destroy(err);\n        });\n        const cipher = securePair.cleartext.getCipher();\n        if (cipher) {\n          this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n        }\n        this.emit('secure', securePair.cleartext);\n        securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n        this.outgoingMessageStream.unpipe(this.socket);\n        this.socket.unpipe(this.incomingMessageStream);\n        this.socket.pipe(securePair.encrypted);\n        securePair.encrypted.pipe(this.socket);\n        securePair.cleartext.pipe(this.incomingMessageStream);\n        this.outgoingMessageStream.pipe(securePair.cleartext);\n        this.tlsNegotiationComplete = true;\n        resolve();\n      };\n      const onError = err => {\n        securePair.encrypted.removeListener('readable', onReadable);\n        securePair.cleartext.removeListener('error', onError);\n        securePair.cleartext.removeListener('secureConnect', onSecureConnect);\n        securePair.cleartext.destroy();\n        securePair.encrypted.destroy();\n        reject(err);\n      };\n      const onReadable = () => {\n        // When there is handshake data on the encryped stream of the secure pair,\n        // we wrap it into a `PRELOGIN` message and send it to the server.\n        //\n        // For each `PRELOGIN` message we sent we get back exactly one response message\n        // that contains the server's handshake response data.\n        const message = new _message.default({\n          type: _packet.TYPE.PRELOGIN,\n          resetConnection: false\n        });\n        let chunk;\n        while (chunk = securePair.encrypted.read()) {\n          message.write(chunk);\n        }\n        this.outgoingMessageStream.write(message);\n        message.end();\n        this.readMessage().then(async response => {\n          // Setup readable handler for the next round of handshaking.\n          // If we encounter a `secureConnect` on the cleartext side\n          // of the secure pair, the `readable` handler is cleared\n          // and no further handshake handling will happen.\n          securePair.encrypted.once('readable', onReadable);\n          for await (const data of response) {\n            // We feed the server's handshake response back into the\n            // encrypted end of the secure pair.\n            securePair.encrypted.write(data);\n          }\n        }).catch(onError);\n      };\n      securePair.cleartext.once('error', onError);\n      securePair.cleartext.once('secureConnect', onSecureConnect);\n      securePair.encrypted.once('readable', onReadable);\n    });\n  } // TODO listen for 'drain' event when socket.write returns false.\n  // TODO implement incomplete request cancelation (2.2.1.6)\n\n  sendMessage(packetType, data, resetConnection) {\n    const message = new _message.default({\n      type: packetType,\n      resetConnection: resetConnection\n    });\n    message.end(data);\n    this.outgoingMessageStream.write(message);\n    return message;\n  }\n  /**\n   * Read the next incoming message from the socket.\n   */\n\n  async readMessage() {\n    const result = await this.incomingMessageIterator.next();\n    if (result.done) {\n      throw new Error('unexpected end of message stream');\n    }\n    return result.value;\n  }\n}\nvar _default = MessageIO;\nexports.default = _default;\nmodule.exports = MessageIO;","map":{"version":3,"names":["_nativeDuplexpair","_interopRequireDefault","require","tls","_interopRequireWildcard","_events","_message","_packet","_incomingMessageStream","_outgoingMessageStream","MessageIO","EventEmitter","constructor","socket","packetSize","debug","tlsNegotiationComplete","incomingMessageStream","outgoingMessageStream","securePair","incomingMessageIterator","default","Symbol","asyncIterator","pipe","arguments","length","undefined","log","cleartext","setMaxSendFragment","startTls","credentialsDetails","hostname","trustServerCertificate","maxVersion","includes","secureContext","createSecureContext","Promise","resolve","reject","duplexpair","connect","socket1","servername","rejectUnauthorized","encrypted","socket2","onSecureConnect","removeListener","onReadable","onError","once","err","destroy","cipher","getCipher","name","version","emit","unpipe","message","type","TYPE","PRELOGIN","resetConnection","chunk","read","write","end","readMessage","then","response","data","catch","sendMessage","packetType","result","next","done","Error","value","module","exports"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/tedious/src/message-io.ts"],"sourcesContent":["import DuplexPair from 'native-duplexpair';\n\nimport { Duplex } from 'stream';\nimport * as tls from 'tls';\nimport { Socket } from 'net';\nimport { EventEmitter } from 'events';\n\nimport Debug from './debug';\n\nimport Message from './message';\nimport { TYPE } from './packet';\n\nimport IncomingMessageStream from './incoming-message-stream';\nimport OutgoingMessageStream from './outgoing-message-stream';\n\nclass MessageIO extends EventEmitter {\n  socket: Socket;\n  debug: Debug;\n\n  tlsNegotiationComplete: boolean;\n\n  private incomingMessageStream: IncomingMessageStream;\n  outgoingMessageStream: OutgoingMessageStream;\n\n  securePair?: {\n    cleartext: tls.TLSSocket;\n    encrypted: Duplex;\n  }\n\n  incomingMessageIterator: AsyncIterableIterator<Message>;\n\n  constructor(socket: Socket, packetSize: number, debug: Debug) {\n    super();\n\n    this.socket = socket;\n    this.debug = debug;\n\n    this.tlsNegotiationComplete = false;\n\n    this.incomingMessageStream = new IncomingMessageStream(this.debug);\n    this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();\n\n    this.outgoingMessageStream = new OutgoingMessageStream(this.debug, { packetSize: packetSize });\n\n    this.socket.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(this.socket);\n  }\n\n  packetSize(...args: [number]) {\n    if (args.length > 0) {\n      const packetSize = args[0];\n      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n      this.outgoingMessageStream.packetSize = packetSize;\n    }\n\n    if (this.securePair) {\n      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    }\n\n    return this.outgoingMessageStream.packetSize;\n  }\n\n  // Negotiate TLS encryption.\n  startTls(credentialsDetails: tls.SecureContextOptions, hostname: string, trustServerCertificate: boolean) {\n    if (!credentialsDetails.maxVersion || !['TLSv1.2', 'TLSv1.1', 'TLSv1'].includes(credentialsDetails.maxVersion)) {\n      credentialsDetails.maxVersion = 'TLSv1.2';\n    }\n\n    const secureContext = tls.createSecureContext(credentialsDetails);\n\n    return new Promise<void>((resolve, reject) => {\n      const duplexpair = new DuplexPair();\n      const securePair = this.securePair = {\n        cleartext: tls.connect({\n          socket: duplexpair.socket1 as Socket,\n          servername: hostname,\n          secureContext: secureContext,\n          rejectUnauthorized: !trustServerCertificate\n        }),\n        encrypted: duplexpair.socket2\n      };\n\n      const onSecureConnect = () => {\n        securePair.encrypted.removeListener('readable', onReadable);\n        securePair.cleartext.removeListener('error', onError);\n        securePair.cleartext.removeListener('secureConnect', onSecureConnect);\n\n        // If we encounter any errors from this point on,\n        // we just forward them to the actual network socket.\n        securePair.cleartext.once('error', (err) => {\n          this.socket.destroy(err);\n        });\n\n        const cipher = securePair.cleartext.getCipher();\n        if (cipher) {\n          this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n        }\n\n        this.emit('secure', securePair.cleartext);\n\n        securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n\n        this.outgoingMessageStream.unpipe(this.socket);\n        this.socket.unpipe(this.incomingMessageStream);\n\n        this.socket.pipe(securePair.encrypted);\n        securePair.encrypted.pipe(this.socket);\n\n        securePair.cleartext.pipe(this.incomingMessageStream);\n        this.outgoingMessageStream.pipe(securePair.cleartext);\n\n        this.tlsNegotiationComplete = true;\n\n        resolve();\n      };\n\n      const onError = (err?: Error) => {\n        securePair.encrypted.removeListener('readable', onReadable);\n        securePair.cleartext.removeListener('error', onError);\n        securePair.cleartext.removeListener('secureConnect', onSecureConnect);\n\n        securePair.cleartext.destroy();\n        securePair.encrypted.destroy();\n\n        reject(err);\n      };\n\n      const onReadable = () => {\n        // When there is handshake data on the encryped stream of the secure pair,\n        // we wrap it into a `PRELOGIN` message and send it to the server.\n        //\n        // For each `PRELOGIN` message we sent we get back exactly one response message\n        // that contains the server's handshake response data.\n        const message = new Message({ type: TYPE.PRELOGIN, resetConnection: false });\n\n        let chunk;\n        while (chunk = securePair.encrypted.read()) {\n          message.write(chunk);\n        }\n        this.outgoingMessageStream.write(message);\n        message.end();\n\n        this.readMessage().then(async (response) => {\n          // Setup readable handler for the next round of handshaking.\n          // If we encounter a `secureConnect` on the cleartext side\n          // of the secure pair, the `readable` handler is cleared\n          // and no further handshake handling will happen.\n          securePair.encrypted.once('readable', onReadable);\n\n          for await (const data of response) {\n            // We feed the server's handshake response back into the\n            // encrypted end of the secure pair.\n            securePair.encrypted.write(data);\n          }\n        }).catch(onError);\n      };\n\n      securePair.cleartext.once('error', onError);\n      securePair.cleartext.once('secureConnect', onSecureConnect);\n      securePair.encrypted.once('readable', onReadable);\n    });\n  }\n\n  // TODO listen for 'drain' event when socket.write returns false.\n  // TODO implement incomplete request cancelation (2.2.1.6)\n  sendMessage(packetType: number, data?: Buffer, resetConnection?: boolean) {\n    const message = new Message({ type: packetType, resetConnection: resetConnection });\n    message.end(data);\n    this.outgoingMessageStream.write(message);\n    return message;\n  }\n\n  /**\n   * Read the next incoming message from the socket.\n   */\n  async readMessage(): Promise<Message> {\n    const result = await this.incomingMessageIterator.next();\n\n    if (result.done) {\n      throw new Error('unexpected end of message stream');\n    }\n\n    return result.value;\n  }\n}\n\nexport default MessageIO;\nmodule.exports = MessageIO;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}