{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.connectInParallel = connectInParallel;\nexports.connectInSequence = connectInSequence;\nexports.lookupAllAddresses = lookupAllAddresses;\nvar _net = _interopRequireDefault(require(\"net\"));\nvar punycode = _interopRequireWildcard(require(\"punycode\"));\nvar _abortError = _interopRequireDefault(require(\"./errors/abort-error\"));\nvar _esAggregateError = _interopRequireDefault(require(\"es-aggregate-error\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nasync function connectInParallel(options, lookup, signal) {\n  if (signal.aborted) {\n    throw new _abortError.default();\n  }\n  const addresses = await lookupAllAddresses(options.host, lookup, signal);\n  return await new Promise((resolve, reject) => {\n    const sockets = new Array(addresses.length);\n    const errors = [];\n    function onError(err) {\n      errors.push(err);\n      this.removeListener('error', onError);\n      this.removeListener('connect', onConnect);\n      this.destroy();\n      if (errors.length === addresses.length) {\n        signal.removeEventListener('abort', onAbort);\n        reject(new _esAggregateError.default(errors, 'Could not connect (parallel)'));\n      }\n    }\n    function onConnect() {\n      signal.removeEventListener('abort', onAbort);\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n        if (this === socket) {\n          continue;\n        }\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n      resolve(this);\n    }\n    const onAbort = () => {\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n      reject(new _abortError.default());\n    };\n    for (let i = 0, len = addresses.length; i < len; i++) {\n      const socket = sockets[i] = _net.default.connect({\n        ...options,\n        host: addresses[i].address,\n        family: addresses[i].family\n      });\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n    signal.addEventListener('abort', onAbort, {\n      once: true\n    });\n  });\n}\nasync function connectInSequence(options, lookup, signal) {\n  if (signal.aborted) {\n    throw new _abortError.default();\n  }\n  const errors = [];\n  const addresses = await lookupAllAddresses(options.host, lookup, signal);\n  for (const address of addresses) {\n    try {\n      return await new Promise((resolve, reject) => {\n        const socket = _net.default.connect({\n          ...options,\n          host: address.address,\n          family: address.family\n        });\n        const onAbort = () => {\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n          socket.destroy();\n          reject(new _abortError.default());\n        };\n        const onError = err => {\n          signal.removeEventListener('abort', onAbort);\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n          socket.destroy();\n          reject(err);\n        };\n        const onConnect = () => {\n          signal.removeEventListener('abort', onAbort);\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n          resolve(socket);\n        };\n        signal.addEventListener('abort', onAbort, {\n          once: true\n        });\n        socket.on('error', onError);\n        socket.on('connect', onConnect);\n      });\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        throw err;\n      }\n      errors.push(err);\n      continue;\n    }\n  }\n  throw new _esAggregateError.default(errors, 'Could not connect (sequence)');\n}\n/**\n * Look up all addresses for the given hostname.\n */\n\nasync function lookupAllAddresses(host, lookup, signal) {\n  if (signal.aborted) {\n    throw new _abortError.default();\n  }\n  if (_net.default.isIPv6(host)) {\n    return [{\n      address: host,\n      family: 6\n    }];\n  } else if (_net.default.isIPv4(host)) {\n    return [{\n      address: host,\n      family: 4\n    }];\n  } else {\n    return await new Promise((resolve, reject) => {\n      const onAbort = () => {\n        reject(new _abortError.default());\n      };\n      signal.addEventListener('abort', onAbort);\n      lookup(punycode.toASCII(host), {\n        all: true\n      }, (err, addresses) => {\n        signal.removeEventListener('abort', onAbort);\n        err ? reject(err) : resolve(addresses);\n      });\n    });\n  }\n}","map":{"version":3,"names":["_net","_interopRequireDefault","require","punycode","_interopRequireWildcard","_abortError","_esAggregateError","connectInParallel","options","lookup","signal","aborted","default","addresses","lookupAllAddresses","host","Promise","resolve","reject","sockets","Array","length","errors","onError","err","push","removeListener","onConnect","destroy","removeEventListener","onAbort","j","socket","i","len","connect","address","family","on","addEventListener","once","connectInSequence","Error","name","isIPv6","isIPv4","toASCII","all"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/tedious/src/connector.ts"],"sourcesContent":["import net from 'net';\nimport dns, { LookupAddress } from 'dns';\n\nimport * as punycode from 'punycode';\nimport { AbortSignal } from 'node-abort-controller';\nimport AbortError from './errors/abort-error';\n\nimport AggregateError from 'es-aggregate-error';\n\ntype LookupFunction = (hostname: string, options: dns.LookupAllOptions, callback: (err: NodeJS.ErrnoException | null, addresses: dns.LookupAddress[]) => void) => void;\n\nexport async function connectInParallel(options: { host: string, port: number, localAddress?: string | undefined }, lookup: LookupFunction, signal: AbortSignal) {\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  const addresses = await lookupAllAddresses(options.host, lookup, signal);\n\n  return await new Promise<net.Socket>((resolve, reject) => {\n    const sockets = new Array(addresses.length);\n\n    const errors: Error[] = [];\n\n    function onError(this: net.Socket, err: Error) {\n      errors.push(err);\n\n      this.removeListener('error', onError);\n      this.removeListener('connect', onConnect);\n\n      this.destroy();\n\n      if (errors.length === addresses.length) {\n        signal.removeEventListener('abort', onAbort);\n\n        reject(new AggregateError(errors, 'Could not connect (parallel)'));\n      }\n    }\n\n    function onConnect(this: net.Socket) {\n      signal.removeEventListener('abort', onAbort);\n\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n\n        if (this === socket) {\n          continue;\n        }\n\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n\n      resolve(this);\n    }\n\n    const onAbort = () => {\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n\n        socket.destroy();\n      }\n\n      reject(new AbortError());\n    };\n\n    for (let i = 0, len = addresses.length; i < len; i++) {\n      const socket = sockets[i] = net.connect({\n        ...options,\n        host: addresses[i].address,\n        family: addresses[i].family\n      });\n\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n\n    signal.addEventListener('abort', onAbort, { once: true });\n  });\n}\n\nexport async function connectInSequence(options: { host: string, port: number, localAddress?: string | undefined }, lookup: LookupFunction, signal: AbortSignal) {\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  const errors: any[] = [];\n  const addresses = await lookupAllAddresses(options.host, lookup, signal);\n\n  for (const address of addresses) {\n    try {\n      return await new Promise<net.Socket>((resolve, reject) => {\n        const socket = net.connect({\n          ...options,\n          host: address.address,\n          family: address.family\n        });\n\n        const onAbort = () => {\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n\n          socket.destroy();\n\n          reject(new AbortError());\n        };\n\n        const onError = (err: Error) => {\n          signal.removeEventListener('abort', onAbort);\n\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n\n          socket.destroy();\n\n          reject(err);\n        };\n\n        const onConnect = () => {\n          signal.removeEventListener('abort', onAbort);\n\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n\n          resolve(socket);\n        };\n\n        signal.addEventListener('abort', onAbort, { once: true });\n\n        socket.on('error', onError);\n        socket.on('connect', onConnect);\n      });\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        throw err;\n      }\n\n      errors.push(err);\n\n      continue;\n    }\n  }\n\n  throw new AggregateError(errors, 'Could not connect (sequence)');\n}\n\n/**\n * Look up all addresses for the given hostname.\n */\nexport async function lookupAllAddresses(host: string, lookup: LookupFunction, signal: AbortSignal): Promise<dns.LookupAddress[]> {\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  if (net.isIPv6(host)) {\n    return [{ address: host, family: 6 }];\n  } else if (net.isIPv4(host)) {\n    return [{ address: host, family: 4 }];\n  } else {\n    return await new Promise<LookupAddress[]>((resolve, reject) => {\n      const onAbort = () => {\n        reject(new AbortError());\n      };\n\n      signal.addEventListener('abort', onAbort);\n\n      lookup(punycode.toASCII(host), { all: true }, (err, addresses) => {\n        signal.removeEventListener('abort', onAbort);\n\n        err ? reject(err) : resolve(addresses);\n      });\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}