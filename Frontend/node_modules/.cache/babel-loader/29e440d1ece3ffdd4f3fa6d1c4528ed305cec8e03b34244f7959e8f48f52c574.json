{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withTimeout = withTimeout;\nvar _nodeAbortController = require(\"node-abort-controller\");\nvar _timeoutError = _interopRequireDefault(require(\"../errors/timeout-error\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Run the function `func` with an `AbortSignal` that will automatically abort after the time specified\n * by `timeout` or when the given `signal` is aborted.\n *\n * On timeout, the `timeoutSignal` will be aborted and a `TimeoutError` will be thrown.\n */\nasync function withTimeout(timeout, func, signal) {\n  const timeoutController = new _nodeAbortController.AbortController();\n  const abortCurrentAttempt = () => {\n    timeoutController.abort();\n  };\n  const timer = setTimeout(abortCurrentAttempt, timeout);\n  signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', abortCurrentAttempt, {\n    once: true\n  });\n  try {\n    return await func(timeoutController.signal);\n  } catch (err) {\n    if (err instanceof Error && err.name === 'AbortError' && !(signal && signal.aborted)) {\n      throw new _timeoutError.default();\n    }\n    throw err;\n  } finally {\n    signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', abortCurrentAttempt);\n    clearTimeout(timer);\n  }\n}","map":{"version":3,"names":["_nodeAbortController","require","_timeoutError","_interopRequireDefault","withTimeout","timeout","func","signal","timeoutController","AbortController","abortCurrentAttempt","abort","timer","setTimeout","addEventListener","once","err","Error","name","aborted","default","removeEventListener","clearTimeout"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/tedious/src/utils/with-timeout.ts"],"sourcesContent":["import { AbortController, AbortSignal } from 'node-abort-controller';\nimport TimeoutError from '../errors/timeout-error';\n\n/**\n * Run the function `func` with an `AbortSignal` that will automatically abort after the time specified\n * by `timeout` or when the given `signal` is aborted.\n *\n * On timeout, the `timeoutSignal` will be aborted and a `TimeoutError` will be thrown.\n */\nexport async function withTimeout<T>(timeout: number, func: (timeoutSignal: AbortSignal) => Promise<T>, signal?: AbortSignal): Promise<T> {\n  const timeoutController = new AbortController();\n  const abortCurrentAttempt = () => { timeoutController.abort(); };\n\n  const timer = setTimeout(abortCurrentAttempt, timeout);\n  signal?.addEventListener('abort', abortCurrentAttempt, { once: true });\n\n  try {\n    return await func(timeoutController.signal);\n  } catch (err) {\n    if (err instanceof Error && err.name === 'AbortError' && !(signal && signal.aborted)) {\n      throw new TimeoutError();\n    }\n\n    throw err;\n  } finally {\n    signal?.removeEventListener('abort', abortCurrentAttempt);\n    clearTimeout(timer);\n  }\n}\n"],"mappings":";;;;;;AAAA,IAAAA,oBAAA,GAAAC,OAAA;AACA,IAAAC,aAAA,GAAAC,sBAAA,CAAAF,OAAA;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeG,WAAfA,CAA8BC,OAA9B,EAA+CC,IAA/C,EAAiGC,MAAjG,EAAmI;EACxI,MAAMC,iBAAiB,GAAG,IAAIR,oBAAA,CAAAS,eAAJ,EAA1B;EACA,MAAMC,mBAAmB,GAAGA,CAAA,KAAM;IAAEF,iBAAiB,CAACG,KAAlB;EAA4B,CAAhE;EAEA,MAAMC,KAAK,GAAGC,UAAU,CAACH,mBAAD,EAAsBL,OAAtB,CAAxB;EACAE,MAAM,SAAN,IAAAA,MAAM,WAAN,YAAAA,MAAM,CAAEO,gBAAR,CAAyB,OAAzB,EAAkCJ,mBAAlC,EAAuD;IAAEK,IAAI,EAAE;EAAR,CAAvD;EAEA,IAAI;IACF,OAAO,MAAMT,IAAI,CAACE,iBAAiB,CAACD,MAAnB,CAAjB;EACD,CAFD,CAEE,OAAOS,GAAP,EAAY;IACZ,IAAIA,GAAG,YAAYC,KAAf,IAAwBD,GAAG,CAACE,IAAJ,KAAa,YAArC,IAAqD,EAAEX,MAAM,IAAIA,MAAM,CAACY,OAAnB,CAAzD,EAAsF;MACpF,MAAM,IAAIjB,aAAA,CAAAkB,OAAJ,EAAN;IACD;IAED,MAAMJ,GAAN;EACD,CARD,SAQU;IACRT,MAAM,SAAN,IAAAA,MAAM,WAAN,YAAAA,MAAM,CAAEc,mBAAR,CAA4B,OAA5B,EAAqCX,mBAArC;IACAY,YAAY,CAACV,KAAD,CAAZ;EACD;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}