{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    maxRetries: DEFAULT_RETRY_POLICY_COUNT\n  };\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    async sendRequest(request, next) {\n      var _a, _b;\n      let response;\n      let responseError;\n      let retryCount = -1;\n      // eslint-disable-next-line no-constant-condition\n      retryRequest: while (true) {\n        retryCount += 1;\n        response = undefined;\n        responseError = undefined;\n        try {\n          logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n          response = await next(request);\n          logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n        } catch (e) {\n          logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n          // RestErrors are valid targets for the retry strategies.\n          // If none of the retry strategies can work with them, they will be thrown later in this policy.\n          // If the received error is not a RestError, it is immediately thrown.\n          responseError = e;\n          if (!e || responseError.name !== \"RestError\") {\n            throw e;\n          }\n          response = responseError.response;\n        }\n        if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n          logger.error(`Retry ${retryCount}: Request aborted.`);\n          const abortError = new AbortError();\n          throw abortError;\n        }\n        if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {\n          logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n          if (responseError) {\n            throw responseError;\n          } else if (response) {\n            return response;\n          } else {\n            throw new Error(\"Maximum retries reached with no response or error to throw\");\n          }\n        }\n        logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n        strategiesLoop: for (const strategy of strategies) {\n          const strategyLogger = strategy.logger || retryPolicyLogger;\n          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n          const modifiers = strategy.retry({\n            retryCount,\n            response,\n            responseError\n          });\n          if (modifiers.skipStrategy) {\n            strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n            continue strategiesLoop;\n          }\n          const {\n            errorToThrow,\n            retryAfterInMs,\n            redirectTo\n          } = modifiers;\n          if (errorToThrow) {\n            strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n            throw errorToThrow;\n          }\n          if (retryAfterInMs || retryAfterInMs === 0) {\n            strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n            await delay(retryAfterInMs, undefined, {\n              abortSignal: request.abortSignal\n            });\n            continue retryRequest;\n          }\n          if (redirectTo) {\n            strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n            request.url = redirectTo;\n            continue retryRequest;\n          }\n        }\n        if (responseError) {\n          logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n          throw responseError;\n        }\n        if (response) {\n          logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n          return response;\n        }\n        // If all the retries skip and there's no response,\n        // we're still in the retry loop, so a new request will be sent\n        // until `maxRetries` is reached.\n      }\n    }\n  };\n}","map":{"version":3,"names":["delay","createClientLogger","AbortError","DEFAULT_RETRY_POLICY_COUNT","retryPolicyLogger","retryPolicyName","retryPolicy","strategies","options","arguments","length","undefined","maxRetries","logger","name","sendRequest","request","next","response","responseError","retryCount","retryRequest","info","requestId","e","error","_a","abortSignal","aborted","abortError","_b","Error","strategiesLoop","strategy","strategyLogger","modifiers","retry","skipStrategy","errorToThrow","retryAfterInMs","redirectTo","url"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/@azure/core-rest-pipeline/src/policies/retryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { RetryStrategy } from \"../retryStrategies/retryStrategy\";\nimport { RestError } from \"../restError\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { AzureLogger } from \"@azure/logger\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\n\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n\n/**\n * Options to the {@link retryPolicy}\n */\nexport interface RetryPolicyOptions {\n  /**\n   * Maximum number of retries. If not specified, it will limit to 3 retries.\n   */\n  maxRetries?: number;\n  /**\n   * Logger. If it's not provided, a default logger is used.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(\n  strategies: RetryStrategy[],\n  options: RetryPolicyOptions = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }\n): PipelinePolicy {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      let response: PipelineResponse | undefined;\n      let responseError: RestError | undefined;\n      let retryCount = -1;\n\n      // eslint-disable-next-line no-constant-condition\n      retryRequest: while (true) {\n        retryCount += 1;\n        response = undefined;\n        responseError = undefined;\n\n        try {\n          logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n          response = await next(request);\n          logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n        } catch (e: any) {\n          logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n\n          // RestErrors are valid targets for the retry strategies.\n          // If none of the retry strategies can work with them, they will be thrown later in this policy.\n          // If the received error is not a RestError, it is immediately thrown.\n          responseError = e as RestError;\n          if (!e || responseError.name !== \"RestError\") {\n            throw e;\n          }\n\n          response = responseError.response;\n        }\n\n        if (request.abortSignal?.aborted) {\n          logger.error(`Retry ${retryCount}: Request aborted.`);\n          const abortError = new AbortError();\n          throw abortError;\n        }\n\n        if (retryCount >= (options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT)) {\n          logger.info(\n            `Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`\n          );\n          if (responseError) {\n            throw responseError;\n          } else if (response) {\n            return response;\n          } else {\n            throw new Error(\"Maximum retries reached with no response or error to throw\");\n          }\n        }\n\n        logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n\n        strategiesLoop: for (const strategy of strategies) {\n          const strategyLogger = strategy.logger || retryPolicyLogger;\n          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n\n          const modifiers = strategy.retry({\n            retryCount,\n            response,\n            responseError,\n          });\n\n          if (modifiers.skipStrategy) {\n            strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n            continue strategiesLoop;\n          }\n\n          const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;\n\n          if (errorToThrow) {\n            strategyLogger.error(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`,\n              errorToThrow\n            );\n            throw errorToThrow;\n          }\n\n          if (retryAfterInMs || retryAfterInMs === 0) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`\n            );\n            await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });\n            continue retryRequest;\n          }\n\n          if (redirectTo) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`\n            );\n            request.url = redirectTo;\n            continue retryRequest;\n          }\n        }\n\n        if (responseError) {\n          logger.info(\n            `None of the retry strategies could work with the received error. Throwing it.`\n          );\n          throw responseError;\n        }\n        if (response) {\n          logger.info(\n            `None of the retry strategies could work with the received response. Returning it.`\n          );\n          return response;\n        }\n\n        // If all the retries skip and there's no response,\n        // we're still in the retry loop, so a new request will be sent\n        // until `maxRetries` is reached.\n      }\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}