{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _bl = _interopRequireDefault(require(\"bl\"));\nvar _stream = require(\"stream\");\nvar _message = _interopRequireDefault(require(\"./message\"));\nvar _packet = require(\"./packet\");\nvar _errors = require(\"./errors\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n  IncomingMessageStream\n  Transform received TDS data into individual IncomingMessage streams.\n*/\nclass IncomingMessageStream extends _stream.Transform {\n  constructor(debug) {\n    super({\n      readableObjectMode: true\n    });\n    this.debug = void 0;\n    this.bl = void 0;\n    this.currentMessage = void 0;\n    this.debug = debug;\n    this.currentMessage = undefined;\n    this.bl = new _bl.default();\n  }\n  pause() {\n    super.pause();\n    if (this.currentMessage) {\n      this.currentMessage.pause();\n    }\n    return this;\n  }\n  resume() {\n    super.resume();\n    if (this.currentMessage) {\n      this.currentMessage.resume();\n    }\n    return this;\n  }\n  processBufferedData(callback) {\n    // The packet header is always 8 bytes of length.\n    while (this.bl.length >= _packet.HEADER_LENGTH) {\n      // Get the full packet length\n      const length = this.bl.readUInt16BE(2);\n      if (length < _packet.HEADER_LENGTH) {\n        return callback(new _errors.ConnectionError('Unable to process incoming packet'));\n      }\n      if (this.bl.length >= length) {\n        const data = this.bl.slice(0, length);\n        this.bl.consume(length); // TODO: Get rid of creating `Packet` instances here.\n\n        const packet = new _packet.Packet(data);\n        this.debug.packet('Received', packet);\n        this.debug.data(packet);\n        let message = this.currentMessage;\n        if (message === undefined) {\n          this.currentMessage = message = new _message.default({\n            type: packet.type(),\n            resetConnection: false\n          });\n          this.push(message);\n        }\n        if (packet.isLast()) {\n          // Wait until the current message was fully processed before we\n          // continue processing any remaining messages.\n          message.once('end', () => {\n            this.currentMessage = undefined;\n            this.processBufferedData(callback);\n          });\n          message.end(packet.data());\n          return;\n        } else if (!message.write(packet.data())) {\n          // If too much data is buffering up in the\n          // current message, wait for it to drain.\n          message.once('drain', () => {\n            this.processBufferedData(callback);\n          });\n          return;\n        }\n      } else {\n        break;\n      }\n    } // Not enough data to read the next packet. Stop here and wait for\n    // the next call to `_transform`.\n\n    callback();\n  }\n  _transform(chunk, _encoding, callback) {\n    this.bl.append(chunk);\n    this.processBufferedData(callback);\n  }\n}\nvar _default = IncomingMessageStream;\nexports.default = _default;\nmodule.exports = IncomingMessageStream;","map":{"version":3,"names":["_bl","_interopRequireDefault","require","_stream","_message","_packet","_errors","IncomingMessageStream","Transform","constructor","debug","readableObjectMode","bl","currentMessage","undefined","default","pause","resume","processBufferedData","callback","length","HEADER_LENGTH","readUInt16BE","ConnectionError","data","slice","consume","packet","Packet","message","type","resetConnection","push","isLast","once","end","write","_transform","chunk","_encoding","append","module","exports"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/tedious/src/incoming-message-stream.ts"],"sourcesContent":["import BufferList from 'bl';\nimport { Transform } from 'stream';\n\nimport Debug from './debug';\nimport Message from './message';\nimport { Packet, HEADER_LENGTH } from './packet';\nimport { ConnectionError } from './errors';\n\n/**\n  IncomingMessageStream\n  Transform received TDS data into individual IncomingMessage streams.\n*/\nclass IncomingMessageStream extends Transform {\n  debug: Debug;\n  bl: any;\n  currentMessage: Message | undefined;\n\n  constructor(debug: Debug) {\n    super({ readableObjectMode: true });\n\n    this.debug = debug;\n\n    this.currentMessage = undefined;\n    this.bl = new BufferList();\n  }\n\n  pause() {\n    super.pause();\n\n    if (this.currentMessage) {\n      this.currentMessage.pause();\n    }\n\n    return this;\n  }\n\n  resume() {\n    super.resume();\n\n    if (this.currentMessage) {\n      this.currentMessage.resume();\n    }\n\n    return this;\n  }\n\n  processBufferedData(callback: (err?: ConnectionError) => void) {\n    // The packet header is always 8 bytes of length.\n    while (this.bl.length >= HEADER_LENGTH) {\n      // Get the full packet length\n      const length = this.bl.readUInt16BE(2);\n      if (length < HEADER_LENGTH) {\n        return callback(new ConnectionError('Unable to process incoming packet'));\n      }\n\n      if (this.bl.length >= length) {\n        const data = this.bl.slice(0, length);\n        this.bl.consume(length);\n\n        // TODO: Get rid of creating `Packet` instances here.\n        const packet = new Packet(data);\n        this.debug.packet('Received', packet);\n        this.debug.data(packet);\n\n        let message = this.currentMessage;\n        if (message === undefined) {\n          this.currentMessage = message = new Message({ type: packet.type(), resetConnection: false });\n          this.push(message);\n        }\n\n        if (packet.isLast()) {\n          // Wait until the current message was fully processed before we\n          // continue processing any remaining messages.\n          message.once('end', () => {\n            this.currentMessage = undefined;\n            this.processBufferedData(callback);\n          });\n          message.end(packet.data());\n          return;\n        } else if (!message.write(packet.data())) {\n          // If too much data is buffering up in the\n          // current message, wait for it to drain.\n          message.once('drain', () => {\n            this.processBufferedData(callback);\n          });\n          return;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Not enough data to read the next packet. Stop here and wait for\n    // the next call to `_transform`.\n    callback();\n  }\n\n  _transform(chunk: Buffer, _encoding: string, callback: () => void) {\n    this.bl.append(chunk);\n    this.processBufferedData(callback);\n  }\n}\n\nexport default IncomingMessageStream;\nmodule.exports = IncomingMessageStream;\n"],"mappings":";;;;;;AAAA,IAAAA,GAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,OAAA,GAAAD,OAAA;AAGA,IAAAE,QAAA,GAAAH,sBAAA,CAAAC,OAAA;AACA,IAAAG,OAAA,GAAAH,OAAA;AACA,IAAAI,OAAA,GAAAJ,OAAA;;;;;;;AAEA;AACA;AACA;AACA;AACA,MAAMK,qBAAN,SAAoCJ,OAAA,CAAAK,SAApC,CAA8C;EAK5CC,WAAWA,CAACC,KAAD,EAAe;IACxB,MAAM;MAAEC,kBAAkB,EAAE;IAAtB,CAAN;IADwB,KAJ1BD,KAI0B;IAAA,KAH1BE,EAG0B;IAAA,KAF1BC,cAE0B;IAGxB,KAAKH,KAAL,GAAaA,KAAb;IAEA,KAAKG,cAAL,GAAsBC,SAAtB;IACA,KAAKF,EAAL,GAAU,IAAIZ,GAAA,CAAAe,OAAJ,EAAV;EACD;EAEDC,KAAKA,CAAA,EAAG;IACN,MAAMA,KAAN;IAEA,IAAI,KAAKH,cAAT,EAAyB;MACvB,KAAKA,cAAL,CAAoBG,KAApB;IACD;IAED,OAAO,IAAP;EACD;EAEDC,MAAMA,CAAA,EAAG;IACP,MAAMA,MAAN;IAEA,IAAI,KAAKJ,cAAT,EAAyB;MACvB,KAAKA,cAAL,CAAoBI,MAApB;IACD;IAED,OAAO,IAAP;EACD;EAEDC,mBAAmBA,CAACC,QAAD,EAA4C;IAC7D;IACA,OAAO,KAAKP,EAAL,CAAQQ,MAAR,IAAkBf,OAAA,CAAAgB,aAAzB,EAAwC;MACtC;MACA,MAAMD,MAAM,GAAG,KAAKR,EAAL,CAAQU,YAAR,CAAqB,CAArB,CAAf;MACA,IAAIF,MAAM,GAAGf,OAAA,CAAAgB,aAAb,EAA4B;QAC1B,OAAOF,QAAQ,CAAC,IAAIb,OAAA,CAAAiB,eAAJ,CAAoB,mCAApB,CAAD,CAAf;MACD;MAED,IAAI,KAAKX,EAAL,CAAQQ,MAAR,IAAkBA,MAAtB,EAA8B;QAC5B,MAAMI,IAAI,GAAG,KAAKZ,EAAL,CAAQa,KAAR,CAAc,CAAd,EAAiBL,MAAjB,CAAb;QACA,KAAKR,EAAL,CAAQc,OAAR,CAAgBN,MAAhB,EAF4B,CAI5B;;QACA,MAAMO,MAAM,GAAG,IAAItB,OAAA,CAAAuB,MAAJ,CAAWJ,IAAX,CAAf;QACA,KAAKd,KAAL,CAAWiB,MAAX,CAAkB,UAAlB,EAA8BA,MAA9B;QACA,KAAKjB,KAAL,CAAWc,IAAX,CAAgBG,MAAhB;QAEA,IAAIE,OAAO,GAAG,KAAKhB,cAAnB;QACA,IAAIgB,OAAO,KAAKf,SAAhB,EAA2B;UACzB,KAAKD,cAAL,GAAsBgB,OAAO,GAAG,IAAIzB,QAAA,CAAAW,OAAJ,CAAY;YAAEe,IAAI,EAAEH,MAAM,CAACG,IAAP,EAAR;YAAuBC,eAAe,EAAE;UAAxC,CAAZ,CAAhC;UACA,KAAKC,IAAL,CAAUH,OAAV;QACD;QAED,IAAIF,MAAM,CAACM,MAAP,EAAJ,EAAqB;UACnB;UACA;UACAJ,OAAO,CAACK,IAAR,CAAa,KAAb,EAAoB,MAAM;YACxB,KAAKrB,cAAL,GAAsBC,SAAtB;YACA,KAAKI,mBAAL,CAAyBC,QAAzB;UACD,CAHD;UAIAU,OAAO,CAACM,GAAR,CAAYR,MAAM,CAACH,IAAP,EAAZ;UACA;QACD,CATD,MASO,IAAI,CAACK,OAAO,CAACO,KAAR,CAAcT,MAAM,CAACH,IAAP,EAAd,CAAL,EAAmC;UACxC;UACA;UACAK,OAAO,CAACK,IAAR,CAAa,OAAb,EAAsB,MAAM;YAC1B,KAAKhB,mBAAL,CAAyBC,QAAzB;UACD,CAFD;UAGA;QACD;MACF,CAhCD,MAgCO;QACL;MACD;IACF,CA5C4D,CA8C7D;IACA;;IACAA,QAAQ;EACT;EAEDkB,UAAUA,CAACC,KAAD,EAAgBC,SAAhB,EAAmCpB,QAAnC,EAAyD;IACjE,KAAKP,EAAL,CAAQ4B,MAAR,CAAeF,KAAf;IACA,KAAKpB,mBAAL,CAAyBC,QAAzB;EACD;AAxF2C;eA2F/BZ,qB;;AACfkC,MAAM,CAACC,OAAP,GAAiBnC,qBAAjB"},"metadata":{},"sourceType":"script","externalDependencies":[]}