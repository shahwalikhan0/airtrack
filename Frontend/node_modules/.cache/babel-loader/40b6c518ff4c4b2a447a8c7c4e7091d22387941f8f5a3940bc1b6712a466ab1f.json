{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { tracingClient } from \"../util/tracing\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\nexport class ChainedTokenCredential {\n  /**\n   * Creates an instance of ChainedTokenCredential using the given credentials.\n   *\n   * @param sources - `TokenCredential` implementations to be tried in order.\n   *\n   * Example usage:\n   * ```javascript\n   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n   * ```\n   */\n  constructor() {\n    /**\n     * The message to use when the chained token fails to get a token\n     */\n    this.UnavailableMessage = \"ChainedTokenCredential => failed to retrieve a token from the included credentials\";\n    this._sources = [];\n    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n      sources[_key] = arguments[_key];\n    }\n    this._sources = sources;\n  }\n  /**\n   * Returns the first access token returned by one of the chained\n   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an access token.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                `TokenCredential` implementation might make.\n   */\n  async getToken(scopes) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let token = null;\n    let successfulCredentialName = \"\";\n    const errors = [];\n    return tracingClient.withSpan(\"ChainedTokenCredential.getToken\", options, async updatedOptions => {\n      for (let i = 0; i < this._sources.length && token === null; i++) {\n        try {\n          token = await this._sources[i].getToken(scopes, updatedOptions);\n          successfulCredentialName = this._sources[i].constructor.name;\n        } catch (err) {\n          if (err.name === \"CredentialUnavailableError\" || err.name === \"AuthenticationRequiredError\") {\n            errors.push(err);\n          } else {\n            logger.getToken.info(formatError(scopes, err));\n            throw err;\n          }\n        }\n      }\n      if (!token && errors.length > 0) {\n        const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n        logger.getToken.info(formatError(scopes, err));\n        throw err;\n      }\n      logger.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);\n      if (token === null) {\n        throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n      }\n      return token;\n    });\n  }\n}","map":{"version":3,"names":["AggregateAuthenticationError","CredentialUnavailableError","tracingClient","credentialLogger","formatError","formatSuccess","logger","ChainedTokenCredential","constructor","UnavailableMessage","_sources","_len","arguments","length","sources","Array","_key","getToken","scopes","options","undefined","token","successfulCredentialName","errors","withSpan","updatedOptions","i","name","err","push","info"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/@azure/identity/src/credentials/chainedTokenCredential.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\n\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { tracingClient } from \"../util/tracing\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\n\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\nexport class ChainedTokenCredential implements TokenCredential {\n  /**\n   * The message to use when the chained token fails to get a token\n   */\n  protected UnavailableMessage =\n    \"ChainedTokenCredential => failed to retrieve a token from the included credentials\";\n\n  private _sources: TokenCredential[] = [];\n\n  /**\n   * Creates an instance of ChainedTokenCredential using the given credentials.\n   *\n   * @param sources - `TokenCredential` implementations to be tried in order.\n   *\n   * Example usage:\n   * ```javascript\n   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n   * ```\n   */\n  constructor(...sources: TokenCredential[]) {\n    this._sources = sources;\n  }\n\n  /**\n   * Returns the first access token returned by one of the chained\n   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an access token.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                `TokenCredential` implementation might make.\n   */\n  async getToken(scopes: string | string[], options: GetTokenOptions = {}): Promise<AccessToken> {\n    let token: AccessToken | null = null;\n    let successfulCredentialName = \"\";\n    const errors: Error[] = [];\n\n    return tracingClient.withSpan(\n      \"ChainedTokenCredential.getToken\",\n      options,\n      async (updatedOptions) => {\n        for (let i = 0; i < this._sources.length && token === null; i++) {\n          try {\n            token = await this._sources[i].getToken(scopes, updatedOptions);\n            successfulCredentialName = this._sources[i].constructor.name;\n          } catch (err: any) {\n            if (\n              err.name === \"CredentialUnavailableError\" ||\n              err.name === \"AuthenticationRequiredError\"\n            ) {\n              errors.push(err);\n            } else {\n              logger.getToken.info(formatError(scopes, err));\n              throw err;\n            }\n          }\n        }\n\n        if (!token && errors.length > 0) {\n          const err = new AggregateAuthenticationError(\n            errors,\n            \"ChainedTokenCredential authentication failed.\"\n          );\n          logger.getToken.info(formatError(scopes, err));\n          throw err;\n        }\n\n        logger.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);\n\n        if (token === null) {\n          throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n        }\n        return token;\n      }\n    );\n  }\n}\n"],"mappings":"AAAA;AACA;AAIA,SAASA,4BAA4B,EAAEC,0BAA0B,QAAQ,WAAW;AACpF,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,gBAAgB,EAAEC,WAAW,EAAEC,aAAa,QAAQ,iBAAiB;AAE9E;;;AAGA,OAAO,MAAMC,MAAM,GAAGH,gBAAgB,CAAC,wBAAwB,CAAC;AAEhE;;;;AAIA,OAAM,MAAOI,sBAAsB;EASjC;;;;;;;;;;;;EAYAC,YAAA,EAAyC;IApBzC;;;IAGU,KAAAC,kBAAkB,GAC1B,oFAAoF;IAE9E,KAAAC,QAAQ,GAAsB,EAAE;IAAC,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAc1BC,OAA0B,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAA1BF,OAA0B,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;IAAA;IACvC,IAAI,CAACN,QAAQ,GAAGI,OAAO;EACzB;EAEA;;;;;;;;;;;;;EAaA,MAAMG,QAAQA,CAACC,MAAyB,EAA+B;IAAA,IAA7BC,OAAA,GAAAP,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAQ,SAAA,GAAAR,SAAA,MAA2B,EAAE;IACrE,IAAIS,KAAK,GAAuB,IAAI;IACpC,IAAIC,wBAAwB,GAAG,EAAE;IACjC,MAAMC,MAAM,GAAY,EAAE;IAE1B,OAAOrB,aAAa,CAACsB,QAAQ,CAC3B,iCAAiC,EACjCL,OAAO,EACP,MAAOM,cAAc,IAAI;MACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAChB,QAAQ,CAACG,MAAM,IAAIQ,KAAK,KAAK,IAAI,EAAEK,CAAC,EAAE,EAAE;QAC/D,IAAI;UACFL,KAAK,GAAG,MAAM,IAAI,CAACX,QAAQ,CAACgB,CAAC,CAAC,CAACT,QAAQ,CAACC,MAAM,EAAEO,cAAc,CAAC;UAC/DH,wBAAwB,GAAG,IAAI,CAACZ,QAAQ,CAACgB,CAAC,CAAC,CAAClB,WAAW,CAACmB,IAAI;SAC7D,CAAC,OAAOC,GAAQ,EAAE;UACjB,IACEA,GAAG,CAACD,IAAI,KAAK,4BAA4B,IACzCC,GAAG,CAACD,IAAI,KAAK,6BAA6B,EAC1C;YACAJ,MAAM,CAACM,IAAI,CAACD,GAAG,CAAC;WACjB,MAAM;YACLtB,MAAM,CAACW,QAAQ,CAACa,IAAI,CAAC1B,WAAW,CAACc,MAAM,EAAEU,GAAG,CAAC,CAAC;YAC9C,MAAMA,GAAG;;;;MAKf,IAAI,CAACP,KAAK,IAAIE,MAAM,CAACV,MAAM,GAAG,CAAC,EAAE;QAC/B,MAAMe,GAAG,GAAG,IAAI5B,4BAA4B,CAC1CuB,MAAM,EACN,+CAA+C,CAChD;QACDjB,MAAM,CAACW,QAAQ,CAACa,IAAI,CAAC1B,WAAW,CAACc,MAAM,EAAEU,GAAG,CAAC,CAAC;QAC9C,MAAMA,GAAG;;MAGXtB,MAAM,CAACW,QAAQ,CAACa,IAAI,CAAC,cAAcR,wBAAwB,KAAKjB,aAAa,CAACa,MAAM,CAAC,EAAE,CAAC;MAExF,IAAIG,KAAK,KAAK,IAAI,EAAE;QAClB,MAAM,IAAIpB,0BAA0B,CAAC,kCAAkC,CAAC;;MAE1E,OAAOoB,KAAK;IACd,CAAC,CACF;EACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}