{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline\";\nimport { flattenResponse } from \"./utils\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nimport { getRequestUrl } from \"./urlHelpers\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers\";\nimport { logger } from \"./log\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param credential - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _a, _b;\n    this._requestContentType = options.requestContentType;\n    this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;\n    if (options.baseUri) {\n      logger.warning(\"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\");\n    }\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n    if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {\n      for (const {\n        policy,\n        position\n      } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase\n        });\n      }\n    }\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n  async sendRequest(request) {\n    return this.pipeline.sendRequest(this._httpClient, request);\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n  async sendOperationRequest(operationArguments, operationSpec) {\n    const endpoint = operationSpec.baseUrl || this._endpoint;\n    if (!endpoint) {\n      throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\");\n    }\n    // Templatized URLs sometimes reference properties on the ServiceClient child class,\n    // so we have to pass `this` below in order to search these properties if they're\n    // not part of OperationArguments\n    const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n    const request = createPipelineRequest({\n      url\n    });\n    request.method = operationSpec.httpMethod;\n    const operationInfo = getOperationRequestInfo(request);\n    operationInfo.operationSpec = operationSpec;\n    operationInfo.operationArguments = operationArguments;\n    const contentType = operationSpec.contentType || this._requestContentType;\n    if (contentType && operationSpec.requestBody) {\n      request.headers.set(\"Content-Type\", contentType);\n    }\n    const options = operationArguments.options;\n    if (options) {\n      const requestOptions = options.requestOptions;\n      if (requestOptions) {\n        if (requestOptions.timeout) {\n          request.timeout = requestOptions.timeout;\n        }\n        if (requestOptions.onUploadProgress) {\n          request.onUploadProgress = requestOptions.onUploadProgress;\n        }\n        if (requestOptions.onDownloadProgress) {\n          request.onDownloadProgress = requestOptions.onDownloadProgress;\n        }\n        if (requestOptions.shouldDeserialize !== undefined) {\n          operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n        }\n        if (requestOptions.allowInsecureConnection) {\n          request.allowInsecureConnection = true;\n        }\n      }\n      if (options.abortSignal) {\n        request.abortSignal = options.abortSignal;\n      }\n      if (options.tracingOptions) {\n        request.tracingOptions = options.tracingOptions;\n      }\n    }\n    if (this._allowInsecureConnection) {\n      request.allowInsecureConnection = true;\n    }\n    if (request.streamResponseStatusCodes === undefined) {\n      request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n    }\n    try {\n      const rawResponse = await this.sendRequest(request);\n      const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n      if (options === null || options === void 0 ? void 0 : options.onResponse) {\n        options.onResponse(rawResponse, flatResponse);\n      }\n      return flatResponse;\n    } catch (error) {\n      if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n        const rawResponse = error.response;\n        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n        error.details = flatResponse;\n        if (options === null || options === void 0 ? void 0 : options.onResponse) {\n          options.onResponse(rawResponse, flatResponse, error);\n        }\n      }\n      throw error;\n    }\n  }\n}\nfunction createDefaultPipeline(options) {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions = options.credential && credentialScopes ? {\n    credentialScopes,\n    credential: options.credential\n  } : undefined;\n  return createClientPipeline(Object.assign(Object.assign({}, options), {\n    credentialOptions\n  }));\n}\nfunction getCredentialScopes(options) {\n  if (options.credentialScopes) {\n    const scopes = options.credentialScopes;\n    return Array.isArray(scopes) ? scopes.map(scope => new URL(scope).toString()) : new URL(scopes).toString();\n  }\n  if (options.endpoint) {\n    return `${options.endpoint}/.default`;\n  }\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n  }\n  return undefined;\n}","map":{"version":3,"names":["createPipelineRequest","createClientPipeline","flattenResponse","getCachedDefaultHttpClient","getOperationRequestInfo","getRequestUrl","getStreamingResponseStatusCodes","logger","ServiceClient","constructor","options","arguments","length","undefined","_requestContentType","requestContentType","_endpoint","_a","endpoint","baseUri","warning","_allowInsecureConnection","allowInsecureConnection","_httpClient","httpClient","pipeline","createDefaultPipeline","_b","additionalPolicies","policy","position","afterPhase","addPolicy","sendRequest","request","sendOperationRequest","operationArguments","operationSpec","baseUrl","Error","url","method","httpMethod","operationInfo","contentType","requestBody","headers","set","requestOptions","timeout","onUploadProgress","onDownloadProgress","shouldDeserialize","abortSignal","tracingOptions","streamResponseStatusCodes","rawResponse","flatResponse","responses","status","onResponse","error","response","statusCode","details","credentialScopes","getCredentialScopes","credentialOptions","credential","Object","assign","scopes","Array","isArray","map","scope","URL","toString"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/@azure/core-client/src/serviceClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  CommonClientOptions,\n  OperationArguments,\n  OperationRequest,\n  OperationSpec,\n} from \"./interfaces\";\nimport {\n  HttpClient,\n  Pipeline,\n  PipelineRequest,\n  PipelineResponse,\n  createPipelineRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { TokenCredential } from \"@azure/core-auth\";\nimport { createClientPipeline } from \"./pipeline\";\nimport { flattenResponse } from \"./utils\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nimport { getRequestUrl } from \"./urlHelpers\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers\";\nimport { logger } from \"./log\";\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions extends CommonClientOptions {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   * @deprecated This property is deprecated and will be removed soon, please use endpoint instead\n   */\n  baseUri?: string;\n  /**\n   * If specified, this is the endpoint that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   * to encourage customer to use endpoint, we mark the baseUri as deprecated.\n   */\n  endpoint?: string;\n  /**\n   * If specified, will be used to build the BearerTokenAuthenticationPolicy.\n   */\n  credentialScopes?: string | string[];\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  requestContentType?: string;\n  /**\n   * Credential used to authenticate the request.\n   */\n  credential?: TokenCredential;\n  /**\n   * A customized pipeline to use, otherwise a default one will be created.\n   */\n  pipeline?: Pipeline;\n}\n\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  private readonly _endpoint?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  private readonly _requestContentType?: string;\n\n  /**\n   * Set to true if the request is sent over HTTP instead of HTTPS\n   */\n  private readonly _allowInsecureConnection?: boolean;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n\n  /**\n   * The pipeline used by this client to make requests\n   */\n  public readonly pipeline: Pipeline;\n\n  /**\n   * The ServiceClient constructor\n   * @param credential - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options: ServiceClientOptions = {}) {\n    this._requestContentType = options.requestContentType;\n    this._endpoint = options.endpoint ?? options.baseUri;\n    if (options.baseUri) {\n      logger.warning(\n        \"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\"\n      );\n    }\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n    if (options.additionalPolicies?.length) {\n      for (const { policy, position } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase,\n        });\n      }\n    }\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    return this.pipeline.sendRequest(this._httpClient, request);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n  async sendOperationRequest<T>(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec\n  ): Promise<T> {\n    const endpoint: string | undefined = operationSpec.baseUrl || this._endpoint;\n    if (!endpoint) {\n      throw new Error(\n        \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\"\n      );\n    }\n\n    // Templatized URLs sometimes reference properties on the ServiceClient child class,\n    // so we have to pass `this` below in order to search these properties if they're\n    // not part of OperationArguments\n    const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n\n    const request: OperationRequest = createPipelineRequest({\n      url,\n    });\n    request.method = operationSpec.httpMethod;\n    const operationInfo = getOperationRequestInfo(request);\n    operationInfo.operationSpec = operationSpec;\n    operationInfo.operationArguments = operationArguments;\n\n    const contentType = operationSpec.contentType || this._requestContentType;\n    if (contentType && operationSpec.requestBody) {\n      request.headers.set(\"Content-Type\", contentType);\n    }\n\n    const options = operationArguments.options;\n    if (options) {\n      const requestOptions = options.requestOptions;\n\n      if (requestOptions) {\n        if (requestOptions.timeout) {\n          request.timeout = requestOptions.timeout;\n        }\n\n        if (requestOptions.onUploadProgress) {\n          request.onUploadProgress = requestOptions.onUploadProgress;\n        }\n\n        if (requestOptions.onDownloadProgress) {\n          request.onDownloadProgress = requestOptions.onDownloadProgress;\n        }\n\n        if (requestOptions.shouldDeserialize !== undefined) {\n          operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n        }\n\n        if (requestOptions.allowInsecureConnection) {\n          request.allowInsecureConnection = true;\n        }\n      }\n\n      if (options.abortSignal) {\n        request.abortSignal = options.abortSignal;\n      }\n\n      if (options.tracingOptions) {\n        request.tracingOptions = options.tracingOptions;\n      }\n    }\n\n    if (this._allowInsecureConnection) {\n      request.allowInsecureConnection = true;\n    }\n\n    if (request.streamResponseStatusCodes === undefined) {\n      request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n    }\n\n    try {\n      const rawResponse = await this.sendRequest(request);\n      const flatResponse = flattenResponse(\n        rawResponse,\n        operationSpec.responses[rawResponse.status]\n      ) as T;\n      if (options?.onResponse) {\n        options.onResponse(rawResponse, flatResponse);\n      }\n      return flatResponse;\n    } catch (error: any) {\n      if (typeof error === \"object\" && error?.response) {\n        const rawResponse = error.response;\n        const flatResponse = flattenResponse(\n          rawResponse,\n          operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]\n        );\n        error.details = flatResponse;\n        if (options?.onResponse) {\n          options.onResponse(rawResponse, flatResponse, error);\n        }\n      }\n      throw error;\n    }\n  }\n}\n\nfunction createDefaultPipeline(options: ServiceClientOptions): Pipeline {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions =\n    options.credential && credentialScopes\n      ? { credentialScopes, credential: options.credential }\n      : undefined;\n\n  return createClientPipeline({\n    ...options,\n    credentialOptions,\n  });\n}\n\nfunction getCredentialScopes(options: ServiceClientOptions): string | string[] | undefined {\n  if (options.credentialScopes) {\n    const scopes = options.credentialScopes;\n    return Array.isArray(scopes)\n      ? scopes.map((scope) => new URL(scope).toString())\n      : new URL(scopes).toString();\n  }\n\n  if (options.endpoint) {\n    return `${options.endpoint}/.default`;\n  }\n\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(\n      `When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`\n    );\n  }\n\n  return undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}