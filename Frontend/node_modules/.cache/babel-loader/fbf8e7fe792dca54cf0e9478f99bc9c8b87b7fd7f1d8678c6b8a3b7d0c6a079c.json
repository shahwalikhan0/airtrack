{"ast":null,"code":"'use strict';\n\nconst tds = require('tedious');\nconst debug = require('debug')('mssql:tedi');\nconst BaseRequest = require('../base/request');\nconst RequestError = require('../error/request-error');\nconst {\n  IDS,\n  objectHasProperty\n} = require('../utils');\nconst {\n  TYPES,\n  DECLARATIONS,\n  declare,\n  cast\n} = require('../datatypes');\nconst Table = require('../table');\nconst {\n  PARSERS: UDT\n} = require('../udt');\nconst {\n  valueHandler\n} = require('../shared');\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B';\nconst N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n};\nconst getTediousType = function (type) {\n  switch (type) {\n    case TYPES.VarChar:\n      return tds.TYPES.VarChar;\n    case TYPES.NVarChar:\n      return tds.TYPES.NVarChar;\n    case TYPES.Text:\n      return tds.TYPES.Text;\n    case TYPES.Int:\n      return tds.TYPES.Int;\n    case TYPES.BigInt:\n      return tds.TYPES.BigInt;\n    case TYPES.TinyInt:\n      return tds.TYPES.TinyInt;\n    case TYPES.SmallInt:\n      return tds.TYPES.SmallInt;\n    case TYPES.Bit:\n      return tds.TYPES.Bit;\n    case TYPES.Float:\n      return tds.TYPES.Float;\n    case TYPES.Decimal:\n      return tds.TYPES.Decimal;\n    case TYPES.Numeric:\n      return tds.TYPES.Numeric;\n    case TYPES.Real:\n      return tds.TYPES.Real;\n    case TYPES.Money:\n      return tds.TYPES.Money;\n    case TYPES.SmallMoney:\n      return tds.TYPES.SmallMoney;\n    case TYPES.Time:\n      return tds.TYPES.Time;\n    case TYPES.Date:\n      return tds.TYPES.Date;\n    case TYPES.DateTime:\n      return tds.TYPES.DateTime;\n    case TYPES.DateTime2:\n      return tds.TYPES.DateTime2;\n    case TYPES.DateTimeOffset:\n      return tds.TYPES.DateTimeOffset;\n    case TYPES.SmallDateTime:\n      return tds.TYPES.SmallDateTime;\n    case TYPES.UniqueIdentifier:\n      return tds.TYPES.UniqueIdentifier;\n    case TYPES.Xml:\n      return tds.TYPES.NVarChar;\n    case TYPES.Char:\n      return tds.TYPES.Char;\n    case TYPES.NChar:\n      return tds.TYPES.NChar;\n    case TYPES.NText:\n      return tds.TYPES.NVarChar;\n    case TYPES.Image:\n      return tds.TYPES.Image;\n    case TYPES.Binary:\n      return tds.TYPES.Binary;\n    case TYPES.VarBinary:\n      return tds.TYPES.VarBinary;\n    case TYPES.UDT:\n    case TYPES.Geography:\n    case TYPES.Geometry:\n      return tds.TYPES.UDT;\n    case TYPES.TVP:\n      return tds.TYPES.TVP;\n    case TYPES.Variant:\n      return tds.TYPES.Variant;\n    default:\n      return type;\n  }\n};\nconst getMssqlType = function (type, length) {\n  if (typeof type !== 'object') return undefined;\n  switch (type) {\n    case tds.TYPES.Char:\n      return TYPES.Char;\n    case tds.TYPES.NChar:\n      return TYPES.NChar;\n    case tds.TYPES.VarChar:\n      return TYPES.VarChar;\n    case tds.TYPES.NVarChar:\n      return TYPES.NVarChar;\n    case tds.TYPES.Text:\n      return TYPES.Text;\n    case tds.TYPES.NText:\n      return TYPES.NText;\n    case tds.TYPES.Int:\n      return TYPES.Int;\n    case tds.TYPES.BigInt:\n      return TYPES.BigInt;\n    case tds.TYPES.TinyInt:\n      return TYPES.TinyInt;\n    case tds.TYPES.SmallInt:\n      return TYPES.SmallInt;\n    case tds.TYPES.Bit:\n      return TYPES.Bit;\n    case tds.TYPES.Float:\n      return TYPES.Float;\n    case tds.TYPES.Real:\n      return TYPES.Real;\n    case tds.TYPES.Money:\n      return TYPES.Money;\n    case tds.TYPES.SmallMoney:\n      return TYPES.SmallMoney;\n    case tds.TYPES.Numeric:\n      return TYPES.Numeric;\n    case tds.TYPES.Decimal:\n      return TYPES.Decimal;\n    case tds.TYPES.DateTime:\n      return TYPES.DateTime;\n    case tds.TYPES.Time:\n      return TYPES.Time;\n    case tds.TYPES.Date:\n      return TYPES.Date;\n    case tds.TYPES.DateTime2:\n      return TYPES.DateTime2;\n    case tds.TYPES.DateTimeOffset:\n      return TYPES.DateTimeOffset;\n    case tds.TYPES.SmallDateTime:\n      return TYPES.SmallDateTime;\n    case tds.TYPES.UniqueIdentifier:\n      return TYPES.UniqueIdentifier;\n    case tds.TYPES.Image:\n      return TYPES.Image;\n    case tds.TYPES.Binary:\n      return TYPES.Binary;\n    case tds.TYPES.VarBinary:\n      return TYPES.VarBinary;\n    case tds.TYPES.Xml:\n      return TYPES.Xml;\n    case tds.TYPES.UDT:\n      return TYPES.UDT;\n    case tds.TYPES.TVP:\n      return TYPES.TVP;\n    case tds.TYPES.Variant:\n      return TYPES.Variant;\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN:\n          return TYPES.Bit;\n        case N_TYPES.NumericN:\n          return TYPES.Numeric;\n        case N_TYPES.DecimalN:\n          return TYPES.Decimal;\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt;\n          if (length === 4) return TYPES.Int;\n          if (length === 2) return TYPES.SmallInt;\n          return TYPES.TinyInt;\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float;\n          return TYPES.Real;\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money;\n          return TYPES.SmallMoney;\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime;\n          return TYPES.SmallDateTime;\n      }\n  }\n};\nconst createColumns = function (metadata, arrayRowMode) {\n  let out = {};\n  if (arrayRowMode) out = [];\n  for (let index = 0, length = metadata.length; index < length; index++) {\n    const column = metadata[index];\n    const outColumn = {\n      index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    };\n    if (column.udtInfo) {\n      outColumn.udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      };\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName];\n      }\n    }\n    if (arrayRowMode) {\n      out.push(outColumn);\n    } else {\n      out[column.colName] = outColumn;\n    }\n  }\n  return out;\n};\nconst valueCorrection = function (value, metadata) {\n  const type = getMssqlType(metadata.type);\n  if (valueHandler.has(type)) {\n    return valueHandler.get(type)(value);\n  } else if (metadata.type === tds.TYPES.UDT && value != null) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value);\n    } else {\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\nconst parameterCorrection = function (value) {\n  if (value instanceof Table) {\n    const tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    };\n    for (const col of value.columns) {\n      tvp.columns.push({\n        name: col.name,\n        type: getTediousType(col.type),\n        length: col.length,\n        scale: col.scale,\n        precision: col.precision\n      });\n    }\n    return tvp;\n  } else {\n    return value;\n  }\n};\nclass Request extends BaseRequest {\n  /*\n  Execute specified sql batch.\n  */\n\n  _batch(batch, callback) {\n    this._isBatch = true;\n    this._query(batch, callback);\n  }\n\n  /*\n  Bulk load.\n  */\n\n  _bulk(table, options, callback) {\n    var _this = this;\n    super._bulk(table, options, err => {\n      if (err) return callback(err);\n      try {\n        table._makeBulk();\n      } catch (e) {\n        return callback(new RequestError(e, 'EREQUEST'));\n      }\n      if (!table.name) {\n        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'));\n      }\n      if (table.name.charAt(0) === '@') {\n        return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'));\n      }\n      const errors = [];\n      const errorHandlers = {};\n      let hasReturned = false;\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n              this.parent.release(connection);\n            }\n            hasReturned = true;\n            callback(err);\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err);\n      };\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n      this.parent.acquire(this, (err, connection) => {\n        const callbackWithRelease = function (err) {\n          try {\n            _this.parent.release(connection);\n          } catch (e) {\n            // noop\n          }\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          callback(err, ...args);\n        };\n        if (err) return callbackWithRelease(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'));\n        }\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        };\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n        const done = (err, rowCount) => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          }\n          delete this._cancel;\n          let error;\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n            hasReturned = true;\n            if (this.stream) {\n              callbackWithRelease(null, rowCount);\n            } else {\n              callbackWithRelease(error, rowCount);\n            }\n          }\n        };\n        const bulk = connection.newBulkLoad(table.path, options, done);\n        for (const col of table.columns) {\n          bulk.addColumn(col.name, getTediousType(col.type), {\n            nullable: col.nullable,\n            length: col.length,\n            scale: col.scale,\n            precision: col.precision\n          });\n        }\n        if (table.create) {\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path;\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\n            if (err) return done(err);\n            connection.execBulkLoad(bulk, table.rows);\n          });\n          this._setCurrentRequest(req);\n          connection.execSqlBatch(req);\n        } else {\n          connection.execBulkLoad(bulk, table.rows);\n        }\n      });\n    });\n  }\n\n  /*\n  Execute specified sql command.\n  */\n\n  _query(command, callback) {\n    super._query(command, err => {\n      if (err) return callback(err);\n      const recordsets = [];\n      const recordsetcolumns = [];\n      const errors = [];\n      const errorHandlers = {};\n      const output = {};\n      const rowsAffected = [];\n      let columns = {};\n      let recordset = [];\n      let batchLastRow = null;\n      let batchHasOutput = false;\n      let isChunkedRecordset = false;\n      let chunksBuffer = null;\n      let hasReturned = false;\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n              this.parent.release(connection);\n            }\n            hasReturned = true;\n            callback(err);\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err);\n      };\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        let row;\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new RequestError('Canceled.', 'ECANCEL'));\n        }\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        };\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n        debug('request(%d): query', IDS.get(this), command);\n        const req = new tds.Request(command, err => {\n          // tedious v15 has started using AggregateErrors to wrap multiple errors into single error objects\n          (err?.errors ? err.errors : [err]).forEach((e, i, _ref) => {\n            let {\n              length\n            } = _ref;\n            // to make sure we handle no-sql errors as well\n            if (e && (!errors.length || errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message)) {\n              e = new RequestError(e, 'EREQUEST');\n              if (this.stream) this.emit('error', e);\n              errors.push(e);\n            }\n          });\n\n          // process batch outputs\n          if (batchHasOutput) {\n            if (!this.stream) batchLastRow = recordsets.pop()[0];\n            for (const name in batchLastRow) {\n              const value = batchLastRow[name];\n              if (name !== '___return___') {\n                output[name] = value;\n              }\n            }\n          }\n          delete this._cancel;\n          let error;\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n            this.parent.release(connection);\n            hasReturned = true;\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error);\n            } else {\n              debug('request(%d): completed', IDS.get(this));\n            }\n            if (this.stream) {\n              callback(null, null, output, rowsAffected, recordsetcolumns);\n            } else {\n              callback(error, recordsets, output, rowsAffected, recordsetcolumns);\n            }\n          }\n        });\n        this._setCurrentRequest(req);\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode);\n          isChunkedRecordset = false;\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true;\n            chunksBuffer = [];\n          }\n          if (this.stream) {\n            if (this._isBatch) {\n              // don't stream recordset with output values in batches\n              if (!columns.___return___) {\n                this.emit('recordset', columns);\n              }\n            } else {\n              this.emit('recordset', columns);\n            }\n          }\n          if (this.arrayRowMode) recordsetcolumns.push(columns);\n        });\n        const doneHandler = (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount);\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount);\n            }\n          }\n          // this function is called even when select only set variables so we should skip adding a new recordset\n          if (Object.keys(columns).length === 0) return;\n          if (isChunkedRecordset) {\n            const concatenatedChunks = chunksBuffer.join('');\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (concatenatedChunks === '') {\n                  row = null;\n                } else {\n                  row = JSON.parse(concatenatedChunks);\n                }\n              } catch (ex) {\n                row = null;\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON');\n                if (this.stream) this.emit('error', ex2);\n\n                // we must collect errors even in stream mode\n                errors.push(ex2);\n              }\n            } else {\n              row = {};\n              row[Object.keys(columns)[0]] = concatenatedChunks;\n            }\n            chunksBuffer = null;\n            if (this.stream) {\n              this.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          }\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            });\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value(name) {\n                return Table.fromRecordset(this, name);\n              }\n            });\n            recordsets.push(recordset);\n          }\n          recordset = [];\n          columns = {};\n        };\n        req.on('doneInProc', doneHandler); // doneInProc handlers are used in both queries and batches\n        req.on('done', doneHandler); // done handlers are used in batches\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value;\n        });\n        req.on('row', columns => {\n          if (!recordset) recordset = [];\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value);\n          }\n          if (this.arrayRowMode) {\n            row = [];\n          } else {\n            row = {};\n          }\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata);\n            if (this.arrayRowMode) {\n              row.push(col.value);\n            } else {\n              const exi = row[col.metadata.colName];\n              if (exi !== undefined) {\n                if (exi instanceof Array) {\n                  exi.push(col.value);\n                } else {\n                  row[col.metadata.colName] = [exi, col.value];\n                }\n              } else {\n                row[col.metadata.colName] = col.value;\n              }\n            }\n          }\n          if (this.stream) {\n            if (this._isBatch) {\n              // dont stream recordset with output values in batches\n              if (row.___return___) {\n                batchLastRow = row;\n              } else {\n                this.emit('row', row);\n              }\n            } else {\n              this.emit('row', row);\n            }\n          } else {\n            recordset.push(row);\n          }\n        });\n        if (this._isBatch) {\n          if (Object.keys(this.parameters).length) {\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n              const param = this.parameters[name];\n              try {\n                param.value = getTediousType(param.type).validate(param.value, this.parent.collation);\n              } catch (e) {\n                e.message = `Validation failed for parameter '${name}'. ${e.message}`;\n                const err = new RequestError(e, 'EPARAM');\n                this.parent.release(connection);\n                return callback(err);\n              }\n            }\n            const declarations = [];\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n              const param = this.parameters[name];\n              declarations.push(`@${name} ${declare(param.type, param)}`);\n            }\n            const assigns = [];\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n              const param = this.parameters[name];\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`);\n            }\n            const selects = [];\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n              const param = this.parameters[name];\n              if (param.io === 2) {\n                selects.push(`@${name} as [${name}]`);\n              }\n            }\n            batchHasOutput = selects.length > 0;\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? `select 1 as [___return___], ${selects.join(', ')}` : ''}`;\n          }\n        } else {\n          for (const name in this.parameters) {\n            if (!objectHasProperty(this.parameters, name)) {\n              continue;\n            }\n            const param = this.parameters[name];\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            }\n          }\n        }\n        try {\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req);\n        } catch (error) {\n          handleError(true, connection, error);\n        }\n      });\n    });\n  }\n\n  /*\n  Execute stored procedure with specified parameters.\n  */\n\n  _execute(procedure, callback) {\n    super._execute(procedure, err => {\n      if (err) return callback(err);\n      const recordsets = [];\n      const recordsetcolumns = [];\n      const errors = [];\n      const errorHandlers = {};\n      const output = {};\n      const rowsAffected = [];\n      let columns = {};\n      let recordset = [];\n      let returnValue = 0;\n      let isChunkedRecordset = false;\n      let chunksBuffer = null;\n      let hasReturned = false;\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n              this.parent.release(connection);\n            }\n            hasReturned = true;\n            callback(err);\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err);\n      };\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        let row;\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new RequestError('Canceled.', 'ECANCEL'));\n        }\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        };\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n        if (debug.enabled) {\n          // log stored procedure executions and provided parameters\n          const params = Object.keys(this.parameters).map(k => this.parameters[k]);\n          // cut long string parameters short to keep log somewhat clean\n          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s;\n          // format parameter names as 'my_parameter [sql.Int]'\n          const logName = param => param.name + ' [sql.' + param.type.name + ']';\n          const logParams = {};\n          params.forEach(p => {\n            logParams[logName(p)] = logValue(p.value);\n          });\n          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams);\n        }\n        const req = new tds.Request(procedure, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          }\n          delete this._cancel;\n          let error;\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n            this.parent.release(connection);\n            hasReturned = true;\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error);\n            } else {\n              debug('request(%d): complete', IDS.get(this));\n            }\n            if (this.stream) {\n              callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);\n            } else {\n              callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);\n            }\n          }\n        });\n        this._setCurrentRequest(req);\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode);\n          isChunkedRecordset = false;\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true;\n            chunksBuffer = [];\n          }\n          if (this.stream) this.emit('recordset', columns);\n          if (this.arrayRowMode) recordsetcolumns.push(columns);\n        });\n        req.on('row', columns => {\n          if (!recordset) recordset = [];\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value);\n          }\n          if (this.arrayRowMode) {\n            row = [];\n          } else {\n            row = {};\n          }\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata);\n            if (this.arrayRowMode) {\n              row.push(col.value);\n            } else {\n              const exi = row[col.metadata.colName];\n              if (exi != null) {\n                if (exi instanceof Array) {\n                  exi.push(col.value);\n                } else {\n                  row[col.metadata.colName] = [exi, col.value];\n                }\n              } else {\n                row[col.metadata.colName] = col.value;\n              }\n            }\n          }\n          if (this.stream) {\n            this.emit('row', row);\n          } else {\n            recordset.push(row);\n          }\n        });\n        req.on('doneInProc', (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount);\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount);\n            }\n          }\n\n          // filter empty recordsets when NOCOUNT is OFF\n          if (Object.keys(columns).length === 0) return;\n          if (isChunkedRecordset) {\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (chunksBuffer.length === 0) {\n                  row = null;\n                } else {\n                  row = JSON.parse(chunksBuffer.join(''));\n                }\n              } catch (ex) {\n                row = null;\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON');\n                if (this.stream) this.emit('error', ex2);\n\n                // we must collect errors even in stream mode\n                errors.push(ex2);\n              }\n            } else {\n              row = {};\n              row[Object.keys(columns)[0]] = chunksBuffer.join('');\n            }\n            chunksBuffer = null;\n            if (this.stream) {\n              this.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          }\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            });\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value(name) {\n                return Table.fromRecordset(this, name);\n              }\n            });\n            recordsets.push(recordset);\n          }\n          recordset = [];\n          columns = {};\n        });\n        req.on('doneProc', (rowCount, more, returnStatus) => {\n          returnValue = returnStatus;\n        });\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value;\n        });\n        for (const name in this.parameters) {\n          if (!objectHasProperty(this.parameters, name)) {\n            continue;\n          }\n          const param = this.parameters[name];\n          if (param.io === 1) {\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n              length: param.length,\n              scale: param.scale,\n              precision: param.precision\n            });\n          } else {\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n              length: param.length,\n              scale: param.scale,\n              precision: param.precision\n            });\n          }\n        }\n        connection.callProcedure(req);\n      });\n    });\n  }\n  _pause() {\n    super._pause();\n    if (this._currentRequest) {\n      this._currentRequest.pause();\n    }\n  }\n  _resume() {\n    super._resume();\n    if (this._currentRequest) {\n      this._currentRequest.resume();\n    }\n  }\n}\nmodule.exports = Request;","map":{"version":3,"names":["tds","require","debug","BaseRequest","RequestError","IDS","objectHasProperty","TYPES","DECLARATIONS","declare","cast","Table","PARSERS","UDT","valueHandler","JSON_COLUMN_ID","XML_COLUMN_ID","N_TYPES","BitN","DateTimeN","DecimalN","FloatN","IntN","MoneyN","NumericN","getTediousType","type","VarChar","NVarChar","Text","Int","BigInt","TinyInt","SmallInt","Bit","Float","Decimal","Numeric","Real","Money","SmallMoney","Time","Date","DateTime","DateTime2","DateTimeOffset","SmallDateTime","UniqueIdentifier","Xml","Char","NChar","NText","Image","Binary","VarBinary","Geography","Geometry","TVP","Variant","getMssqlType","length","undefined","id","createColumns","metadata","arrayRowMode","out","index","column","outColumn","name","colName","dataLength","scale","precision","nullable","flags","caseSensitive","identity","readOnly","udtInfo","udt","typeName","database","dbname","schema","owningSchema","assembly","assemblyName","push","valueCorrection","value","has","get","parameterCorrection","tvp","columns","rows","col","Request","_batch","batch","callback","_isBatch","_query","_bulk","table","options","_this","err","_makeBulk","e","charAt","errors","errorHandlers","hasReturned","handleError","doReturn","connection","info","Error","message","stream","emit","event","removeListener","parent","release","handleInfo","msg","number","state","class","lineNumber","serverName","procName","acquire","callbackWithRelease","_len","arguments","args","Array","_key","canceled","_cancel","cancel","on","infoMessage","errorMessage","bind","error","done","rowCount","pop","precedingErrors","bulk","newBulkLoad","path","addColumn","create","objectid","temporary","req","replace","execBulkLoad","_setCurrentRequest","execSqlBatch","command","recordsets","recordsetcolumns","output","rowsAffected","recordset","batchLastRow","batchHasOutput","isChunkedRecordset","chunksBuffer","config","row","forEach","i","_ref","___return___","doneHandler","more","Object","keys","concatenatedChunks","join","parseJSON","JSON","parse","ex","ex2","defineProperty","enumerable","configurable","fromRecordset","parameterName","exi","parameters","param","validate","collation","declarations","assigns","selects","io","sqlTextOrProcedure","addParameter","addOutputParameter","_execute","procedure","returnValue","enabled","params","map","k","logValue","s","substring","logName","logParams","p","returnStatus","callProcedure","_pause","_currentRequest","pause","_resume","resume","module","exports"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/mssql/lib/tedious/request.js"],"sourcesContent":["'use strict'\n\nconst tds = require('tedious')\nconst debug = require('debug')('mssql:tedi')\nconst BaseRequest = require('../base/request')\nconst RequestError = require('../error/request-error')\nconst { IDS, objectHasProperty } = require('../utils')\nconst { TYPES, DECLARATIONS, declare, cast } = require('../datatypes')\nconst Table = require('../table')\nconst { PARSERS: UDT } = require('../udt')\nconst { valueHandler } = require('../shared')\n\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B'\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B'\n\nconst N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n}\n\nconst getTediousType = function (type) {\n  switch (type) {\n    case TYPES.VarChar: return tds.TYPES.VarChar\n    case TYPES.NVarChar: return tds.TYPES.NVarChar\n    case TYPES.Text: return tds.TYPES.Text\n    case TYPES.Int: return tds.TYPES.Int\n    case TYPES.BigInt: return tds.TYPES.BigInt\n    case TYPES.TinyInt: return tds.TYPES.TinyInt\n    case TYPES.SmallInt: return tds.TYPES.SmallInt\n    case TYPES.Bit: return tds.TYPES.Bit\n    case TYPES.Float: return tds.TYPES.Float\n    case TYPES.Decimal: return tds.TYPES.Decimal\n    case TYPES.Numeric: return tds.TYPES.Numeric\n    case TYPES.Real: return tds.TYPES.Real\n    case TYPES.Money: return tds.TYPES.Money\n    case TYPES.SmallMoney: return tds.TYPES.SmallMoney\n    case TYPES.Time: return tds.TYPES.Time\n    case TYPES.Date: return tds.TYPES.Date\n    case TYPES.DateTime: return tds.TYPES.DateTime\n    case TYPES.DateTime2: return tds.TYPES.DateTime2\n    case TYPES.DateTimeOffset: return tds.TYPES.DateTimeOffset\n    case TYPES.SmallDateTime: return tds.TYPES.SmallDateTime\n    case TYPES.UniqueIdentifier: return tds.TYPES.UniqueIdentifier\n    case TYPES.Xml: return tds.TYPES.NVarChar\n    case TYPES.Char: return tds.TYPES.Char\n    case TYPES.NChar: return tds.TYPES.NChar\n    case TYPES.NText: return tds.TYPES.NVarChar\n    case TYPES.Image: return tds.TYPES.Image\n    case TYPES.Binary: return tds.TYPES.Binary\n    case TYPES.VarBinary: return tds.TYPES.VarBinary\n    case TYPES.UDT: case TYPES.Geography: case TYPES.Geometry: return tds.TYPES.UDT\n    case TYPES.TVP: return tds.TYPES.TVP\n    case TYPES.Variant: return tds.TYPES.Variant\n    default: return type\n  }\n}\n\nconst getMssqlType = function (type, length) {\n  if (typeof type !== 'object') return undefined\n\n  switch (type) {\n    case tds.TYPES.Char: return TYPES.Char\n    case tds.TYPES.NChar: return TYPES.NChar\n    case tds.TYPES.VarChar: return TYPES.VarChar\n    case tds.TYPES.NVarChar: return TYPES.NVarChar\n    case tds.TYPES.Text: return TYPES.Text\n    case tds.TYPES.NText: return TYPES.NText\n    case tds.TYPES.Int: return TYPES.Int\n    case tds.TYPES.BigInt: return TYPES.BigInt\n    case tds.TYPES.TinyInt: return TYPES.TinyInt\n    case tds.TYPES.SmallInt: return TYPES.SmallInt\n    case tds.TYPES.Bit: return TYPES.Bit\n    case tds.TYPES.Float: return TYPES.Float\n    case tds.TYPES.Real: return TYPES.Real\n    case tds.TYPES.Money: return TYPES.Money\n    case tds.TYPES.SmallMoney: return TYPES.SmallMoney\n    case tds.TYPES.Numeric: return TYPES.Numeric\n    case tds.TYPES.Decimal: return TYPES.Decimal\n    case tds.TYPES.DateTime: return TYPES.DateTime\n    case tds.TYPES.Time: return TYPES.Time\n    case tds.TYPES.Date: return TYPES.Date\n    case tds.TYPES.DateTime2: return TYPES.DateTime2\n    case tds.TYPES.DateTimeOffset: return TYPES.DateTimeOffset\n    case tds.TYPES.SmallDateTime: return TYPES.SmallDateTime\n    case tds.TYPES.UniqueIdentifier: return TYPES.UniqueIdentifier\n    case tds.TYPES.Image: return TYPES.Image\n    case tds.TYPES.Binary: return TYPES.Binary\n    case tds.TYPES.VarBinary: return TYPES.VarBinary\n    case tds.TYPES.Xml: return TYPES.Xml\n    case tds.TYPES.UDT: return TYPES.UDT\n    case tds.TYPES.TVP: return TYPES.TVP\n    case tds.TYPES.Variant: return TYPES.Variant\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN: return TYPES.Bit\n        case N_TYPES.NumericN: return TYPES.Numeric\n        case N_TYPES.DecimalN: return TYPES.Decimal\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt\n          if (length === 4) return TYPES.Int\n          if (length === 2) return TYPES.SmallInt\n          return TYPES.TinyInt\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float\n          return TYPES.Real\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money\n          return TYPES.SmallMoney\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime\n          return TYPES.SmallDateTime\n      }\n  }\n}\n\nconst createColumns = function (metadata, arrayRowMode) {\n  let out = {}\n  if (arrayRowMode) out = []\n  for (let index = 0, length = metadata.length; index < length; index++) {\n    const column = metadata[index]\n    const outColumn = {\n      index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    }\n\n    if (column.udtInfo) {\n      outColumn.udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      }\n\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName]\n      }\n    }\n\n    if (arrayRowMode) {\n      out.push(outColumn)\n    } else {\n      out[column.colName] = outColumn\n    }\n  }\n\n  return out\n}\n\nconst valueCorrection = function (value, metadata) {\n  const type = getMssqlType(metadata.type)\n  if (valueHandler.has(type)) {\n    return valueHandler.get(type)(value)\n  } else if ((metadata.type === tds.TYPES.UDT) && (value != null)) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value)\n    } else {\n      return value\n    }\n  } else {\n    return value\n  }\n}\n\nconst parameterCorrection = function (value) {\n  if (value instanceof Table) {\n    const tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    }\n\n    for (const col of value.columns) {\n      tvp.columns.push({\n        name: col.name,\n        type: getTediousType(col.type),\n        length: col.length,\n        scale: col.scale,\n        precision: col.precision\n      })\n    }\n\n    return tvp\n  } else {\n    return value\n  }\n}\n\nclass Request extends BaseRequest {\n  /*\n  Execute specified sql batch.\n  */\n\n  _batch (batch, callback) {\n    this._isBatch = true\n    this._query(batch, callback)\n  }\n\n  /*\n  Bulk load.\n  */\n\n  _bulk (table, options, callback) {\n    super._bulk(table, options, err => {\n      if (err) return callback(err)\n\n      try {\n        table._makeBulk()\n      } catch (e) {\n        return callback(new RequestError(e, 'EREQUEST'))\n      }\n\n      if (!table.name) {\n        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'))\n      }\n\n      if (table.name.charAt(0) === '@') {\n        return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'))\n      }\n\n      const errors = []\n      const errorHandlers = {}\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection) => {\n        const callbackWithRelease = (err, ...args) => {\n          try {\n            this.parent.release(connection)\n          } catch (e) {\n            // noop\n          }\n          callback(err, ...args)\n        }\n        if (err) return callbackWithRelease(err)\n\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this))\n          return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this))\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        const done = (err, rowCount) => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\n            err = new RequestError(err, 'EREQUEST')\n            if (this.stream) this.emit('error', err)\n            errors.push(err)\n          }\n\n          delete this._cancel\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            hasReturned = true\n\n            if (this.stream) {\n              callbackWithRelease(null, rowCount)\n            } else {\n              callbackWithRelease(error, rowCount)\n            }\n          }\n        }\n\n        const bulk = connection.newBulkLoad(table.path, options, done)\n\n        for (const col of table.columns) {\n          bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision })\n        }\n\n        if (table.create) {\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\n            if (err) return done(err)\n\n            connection.execBulkLoad(bulk, table.rows)\n          })\n          this._setCurrentRequest(req)\n\n          connection.execSqlBatch(req)\n        } else {\n          connection.execBulkLoad(bulk, table.rows)\n        }\n      })\n    })\n  }\n\n  /*\n  Execute specified sql command.\n  */\n\n  _query (command, callback) {\n    super._query(command, err => {\n      if (err) return callback(err)\n\n      const recordsets = []\n      const recordsetcolumns = []\n      const errors = []\n      const errorHandlers = {}\n      const output = {}\n      const rowsAffected = []\n\n      let columns = {}\n      let recordset = []\n      let batchLastRow = null\n      let batchHasOutput = false\n      let isChunkedRecordset = false\n      let chunksBuffer = null\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err)\n\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\n\n        let row\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this))\n          this.parent.release(connection)\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this))\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        debug('request(%d): query', IDS.get(this), command)\n\n        const req = new tds.Request(command, err => {\n          // tedious v15 has started using AggregateErrors to wrap multiple errors into single error objects\n          (err?.errors ? err.errors : [err]).forEach((e, i, { length }) => {\n            // to make sure we handle no-sql errors as well\n            if (e && (!errors.length || (errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message))) {\n              e = new RequestError(e, 'EREQUEST')\n              if (this.stream) this.emit('error', e)\n              errors.push(e)\n            }\n          })\n\n          // process batch outputs\n          if (batchHasOutput) {\n            if (!this.stream) batchLastRow = recordsets.pop()[0]\n\n            for (const name in batchLastRow) {\n              const value = batchLastRow[name]\n              if (name !== '___return___') {\n                output[name] = value\n              }\n            }\n          }\n\n          delete this._cancel\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            this.parent.release(connection)\n            hasReturned = true\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error)\n            } else {\n              debug('request(%d): completed', IDS.get(this))\n            }\n\n            if (this.stream) {\n              callback(null, null, output, rowsAffected, recordsetcolumns)\n            } else {\n              callback(error, recordsets, output, rowsAffected, recordsetcolumns)\n            }\n          }\n        })\n\n        this._setCurrentRequest(req)\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode)\n\n          isChunkedRecordset = false\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true\n            chunksBuffer = []\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // don't stream recordset with output values in batches\n              if (!columns.___return___) {\n                this.emit('recordset', columns)\n              }\n            } else {\n              this.emit('recordset', columns)\n            }\n          }\n          if (this.arrayRowMode) recordsetcolumns.push(columns)\n        })\n\n        const doneHandler = (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount)\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount)\n            }\n          }\n          // this function is called even when select only set variables so we should skip adding a new recordset\n          if (Object.keys(columns).length === 0) return\n\n          if (isChunkedRecordset) {\n            const concatenatedChunks = chunksBuffer.join('')\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (concatenatedChunks === '') {\n                  row = null\n                } else {\n                  row = JSON.parse(concatenatedChunks)\n                }\n              } catch (ex) {\n                row = null\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\n\n                if (this.stream) this.emit('error', ex2)\n\n                // we must collect errors even in stream mode\n                errors.push(ex2)\n              }\n            } else {\n              row = {}\n              row[Object.keys(columns)[0]] = concatenatedChunks\n            }\n\n            chunksBuffer = null\n\n            if (this.stream) {\n              this.emit('row', row)\n            } else {\n              recordset.push(row)\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            })\n\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value (name) { return Table.fromRecordset(this, name) }\n            })\n\n            recordsets.push(recordset)\n          }\n\n          recordset = []\n          columns = {}\n        }\n\n        req.on('doneInProc', doneHandler) // doneInProc handlers are used in both queries and batches\n        req.on('done', doneHandler) // done handlers are used in batches\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value\n        })\n\n        req.on('row', columns => {\n          if (!recordset) recordset = []\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value)\n          }\n\n          if (this.arrayRowMode) {\n            row = []\n          } else {\n            row = {}\n          }\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata)\n\n            if (this.arrayRowMode) {\n              row.push(col.value)\n            } else {\n              const exi = row[col.metadata.colName]\n              if (exi !== undefined) {\n                if (exi instanceof Array) {\n                  exi.push(col.value)\n                } else {\n                  row[col.metadata.colName] = [exi, col.value]\n                }\n              } else {\n                row[col.metadata.colName] = col.value\n              }\n            }\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // dont stream recordset with output values in batches\n              if (row.___return___) {\n                batchLastRow = row\n              } else {\n                this.emit('row', row)\n              }\n            } else {\n              this.emit('row', row)\n            }\n          } else {\n            recordset.push(row)\n          }\n        })\n\n        if (this._isBatch) {\n          if (Object.keys(this.parameters).length) {\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n\n              try {\n                param.value = getTediousType(param.type).validate(param.value, this.parent.collation)\n              } catch (e) {\n                e.message = `Validation failed for parameter '${name}'. ${e.message}`\n                const err = new RequestError(e, 'EPARAM')\n\n                this.parent.release(connection)\n                return callback(err)\n              }\n            }\n\n            const declarations = []\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n              declarations.push(`@${name} ${declare(param.type, param)}`)\n            }\n\n            const assigns = []\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`)\n            }\n\n            const selects = []\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n              if (param.io === 2) {\n                selects.push(`@${name} as [${name}]`)\n              }\n            }\n\n            batchHasOutput = selects.length > 0\n\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? (`select 1 as [___return___], ${selects.join(', ')}`) : ''}`\n          }\n        } else {\n          for (const name in this.parameters) {\n            if (!objectHasProperty(this.parameters, name)) {\n              continue\n            }\n            const param = this.parameters[name]\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n            }\n          }\n        }\n\n        try {\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req)\n        } catch (error) {\n          handleError(true, connection, error)\n        }\n      })\n    })\n  }\n\n  /*\n  Execute stored procedure with specified parameters.\n  */\n\n  _execute (procedure, callback) {\n    super._execute(procedure, err => {\n      if (err) return callback(err)\n\n      const recordsets = []\n      const recordsetcolumns = []\n      const errors = []\n      const errorHandlers = {}\n      const output = {}\n      const rowsAffected = []\n\n      let columns = {}\n      let recordset = []\n      let returnValue = 0\n      let isChunkedRecordset = false\n      let chunksBuffer = null\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err)\n\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\n\n        let row\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this))\n          this.parent.release(connection)\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this))\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        if (debug.enabled) {\n          // log stored procedure executions and provided parameters\n          const params = Object.keys(this.parameters).map(k => this.parameters[k])\n          // cut long string parameters short to keep log somewhat clean\n          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s\n          // format parameter names as 'my_parameter [sql.Int]'\n          const logName = param => param.name + ' [sql.' + param.type.name + ']'\n          const logParams = {}\n          params.forEach(p => { logParams[logName(p)] = logValue(p.value) })\n          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams)\n        }\n\n        const req = new tds.Request(procedure, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\n            err = new RequestError(err, 'EREQUEST')\n            if (this.stream) this.emit('error', err)\n            errors.push(err)\n          }\n\n          delete this._cancel\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            this.parent.release(connection)\n            hasReturned = true\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error)\n            } else {\n              debug('request(%d): complete', IDS.get(this))\n            }\n\n            if (this.stream) {\n              callback(null, null, output, returnValue, rowsAffected, recordsetcolumns)\n            } else {\n              callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns)\n            }\n          }\n        })\n\n        this._setCurrentRequest(req)\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode)\n\n          isChunkedRecordset = false\n          if ((metadata.length === 1) && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true\n            chunksBuffer = []\n          }\n\n          if (this.stream) this.emit('recordset', columns)\n          if (this.arrayRowMode) recordsetcolumns.push(columns)\n        })\n\n        req.on('row', columns => {\n          if (!recordset) recordset = []\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value)\n          }\n\n          if (this.arrayRowMode) {\n            row = []\n          } else {\n            row = {}\n          }\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata)\n\n            if (this.arrayRowMode) {\n              row.push(col.value)\n            } else {\n              const exi = row[col.metadata.colName]\n              if (exi != null) {\n                if (exi instanceof Array) {\n                  exi.push(col.value)\n                } else {\n                  row[col.metadata.colName] = [exi, col.value]\n                }\n              } else {\n                row[col.metadata.colName] = col.value\n              }\n            }\n          }\n\n          if (this.stream) {\n            this.emit('row', row)\n          } else {\n            recordset.push(row)\n          }\n        })\n\n        req.on('doneInProc', (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount)\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount)\n            }\n          }\n\n          // filter empty recordsets when NOCOUNT is OFF\n          if (Object.keys(columns).length === 0) return\n\n          if (isChunkedRecordset) {\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (chunksBuffer.length === 0) {\n                  row = null\n                } else {\n                  row = JSON.parse(chunksBuffer.join(''))\n                }\n              } catch (ex) {\n                row = null\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\n\n                if (this.stream) this.emit('error', ex2)\n\n                // we must collect errors even in stream mode\n                errors.push(ex2)\n              }\n            } else {\n              row = {}\n              row[Object.keys(columns)[0]] = chunksBuffer.join('')\n            }\n\n            chunksBuffer = null\n\n            if (this.stream) {\n              this.emit('row', row)\n            } else {\n              recordset.push(row)\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            })\n\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value (name) { return Table.fromRecordset(this, name) }\n            })\n\n            recordsets.push(recordset)\n          }\n\n          recordset = []\n          columns = {}\n        })\n\n        req.on('doneProc', (rowCount, more, returnStatus) => {\n          returnValue = returnStatus\n        })\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value\n        })\n\n        for (const name in this.parameters) {\n          if (!objectHasProperty(this.parameters, name)) {\n            continue\n          }\n          const param = this.parameters[name]\n          if (param.io === 1) {\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n          } else {\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n          }\n        }\n\n        connection.callProcedure(req)\n      })\n    })\n  }\n\n  _pause () {\n    super._pause()\n    if (this._currentRequest) {\n      this._currentRequest.pause()\n    }\n  }\n\n  _resume () {\n    super._resume()\n    if (this._currentRequest) {\n      this._currentRequest.resume()\n    }\n  }\n}\n\nmodule.exports = Request\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC9B,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC,CAAC,YAAY,CAAC;AAC5C,MAAME,WAAW,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAC9C,MAAMG,YAAY,GAAGH,OAAO,CAAC,wBAAwB,CAAC;AACtD,MAAM;EAAEI,GAAG;EAAEC;AAAkB,CAAC,GAAGL,OAAO,CAAC,UAAU,CAAC;AACtD,MAAM;EAAEM,KAAK;EAAEC,YAAY;EAAEC,OAAO;EAAEC;AAAK,CAAC,GAAGT,OAAO,CAAC,cAAc,CAAC;AACtE,MAAMU,KAAK,GAAGV,OAAO,CAAC,UAAU,CAAC;AACjC,MAAM;EAAEW,OAAO,EAAEC;AAAI,CAAC,GAAGZ,OAAO,CAAC,QAAQ,CAAC;AAC1C,MAAM;EAAEa;AAAa,CAAC,GAAGb,OAAO,CAAC,WAAW,CAAC;AAE7C,MAAMc,cAAc,GAAG,2CAA2C;AAClE,MAAMC,aAAa,GAAG,0CAA0C;AAEhE,MAAMC,OAAO,GAAG;EACdC,IAAI,EAAE,IAAI;EACVC,SAAS,EAAE,IAAI;EACfC,QAAQ,EAAE,IAAI;EACdC,MAAM,EAAE,IAAI;EACZC,IAAI,EAAE,IAAI;EACVC,MAAM,EAAE,IAAI;EACZC,QAAQ,EAAE;AACZ,CAAC;AAED,MAAMC,cAAc,GAAG,SAAAA,CAAUC,IAAI,EAAE;EACrC,QAAQA,IAAI;IACV,KAAKnB,KAAK,CAACoB,OAAO;MAAE,OAAO3B,GAAG,CAACO,KAAK,CAACoB,OAAO;IAC5C,KAAKpB,KAAK,CAACqB,QAAQ;MAAE,OAAO5B,GAAG,CAACO,KAAK,CAACqB,QAAQ;IAC9C,KAAKrB,KAAK,CAACsB,IAAI;MAAE,OAAO7B,GAAG,CAACO,KAAK,CAACsB,IAAI;IACtC,KAAKtB,KAAK,CAACuB,GAAG;MAAE,OAAO9B,GAAG,CAACO,KAAK,CAACuB,GAAG;IACpC,KAAKvB,KAAK,CAACwB,MAAM;MAAE,OAAO/B,GAAG,CAACO,KAAK,CAACwB,MAAM;IAC1C,KAAKxB,KAAK,CAACyB,OAAO;MAAE,OAAOhC,GAAG,CAACO,KAAK,CAACyB,OAAO;IAC5C,KAAKzB,KAAK,CAAC0B,QAAQ;MAAE,OAAOjC,GAAG,CAACO,KAAK,CAAC0B,QAAQ;IAC9C,KAAK1B,KAAK,CAAC2B,GAAG;MAAE,OAAOlC,GAAG,CAACO,KAAK,CAAC2B,GAAG;IACpC,KAAK3B,KAAK,CAAC4B,KAAK;MAAE,OAAOnC,GAAG,CAACO,KAAK,CAAC4B,KAAK;IACxC,KAAK5B,KAAK,CAAC6B,OAAO;MAAE,OAAOpC,GAAG,CAACO,KAAK,CAAC6B,OAAO;IAC5C,KAAK7B,KAAK,CAAC8B,OAAO;MAAE,OAAOrC,GAAG,CAACO,KAAK,CAAC8B,OAAO;IAC5C,KAAK9B,KAAK,CAAC+B,IAAI;MAAE,OAAOtC,GAAG,CAACO,KAAK,CAAC+B,IAAI;IACtC,KAAK/B,KAAK,CAACgC,KAAK;MAAE,OAAOvC,GAAG,CAACO,KAAK,CAACgC,KAAK;IACxC,KAAKhC,KAAK,CAACiC,UAAU;MAAE,OAAOxC,GAAG,CAACO,KAAK,CAACiC,UAAU;IAClD,KAAKjC,KAAK,CAACkC,IAAI;MAAE,OAAOzC,GAAG,CAACO,KAAK,CAACkC,IAAI;IACtC,KAAKlC,KAAK,CAACmC,IAAI;MAAE,OAAO1C,GAAG,CAACO,KAAK,CAACmC,IAAI;IACtC,KAAKnC,KAAK,CAACoC,QAAQ;MAAE,OAAO3C,GAAG,CAACO,KAAK,CAACoC,QAAQ;IAC9C,KAAKpC,KAAK,CAACqC,SAAS;MAAE,OAAO5C,GAAG,CAACO,KAAK,CAACqC,SAAS;IAChD,KAAKrC,KAAK,CAACsC,cAAc;MAAE,OAAO7C,GAAG,CAACO,KAAK,CAACsC,cAAc;IAC1D,KAAKtC,KAAK,CAACuC,aAAa;MAAE,OAAO9C,GAAG,CAACO,KAAK,CAACuC,aAAa;IACxD,KAAKvC,KAAK,CAACwC,gBAAgB;MAAE,OAAO/C,GAAG,CAACO,KAAK,CAACwC,gBAAgB;IAC9D,KAAKxC,KAAK,CAACyC,GAAG;MAAE,OAAOhD,GAAG,CAACO,KAAK,CAACqB,QAAQ;IACzC,KAAKrB,KAAK,CAAC0C,IAAI;MAAE,OAAOjD,GAAG,CAACO,KAAK,CAAC0C,IAAI;IACtC,KAAK1C,KAAK,CAAC2C,KAAK;MAAE,OAAOlD,GAAG,CAACO,KAAK,CAAC2C,KAAK;IACxC,KAAK3C,KAAK,CAAC4C,KAAK;MAAE,OAAOnD,GAAG,CAACO,KAAK,CAACqB,QAAQ;IAC3C,KAAKrB,KAAK,CAAC6C,KAAK;MAAE,OAAOpD,GAAG,CAACO,KAAK,CAAC6C,KAAK;IACxC,KAAK7C,KAAK,CAAC8C,MAAM;MAAE,OAAOrD,GAAG,CAACO,KAAK,CAAC8C,MAAM;IAC1C,KAAK9C,KAAK,CAAC+C,SAAS;MAAE,OAAOtD,GAAG,CAACO,KAAK,CAAC+C,SAAS;IAChD,KAAK/C,KAAK,CAACM,GAAG;IAAE,KAAKN,KAAK,CAACgD,SAAS;IAAE,KAAKhD,KAAK,CAACiD,QAAQ;MAAE,OAAOxD,GAAG,CAACO,KAAK,CAACM,GAAG;IAC/E,KAAKN,KAAK,CAACkD,GAAG;MAAE,OAAOzD,GAAG,CAACO,KAAK,CAACkD,GAAG;IACpC,KAAKlD,KAAK,CAACmD,OAAO;MAAE,OAAO1D,GAAG,CAACO,KAAK,CAACmD,OAAO;IAC5C;MAAS,OAAOhC,IAAI;EAAA;AAExB,CAAC;AAED,MAAMiC,YAAY,GAAG,SAAAA,CAAUjC,IAAI,EAAEkC,MAAM,EAAE;EAC3C,IAAI,OAAOlC,IAAI,KAAK,QAAQ,EAAE,OAAOmC,SAAS;EAE9C,QAAQnC,IAAI;IACV,KAAK1B,GAAG,CAACO,KAAK,CAAC0C,IAAI;MAAE,OAAO1C,KAAK,CAAC0C,IAAI;IACtC,KAAKjD,GAAG,CAACO,KAAK,CAAC2C,KAAK;MAAE,OAAO3C,KAAK,CAAC2C,KAAK;IACxC,KAAKlD,GAAG,CAACO,KAAK,CAACoB,OAAO;MAAE,OAAOpB,KAAK,CAACoB,OAAO;IAC5C,KAAK3B,GAAG,CAACO,KAAK,CAACqB,QAAQ;MAAE,OAAOrB,KAAK,CAACqB,QAAQ;IAC9C,KAAK5B,GAAG,CAACO,KAAK,CAACsB,IAAI;MAAE,OAAOtB,KAAK,CAACsB,IAAI;IACtC,KAAK7B,GAAG,CAACO,KAAK,CAAC4C,KAAK;MAAE,OAAO5C,KAAK,CAAC4C,KAAK;IACxC,KAAKnD,GAAG,CAACO,KAAK,CAACuB,GAAG;MAAE,OAAOvB,KAAK,CAACuB,GAAG;IACpC,KAAK9B,GAAG,CAACO,KAAK,CAACwB,MAAM;MAAE,OAAOxB,KAAK,CAACwB,MAAM;IAC1C,KAAK/B,GAAG,CAACO,KAAK,CAACyB,OAAO;MAAE,OAAOzB,KAAK,CAACyB,OAAO;IAC5C,KAAKhC,GAAG,CAACO,KAAK,CAAC0B,QAAQ;MAAE,OAAO1B,KAAK,CAAC0B,QAAQ;IAC9C,KAAKjC,GAAG,CAACO,KAAK,CAAC2B,GAAG;MAAE,OAAO3B,KAAK,CAAC2B,GAAG;IACpC,KAAKlC,GAAG,CAACO,KAAK,CAAC4B,KAAK;MAAE,OAAO5B,KAAK,CAAC4B,KAAK;IACxC,KAAKnC,GAAG,CAACO,KAAK,CAAC+B,IAAI;MAAE,OAAO/B,KAAK,CAAC+B,IAAI;IACtC,KAAKtC,GAAG,CAACO,KAAK,CAACgC,KAAK;MAAE,OAAOhC,KAAK,CAACgC,KAAK;IACxC,KAAKvC,GAAG,CAACO,KAAK,CAACiC,UAAU;MAAE,OAAOjC,KAAK,CAACiC,UAAU;IAClD,KAAKxC,GAAG,CAACO,KAAK,CAAC8B,OAAO;MAAE,OAAO9B,KAAK,CAAC8B,OAAO;IAC5C,KAAKrC,GAAG,CAACO,KAAK,CAAC6B,OAAO;MAAE,OAAO7B,KAAK,CAAC6B,OAAO;IAC5C,KAAKpC,GAAG,CAACO,KAAK,CAACoC,QAAQ;MAAE,OAAOpC,KAAK,CAACoC,QAAQ;IAC9C,KAAK3C,GAAG,CAACO,KAAK,CAACkC,IAAI;MAAE,OAAOlC,KAAK,CAACkC,IAAI;IACtC,KAAKzC,GAAG,CAACO,KAAK,CAACmC,IAAI;MAAE,OAAOnC,KAAK,CAACmC,IAAI;IACtC,KAAK1C,GAAG,CAACO,KAAK,CAACqC,SAAS;MAAE,OAAOrC,KAAK,CAACqC,SAAS;IAChD,KAAK5C,GAAG,CAACO,KAAK,CAACsC,cAAc;MAAE,OAAOtC,KAAK,CAACsC,cAAc;IAC1D,KAAK7C,GAAG,CAACO,KAAK,CAACuC,aAAa;MAAE,OAAOvC,KAAK,CAACuC,aAAa;IACxD,KAAK9C,GAAG,CAACO,KAAK,CAACwC,gBAAgB;MAAE,OAAOxC,KAAK,CAACwC,gBAAgB;IAC9D,KAAK/C,GAAG,CAACO,KAAK,CAAC6C,KAAK;MAAE,OAAO7C,KAAK,CAAC6C,KAAK;IACxC,KAAKpD,GAAG,CAACO,KAAK,CAAC8C,MAAM;MAAE,OAAO9C,KAAK,CAAC8C,MAAM;IAC1C,KAAKrD,GAAG,CAACO,KAAK,CAAC+C,SAAS;MAAE,OAAO/C,KAAK,CAAC+C,SAAS;IAChD,KAAKtD,GAAG,CAACO,KAAK,CAACyC,GAAG;MAAE,OAAOzC,KAAK,CAACyC,GAAG;IACpC,KAAKhD,GAAG,CAACO,KAAK,CAACM,GAAG;MAAE,OAAON,KAAK,CAACM,GAAG;IACpC,KAAKb,GAAG,CAACO,KAAK,CAACkD,GAAG;MAAE,OAAOlD,KAAK,CAACkD,GAAG;IACpC,KAAKzD,GAAG,CAACO,KAAK,CAACmD,OAAO;MAAE,OAAOnD,KAAK,CAACmD,OAAO;IAC5C;MACE,QAAQhC,IAAI,CAACoC,EAAE;QACb,KAAK7C,OAAO,CAACC,IAAI;UAAE,OAAOX,KAAK,CAAC2B,GAAG;QACnC,KAAKjB,OAAO,CAACO,QAAQ;UAAE,OAAOjB,KAAK,CAAC8B,OAAO;QAC3C,KAAKpB,OAAO,CAACG,QAAQ;UAAE,OAAOb,KAAK,CAAC6B,OAAO;QAC3C,KAAKnB,OAAO,CAACK,IAAI;UACf,IAAIsC,MAAM,KAAK,CAAC,EAAE,OAAOrD,KAAK,CAACwB,MAAM;UACrC,IAAI6B,MAAM,KAAK,CAAC,EAAE,OAAOrD,KAAK,CAACuB,GAAG;UAClC,IAAI8B,MAAM,KAAK,CAAC,EAAE,OAAOrD,KAAK,CAAC0B,QAAQ;UACvC,OAAO1B,KAAK,CAACyB,OAAO;QACtB,KAAKf,OAAO,CAACI,MAAM;UACjB,IAAIuC,MAAM,KAAK,CAAC,EAAE,OAAOrD,KAAK,CAAC4B,KAAK;UACpC,OAAO5B,KAAK,CAAC+B,IAAI;QACnB,KAAKrB,OAAO,CAACM,MAAM;UACjB,IAAIqC,MAAM,KAAK,CAAC,EAAE,OAAOrD,KAAK,CAACgC,KAAK;UACpC,OAAOhC,KAAK,CAACiC,UAAU;QACzB,KAAKvB,OAAO,CAACE,SAAS;UACpB,IAAIyC,MAAM,KAAK,CAAC,EAAE,OAAOrD,KAAK,CAACoC,QAAQ;UACvC,OAAOpC,KAAK,CAACuC,aAAa;MAAA;EAC7B;AAEP,CAAC;AAED,MAAMiB,aAAa,GAAG,SAAAA,CAAUC,QAAQ,EAAEC,YAAY,EAAE;EACtD,IAAIC,GAAG,GAAG,CAAC,CAAC;EACZ,IAAID,YAAY,EAAEC,GAAG,GAAG,EAAE;EAC1B,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEP,MAAM,GAAGI,QAAQ,CAACJ,MAAM,EAAEO,KAAK,GAAGP,MAAM,EAAEO,KAAK,EAAE,EAAE;IACrE,MAAMC,MAAM,GAAGJ,QAAQ,CAACG,KAAK,CAAC;IAC9B,MAAME,SAAS,GAAG;MAChBF,KAAK;MACLG,IAAI,EAAEF,MAAM,CAACG,OAAO;MACpBX,MAAM,EAAEQ,MAAM,CAACI,UAAU;MACzB9C,IAAI,EAAEiC,YAAY,CAACS,MAAM,CAAC1C,IAAI,EAAE0C,MAAM,CAACI,UAAU,CAAC;MAClDC,KAAK,EAAEL,MAAM,CAACK,KAAK;MACnBC,SAAS,EAAEN,MAAM,CAACM,SAAS;MAC3BC,QAAQ,EAAE,CAAC,EAAEP,MAAM,CAACQ,KAAK,GAAG,IAAI,CAAC;MACjCC,aAAa,EAAE,CAAC,EAAET,MAAM,CAACQ,KAAK,GAAG,IAAI,CAAC;MACtCE,QAAQ,EAAE,CAAC,EAAEV,MAAM,CAACQ,KAAK,GAAG,IAAI,CAAC;MACjCG,QAAQ,EAAE,EAAEX,MAAM,CAACQ,KAAK,GAAG,IAAI;IACjC,CAAC;IAED,IAAIR,MAAM,CAACY,OAAO,EAAE;MAClBX,SAAS,CAACY,GAAG,GAAG;QACdX,IAAI,EAAEF,MAAM,CAACY,OAAO,CAACE,QAAQ;QAC7BC,QAAQ,EAAEf,MAAM,CAACY,OAAO,CAACI,MAAM;QAC/BC,MAAM,EAAEjB,MAAM,CAACY,OAAO,CAACM,YAAY;QACnCC,QAAQ,EAAEnB,MAAM,CAACY,OAAO,CAACQ;MAC3B,CAAC;MAED,IAAIhF,YAAY,CAAC4D,MAAM,CAACY,OAAO,CAACE,QAAQ,CAAC,EAAE;QACzCb,SAAS,CAAC3C,IAAI,GAAGlB,YAAY,CAAC4D,MAAM,CAACY,OAAO,CAACE,QAAQ,CAAC;MACxD;IACF;IAEA,IAAIjB,YAAY,EAAE;MAChBC,GAAG,CAACuB,IAAI,CAACpB,SAAS,CAAC;IACrB,CAAC,MAAM;MACLH,GAAG,CAACE,MAAM,CAACG,OAAO,CAAC,GAAGF,SAAS;IACjC;EACF;EAEA,OAAOH,GAAG;AACZ,CAAC;AAED,MAAMwB,eAAe,GAAG,SAAAA,CAAUC,KAAK,EAAE3B,QAAQ,EAAE;EACjD,MAAMtC,IAAI,GAAGiC,YAAY,CAACK,QAAQ,CAACtC,IAAI,CAAC;EACxC,IAAIZ,YAAY,CAAC8E,GAAG,CAAClE,IAAI,CAAC,EAAE;IAC1B,OAAOZ,YAAY,CAAC+E,GAAG,CAACnE,IAAI,CAAC,CAACiE,KAAK,CAAC;EACtC,CAAC,MAAM,IAAK3B,QAAQ,CAACtC,IAAI,KAAK1B,GAAG,CAACO,KAAK,CAACM,GAAG,IAAM8E,KAAK,IAAI,IAAK,EAAE;IAC/D,IAAI9E,GAAG,CAACmD,QAAQ,CAACgB,OAAO,CAACE,QAAQ,CAAC,EAAE;MAClC,OAAOrE,GAAG,CAACmD,QAAQ,CAACgB,OAAO,CAACE,QAAQ,CAAC,CAACS,KAAK,CAAC;IAC9C,CAAC,MAAM;MACL,OAAOA,KAAK;IACd;EACF,CAAC,MAAM;IACL,OAAOA,KAAK;EACd;AACF,CAAC;AAED,MAAMG,mBAAmB,GAAG,SAAAA,CAAUH,KAAK,EAAE;EAC3C,IAAIA,KAAK,YAAYhF,KAAK,EAAE;IAC1B,MAAMoF,GAAG,GAAG;MACVzB,IAAI,EAAEqB,KAAK,CAACrB,IAAI;MAChBe,MAAM,EAAEM,KAAK,CAACN,MAAM;MACpBW,OAAO,EAAE,EAAE;MACXC,IAAI,EAAEN,KAAK,CAACM;IACd,CAAC;IAED,KAAK,MAAMC,GAAG,IAAIP,KAAK,CAACK,OAAO,EAAE;MAC/BD,GAAG,CAACC,OAAO,CAACP,IAAI,CAAC;QACfnB,IAAI,EAAE4B,GAAG,CAAC5B,IAAI;QACd5C,IAAI,EAAED,cAAc,CAACyE,GAAG,CAACxE,IAAI,CAAC;QAC9BkC,MAAM,EAAEsC,GAAG,CAACtC,MAAM;QAClBa,KAAK,EAAEyB,GAAG,CAACzB,KAAK;QAChBC,SAAS,EAAEwB,GAAG,CAACxB;MACjB,CAAC,CAAC;IACJ;IAEA,OAAOqB,GAAG;EACZ,CAAC,MAAM;IACL,OAAOJ,KAAK;EACd;AACF,CAAC;AAED,MAAMQ,OAAO,SAAShG,WAAW,CAAC;EAChC;AACF;AACA;;EAEEiG,MAAMA,CAAEC,KAAK,EAAEC,QAAQ,EAAE;IACvB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,MAAM,CAACH,KAAK,EAAEC,QAAQ,CAAC;EAC9B;;EAEA;AACF;AACA;;EAEEG,KAAKA,CAAEC,KAAK,EAAEC,OAAO,EAAEL,QAAQ,EAAE;IAAA,IAAAM,KAAA;IAC/B,KAAK,CAACH,KAAK,CAACC,KAAK,EAAEC,OAAO,EAAEE,GAAG,IAAI;MACjC,IAAIA,GAAG,EAAE,OAAOP,QAAQ,CAACO,GAAG,CAAC;MAE7B,IAAI;QACFH,KAAK,CAACI,SAAS,EAAE;MACnB,CAAC,CAAC,OAAOC,CAAC,EAAE;QACV,OAAOT,QAAQ,CAAC,IAAIlG,YAAY,CAAC2G,CAAC,EAAE,UAAU,CAAC,CAAC;MAClD;MAEA,IAAI,CAACL,KAAK,CAACpC,IAAI,EAAE;QACf,OAAOgC,QAAQ,CAAC,IAAIlG,YAAY,CAAC,+CAA+C,EAAE,OAAO,CAAC,CAAC;MAC7F;MAEA,IAAIsG,KAAK,CAACpC,IAAI,CAAC0C,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAChC,OAAOV,QAAQ,CAAC,IAAIlG,YAAY,CAAC,gDAAgD,EAAE,OAAO,CAAC,CAAC;MAC9F;MAEA,MAAM6G,MAAM,GAAG,EAAE;MACjB,MAAMC,aAAa,GAAG,CAAC,CAAC;MACxB,IAAIC,WAAW,GAAG,KAAK;MAEvB,MAAMC,WAAW,GAAGA,CAACC,QAAQ,EAAEC,UAAU,EAAEC,IAAI,KAAK;QAClD,IAAIV,GAAG,GAAG,IAAIW,KAAK,CAACD,IAAI,CAACE,OAAO,CAAC;QACjCZ,GAAG,CAACU,IAAI,GAAGA,IAAI;QACfV,GAAG,GAAG,IAAIzG,YAAY,CAACyG,GAAG,EAAE,UAAU,CAAC;QAEvC,IAAI,IAAI,CAACa,MAAM,EAAE;UACf,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEd,GAAG,CAAC;QACzB,CAAC,MAAM;UACL,IAAIQ,QAAQ,IAAI,CAACF,WAAW,EAAE;YAC5B,IAAIG,UAAU,EAAE;cACd,KAAK,MAAMM,KAAK,IAAIV,aAAa,EAAE;gBACjCI,UAAU,CAACO,cAAc,CAACD,KAAK,EAAEV,aAAa,CAACU,KAAK,CAAC,CAAC;cACxD;cAEA,IAAI,CAACE,MAAM,CAACC,OAAO,CAACT,UAAU,CAAC;YACjC;YAEAH,WAAW,GAAG,IAAI;YAClBb,QAAQ,CAACO,GAAG,CAAC;UACf;QACF;;QAEA;QACAI,MAAM,CAACxB,IAAI,CAACoB,GAAG,CAAC;MAClB,CAAC;MAED,MAAMmB,UAAU,GAAGC,GAAG,IAAI;QACxB,IAAI,CAACN,IAAI,CAAC,MAAM,EAAE;UAChBF,OAAO,EAAEQ,GAAG,CAACR,OAAO;UACpBS,MAAM,EAAED,GAAG,CAACC,MAAM;UAClBC,KAAK,EAAEF,GAAG,CAACE,KAAK;UAChBC,KAAK,EAAEH,GAAG,CAACG,KAAK;UAChBC,UAAU,EAAEJ,GAAG,CAACI,UAAU;UAC1BC,UAAU,EAAEL,GAAG,CAACK,UAAU;UAC1BC,QAAQ,EAAEN,GAAG,CAACM;QAChB,CAAC,CAAC;MACJ,CAAC;MAED,IAAI,CAACT,MAAM,CAACU,OAAO,CAAC,IAAI,EAAE,CAAC3B,GAAG,EAAES,UAAU,KAAK;QAC7C,MAAMmB,mBAAmB,GAAG,SAAAA,CAAC5B,GAAG,EAAc;UAC5C,IAAI;YACFD,KAAI,CAACkB,MAAM,CAACC,OAAO,CAACT,UAAU,CAAC;UACjC,CAAC,CAAC,OAAOP,CAAC,EAAE;YACV;UAAA;UACD,SAAA2B,IAAA,GAAAC,SAAA,CAAA/E,MAAA,EALkCgF,IAAI,OAAAC,KAAA,CAAAH,IAAA,OAAAA,IAAA,WAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;YAAJF,IAAI,CAAAE,IAAA,QAAAH,SAAA,CAAAG,IAAA;UAAA;UAMvCxC,QAAQ,CAACO,GAAG,EAAE,GAAG+B,IAAI,CAAC;QACxB,CAAC;QACD,IAAI/B,GAAG,EAAE,OAAO4B,mBAAmB,CAAC5B,GAAG,CAAC;QAExC3G,KAAK,CAAC,yCAAyC,EAAEG,GAAG,CAACwF,GAAG,CAACyB,UAAU,CAAC,EAAEjH,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;QAEpF,IAAI,IAAI,CAACkD,QAAQ,EAAE;UACjB7I,KAAK,CAAC,uBAAuB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;UAC7C,OAAO4C,mBAAmB,CAAC,IAAIrI,YAAY,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;QACtE;QAEA,IAAI,CAAC4I,OAAO,GAAG,MAAM;UACnB9I,KAAK,CAAC,qBAAqB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;UAC3CyB,UAAU,CAAC2B,MAAM,EAAE;QACrB,CAAC;;QAED;QACA3B,UAAU,CAAC4B,EAAE,CAAC,aAAa,EAAEhC,aAAa,CAACiC,WAAW,GAAGnB,UAAU,CAAC;QACpEV,UAAU,CAAC4B,EAAE,CAAC,cAAc,EAAEhC,aAAa,CAACkC,YAAY,GAAGhC,WAAW,CAACiC,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE/B,UAAU,CAAC,CAAC;QACrGA,UAAU,CAAC4B,EAAE,CAAC,OAAO,EAAEhC,aAAa,CAACoC,KAAK,GAAGlC,WAAW,CAACiC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE/B,UAAU,CAAC,CAAC;QAEtF,MAAMiC,IAAI,GAAGA,CAAC1C,GAAG,EAAE2C,QAAQ,KAAK;UAC9B;UACA,IAAI3C,GAAG,KAAK,CAACI,MAAM,CAACrD,MAAM,IAAKqD,MAAM,CAACrD,MAAM,IAAIiD,GAAG,CAACY,OAAO,KAAKR,MAAM,CAACA,MAAM,CAACrD,MAAM,GAAG,CAAC,CAAC,CAAC6D,OAAQ,CAAC,EAAE;YACnGZ,GAAG,GAAG,IAAIzG,YAAY,CAACyG,GAAG,EAAE,UAAU,CAAC;YACvC,IAAI,IAAI,CAACa,MAAM,EAAE,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEd,GAAG,CAAC;YACxCI,MAAM,CAACxB,IAAI,CAACoB,GAAG,CAAC;UAClB;UAEA,OAAO,IAAI,CAACmC,OAAO;UAEnB,IAAIM,KAAK;UACT,IAAIrC,MAAM,CAACrD,MAAM,IAAI,CAAC,IAAI,CAAC8D,MAAM,EAAE;YACjC4B,KAAK,GAAGrC,MAAM,CAACwC,GAAG,EAAE;YACpBH,KAAK,CAACI,eAAe,GAAGzC,MAAM;UAChC;UAEA,IAAI,CAACE,WAAW,EAAE;YAChB,KAAK,MAAMS,KAAK,IAAIV,aAAa,EAAE;cACjCI,UAAU,CAACO,cAAc,CAACD,KAAK,EAAEV,aAAa,CAACU,KAAK,CAAC,CAAC;YACxD;YAEAT,WAAW,GAAG,IAAI;YAElB,IAAI,IAAI,CAACO,MAAM,EAAE;cACfe,mBAAmB,CAAC,IAAI,EAAEe,QAAQ,CAAC;YACrC,CAAC,MAAM;cACLf,mBAAmB,CAACa,KAAK,EAAEE,QAAQ,CAAC;YACtC;UACF;QACF,CAAC;QAED,MAAMG,IAAI,GAAGrC,UAAU,CAACsC,WAAW,CAAClD,KAAK,CAACmD,IAAI,EAAElD,OAAO,EAAE4C,IAAI,CAAC;QAE9D,KAAK,MAAMrD,GAAG,IAAIQ,KAAK,CAACV,OAAO,EAAE;UAC/B2D,IAAI,CAACG,SAAS,CAAC5D,GAAG,CAAC5B,IAAI,EAAE7C,cAAc,CAACyE,GAAG,CAACxE,IAAI,CAAC,EAAE;YAAEiD,QAAQ,EAAEuB,GAAG,CAACvB,QAAQ;YAAEf,MAAM,EAAEsC,GAAG,CAACtC,MAAM;YAAEa,KAAK,EAAEyB,GAAG,CAACzB,KAAK;YAAEC,SAAS,EAAEwB,GAAG,CAACxB;UAAU,CAAC,CAAC;QAChJ;QAEA,IAAIgC,KAAK,CAACqD,MAAM,EAAE;UAChB,MAAMC,QAAQ,GAAGtD,KAAK,CAACuD,SAAS,GAAI,YAAWvD,KAAK,CAACpC,IAAK,GAAE,GAAGoC,KAAK,CAACmD,IAAI;UACzE,MAAMK,GAAG,GAAG,IAAIlK,GAAG,CAACmG,OAAO,CAAE,iBAAgB6D,QAAQ,CAACG,OAAO,CAAC,IAAI,EAAE,MAAM,CAAE,cAAazD,KAAK,CAACjG,OAAO,EAAG,EAAC,EAAEoG,GAAG,IAAI;YACjH,IAAIA,GAAG,EAAE,OAAO0C,IAAI,CAAC1C,GAAG,CAAC;YAEzBS,UAAU,CAAC8C,YAAY,CAACT,IAAI,EAAEjD,KAAK,CAACT,IAAI,CAAC;UAC3C,CAAC,CAAC;UACF,IAAI,CAACoE,kBAAkB,CAACH,GAAG,CAAC;UAE5B5C,UAAU,CAACgD,YAAY,CAACJ,GAAG,CAAC;QAC9B,CAAC,MAAM;UACL5C,UAAU,CAAC8C,YAAY,CAACT,IAAI,EAAEjD,KAAK,CAACT,IAAI,CAAC;QAC3C;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;;EAEEO,MAAMA,CAAE+D,OAAO,EAAEjE,QAAQ,EAAE;IACzB,KAAK,CAACE,MAAM,CAAC+D,OAAO,EAAE1D,GAAG,IAAI;MAC3B,IAAIA,GAAG,EAAE,OAAOP,QAAQ,CAACO,GAAG,CAAC;MAE7B,MAAM2D,UAAU,GAAG,EAAE;MACrB,MAAMC,gBAAgB,GAAG,EAAE;MAC3B,MAAMxD,MAAM,GAAG,EAAE;MACjB,MAAMC,aAAa,GAAG,CAAC,CAAC;MACxB,MAAMwD,MAAM,GAAG,CAAC,CAAC;MACjB,MAAMC,YAAY,GAAG,EAAE;MAEvB,IAAI3E,OAAO,GAAG,CAAC,CAAC;MAChB,IAAI4E,SAAS,GAAG,EAAE;MAClB,IAAIC,YAAY,GAAG,IAAI;MACvB,IAAIC,cAAc,GAAG,KAAK;MAC1B,IAAIC,kBAAkB,GAAG,KAAK;MAC9B,IAAIC,YAAY,GAAG,IAAI;MACvB,IAAI7D,WAAW,GAAG,KAAK;MAEvB,MAAMC,WAAW,GAAGA,CAACC,QAAQ,EAAEC,UAAU,EAAEC,IAAI,KAAK;QAClD,IAAIV,GAAG,GAAG,IAAIW,KAAK,CAACD,IAAI,CAACE,OAAO,CAAC;QACjCZ,GAAG,CAACU,IAAI,GAAGA,IAAI;QACfV,GAAG,GAAG,IAAIzG,YAAY,CAACyG,GAAG,EAAE,UAAU,CAAC;QAEvC,IAAI,IAAI,CAACa,MAAM,EAAE;UACf,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEd,GAAG,CAAC;QACzB,CAAC,MAAM;UACL,IAAIQ,QAAQ,IAAI,CAACF,WAAW,EAAE;YAC5B,IAAIG,UAAU,EAAE;cACd,KAAK,MAAMM,KAAK,IAAIV,aAAa,EAAE;gBACjCI,UAAU,CAACO,cAAc,CAACD,KAAK,EAAEV,aAAa,CAACU,KAAK,CAAC,CAAC;cACxD;cAEA,IAAI,CAACE,MAAM,CAACC,OAAO,CAACT,UAAU,CAAC;YACjC;YAEAH,WAAW,GAAG,IAAI;YAClBb,QAAQ,CAACO,GAAG,CAAC;UACf;QACF;;QAEA;QACAI,MAAM,CAACxB,IAAI,CAACoB,GAAG,CAAC;MAClB,CAAC;MAED,MAAMmB,UAAU,GAAGC,GAAG,IAAI;QACxB,IAAI,CAACN,IAAI,CAAC,MAAM,EAAE;UAChBF,OAAO,EAAEQ,GAAG,CAACR,OAAO;UACpBS,MAAM,EAAED,GAAG,CAACC,MAAM;UAClBC,KAAK,EAAEF,GAAG,CAACE,KAAK;UAChBC,KAAK,EAAEH,GAAG,CAACG,KAAK;UAChBC,UAAU,EAAEJ,GAAG,CAACI,UAAU;UAC1BC,UAAU,EAAEL,GAAG,CAACK,UAAU;UAC1BC,QAAQ,EAAEN,GAAG,CAACM;QAChB,CAAC,CAAC;MACJ,CAAC;MAED,IAAI,CAACT,MAAM,CAACU,OAAO,CAAC,IAAI,EAAE,CAAC3B,GAAG,EAAES,UAAU,EAAE2D,MAAM,KAAK;QACrD,IAAIpE,GAAG,EAAE,OAAOP,QAAQ,CAACO,GAAG,CAAC;QAE7B3G,KAAK,CAAC,yCAAyC,EAAEG,GAAG,CAACwF,GAAG,CAACyB,UAAU,CAAC,EAAEjH,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;QAEpF,IAAIqF,GAAG;QAEP,IAAI,IAAI,CAACnC,QAAQ,EAAE;UACjB7I,KAAK,CAAC,uBAAuB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;UAC7C,IAAI,CAACiC,MAAM,CAACC,OAAO,CAACT,UAAU,CAAC;UAC/B,OAAOhB,QAAQ,CAAC,IAAIlG,YAAY,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;QAC3D;QAEA,IAAI,CAAC4I,OAAO,GAAG,MAAM;UACnB9I,KAAK,CAAC,qBAAqB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;UAC3CyB,UAAU,CAAC2B,MAAM,EAAE;QACrB,CAAC;;QAED;QACA3B,UAAU,CAAC4B,EAAE,CAAC,aAAa,EAAEhC,aAAa,CAACiC,WAAW,GAAGnB,UAAU,CAAC;QACpEV,UAAU,CAAC4B,EAAE,CAAC,cAAc,EAAEhC,aAAa,CAACkC,YAAY,GAAGhC,WAAW,CAACiC,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE/B,UAAU,CAAC,CAAC;QACrGA,UAAU,CAAC4B,EAAE,CAAC,OAAO,EAAEhC,aAAa,CAACoC,KAAK,GAAGlC,WAAW,CAACiC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE/B,UAAU,CAAC,CAAC;QAEtFpH,KAAK,CAAC,oBAAoB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,EAAE0E,OAAO,CAAC;QAEnD,MAAML,GAAG,GAAG,IAAIlK,GAAG,CAACmG,OAAO,CAACoE,OAAO,EAAE1D,GAAG,IAAI;UAC1C;UACA,CAACA,GAAG,EAAEI,MAAM,GAAGJ,GAAG,CAACI,MAAM,GAAG,CAACJ,GAAG,CAAC,EAAEsE,OAAO,CAAC,CAACpE,CAAC,EAAEqE,CAAC,EAAAC,IAAA,KAAiB;YAAA,IAAf;cAAEzH;YAAO,CAAC,GAAAyH,IAAA;YAC1D;YACA,IAAItE,CAAC,KAAK,CAACE,MAAM,CAACrD,MAAM,IAAKqD,MAAM,CAACrD,MAAM,IAAIqD,MAAM,CAACrD,MAAM,IAAIA,MAAM,IAAImD,CAAC,CAACU,OAAO,KAAKR,MAAM,CAACA,MAAM,CAACrD,MAAM,GAAGA,MAAM,GAAGwH,CAAC,CAAC,CAAC3D,OAAQ,CAAC,EAAE;cACnIV,CAAC,GAAG,IAAI3G,YAAY,CAAC2G,CAAC,EAAE,UAAU,CAAC;cACnC,IAAI,IAAI,CAACW,MAAM,EAAE,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEZ,CAAC,CAAC;cACtCE,MAAM,CAACxB,IAAI,CAACsB,CAAC,CAAC;YAChB;UACF,CAAC,CAAC;;UAEF;UACA,IAAI+D,cAAc,EAAE;YAClB,IAAI,CAAC,IAAI,CAACpD,MAAM,EAAEmD,YAAY,GAAGL,UAAU,CAACf,GAAG,EAAE,CAAC,CAAC,CAAC;YAEpD,KAAK,MAAMnF,IAAI,IAAIuG,YAAY,EAAE;cAC/B,MAAMlF,KAAK,GAAGkF,YAAY,CAACvG,IAAI,CAAC;cAChC,IAAIA,IAAI,KAAK,cAAc,EAAE;gBAC3BoG,MAAM,CAACpG,IAAI,CAAC,GAAGqB,KAAK;cACtB;YACF;UACF;UAEA,OAAO,IAAI,CAACqD,OAAO;UAEnB,IAAIM,KAAK;UACT,IAAIrC,MAAM,CAACrD,MAAM,IAAI,CAAC,IAAI,CAAC8D,MAAM,EAAE;YACjC4B,KAAK,GAAGrC,MAAM,CAACwC,GAAG,EAAE;YACpBH,KAAK,CAACI,eAAe,GAAGzC,MAAM;UAChC;UAEA,IAAI,CAACE,WAAW,EAAE;YAChB,KAAK,MAAMS,KAAK,IAAIV,aAAa,EAAE;cACjCI,UAAU,CAACO,cAAc,CAACD,KAAK,EAAEV,aAAa,CAACU,KAAK,CAAC,CAAC;YACxD;YAEA,IAAI,CAACE,MAAM,CAACC,OAAO,CAACT,UAAU,CAAC;YAC/BH,WAAW,GAAG,IAAI;YAElB,IAAImC,KAAK,EAAE;cACTpJ,KAAK,CAAC,qBAAqB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,EAAEyD,KAAK,CAAC;YACpD,CAAC,MAAM;cACLpJ,KAAK,CAAC,wBAAwB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;YAChD;YAEA,IAAI,IAAI,CAAC6B,MAAM,EAAE;cACfpB,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAEoE,MAAM,EAAEC,YAAY,EAAEF,gBAAgB,CAAC;YAC9D,CAAC,MAAM;cACLnE,QAAQ,CAACgD,KAAK,EAAEkB,UAAU,EAAEE,MAAM,EAAEC,YAAY,EAAEF,gBAAgB,CAAC;YACrE;UACF;QACF,CAAC,CAAC;QAEF,IAAI,CAACJ,kBAAkB,CAACH,GAAG,CAAC;QAE5BA,GAAG,CAAChB,EAAE,CAAC,gBAAgB,EAAElF,QAAQ,IAAI;UACnCgC,OAAO,GAAGjC,aAAa,CAACC,QAAQ,EAAE,IAAI,CAACC,YAAY,CAAC;UAEpD8G,kBAAkB,GAAG,KAAK;UAC1B,IAAI/G,QAAQ,CAACJ,MAAM,KAAK,CAAC,KAAKI,QAAQ,CAAC,CAAC,CAAC,CAACO,OAAO,KAAKxD,cAAc,IAAIiD,QAAQ,CAAC,CAAC,CAAC,CAACO,OAAO,KAAKvD,aAAa,CAAC,EAAE;YAC9G+J,kBAAkB,GAAG,IAAI;YACzBC,YAAY,GAAG,EAAE;UACnB;UAEA,IAAI,IAAI,CAACtD,MAAM,EAAE;YACf,IAAI,IAAI,CAACnB,QAAQ,EAAE;cACjB;cACA,IAAI,CAACP,OAAO,CAACsF,YAAY,EAAE;gBACzB,IAAI,CAAC3D,IAAI,CAAC,WAAW,EAAE3B,OAAO,CAAC;cACjC;YACF,CAAC,MAAM;cACL,IAAI,CAAC2B,IAAI,CAAC,WAAW,EAAE3B,OAAO,CAAC;YACjC;UACF;UACA,IAAI,IAAI,CAAC/B,YAAY,EAAEwG,gBAAgB,CAAChF,IAAI,CAACO,OAAO,CAAC;QACvD,CAAC,CAAC;QAEF,MAAMuF,WAAW,GAAGA,CAAC/B,QAAQ,EAAEgC,IAAI,KAAK;UACtC,IAAIhC,QAAQ,IAAI,IAAI,EAAE;YACpBmB,YAAY,CAAClF,IAAI,CAAC+D,QAAQ,CAAC;YAC3B,IAAI,IAAI,CAAC9B,MAAM,EAAE;cACf,IAAI,CAACC,IAAI,CAAC,cAAc,EAAE6B,QAAQ,CAAC;YACrC;UACF;UACA;UACA,IAAIiC,MAAM,CAACC,IAAI,CAAC1F,OAAO,CAAC,CAACpC,MAAM,KAAK,CAAC,EAAE;UAEvC,IAAImH,kBAAkB,EAAE;YACtB,MAAMY,kBAAkB,GAAGX,YAAY,CAACY,IAAI,CAAC,EAAE,CAAC;YAChD,IAAI5F,OAAO,CAACjF,cAAc,CAAC,IAAIkK,MAAM,CAACY,SAAS,KAAK,IAAI,EAAE;cACxD,IAAI;gBACF,IAAIF,kBAAkB,KAAK,EAAE,EAAE;kBAC7BT,GAAG,GAAG,IAAI;gBACZ,CAAC,MAAM;kBACLA,GAAG,GAAGY,IAAI,CAACC,KAAK,CAACJ,kBAAkB,CAAC;gBACtC;cACF,CAAC,CAAC,OAAOK,EAAE,EAAE;gBACXd,GAAG,GAAG,IAAI;gBACV,MAAMe,GAAG,GAAG,IAAI7L,YAAY,CAAC,IAAIoH,KAAK,CAAE,kCAAiCwE,EAAE,CAACvE,OAAQ,EAAC,CAAC,EAAE,OAAO,CAAC;gBAEhG,IAAI,IAAI,CAACC,MAAM,EAAE,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEsE,GAAG,CAAC;;gBAExC;gBACAhF,MAAM,CAACxB,IAAI,CAACwG,GAAG,CAAC;cAClB;YACF,CAAC,MAAM;cACLf,GAAG,GAAG,CAAC,CAAC;cACRA,GAAG,CAACO,MAAM,CAACC,IAAI,CAAC1F,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG2F,kBAAkB;YACnD;YAEAX,YAAY,GAAG,IAAI;YAEnB,IAAI,IAAI,CAACtD,MAAM,EAAE;cACf,IAAI,CAACC,IAAI,CAAC,KAAK,EAAEuD,GAAG,CAAC;YACvB,CAAC,MAAM;cACLN,SAAS,CAACnF,IAAI,CAACyF,GAAG,CAAC;YACrB;UACF;UAEA,IAAI,CAAC,IAAI,CAACxD,MAAM,EAAE;YAChB;YACA+D,MAAM,CAACS,cAAc,CAACtB,SAAS,EAAE,SAAS,EAAE;cAC1CuB,UAAU,EAAE,KAAK;cACjBC,YAAY,EAAE,IAAI;cAClBzG,KAAK,EAAEK;YACT,CAAC,CAAC;YAEFyF,MAAM,CAACS,cAAc,CAACtB,SAAS,EAAE,SAAS,EAAE;cAC1CuB,UAAU,EAAE,KAAK;cACjBC,YAAY,EAAE,IAAI;cAClBzG,KAAKA,CAAErB,IAAI,EAAE;gBAAE,OAAO3D,KAAK,CAAC0L,aAAa,CAAC,IAAI,EAAE/H,IAAI,CAAC;cAAC;YACxD,CAAC,CAAC;YAEFkG,UAAU,CAAC/E,IAAI,CAACmF,SAAS,CAAC;UAC5B;UAEAA,SAAS,GAAG,EAAE;UACd5E,OAAO,GAAG,CAAC,CAAC;QACd,CAAC;QAEDkE,GAAG,CAAChB,EAAE,CAAC,YAAY,EAAEqC,WAAW,CAAC,EAAC;QAClCrB,GAAG,CAAChB,EAAE,CAAC,MAAM,EAAEqC,WAAW,CAAC,EAAC;;QAE5BrB,GAAG,CAAChB,EAAE,CAAC,aAAa,EAAE,CAACoD,aAAa,EAAE3G,KAAK,EAAE3B,QAAQ,KAAK;UACxD0G,MAAM,CAAC4B,aAAa,CAAC,GAAG3G,KAAK;QAC/B,CAAC,CAAC;QAEFuE,GAAG,CAAChB,EAAE,CAAC,KAAK,EAAElD,OAAO,IAAI;UACvB,IAAI,CAAC4E,SAAS,EAAEA,SAAS,GAAG,EAAE;UAE9B,IAAIG,kBAAkB,EAAE;YACtB,OAAOC,YAAY,CAACvF,IAAI,CAACO,OAAO,CAAC,CAAC,CAAC,CAACL,KAAK,CAAC;UAC5C;UAEA,IAAI,IAAI,CAAC1B,YAAY,EAAE;YACrBiH,GAAG,GAAG,EAAE;UACV,CAAC,MAAM;YACLA,GAAG,GAAG,CAAC,CAAC;UACV;UACA,KAAK,MAAMhF,GAAG,IAAIF,OAAO,EAAE;YACzBE,GAAG,CAACP,KAAK,GAAGD,eAAe,CAACQ,GAAG,CAACP,KAAK,EAAEO,GAAG,CAAClC,QAAQ,CAAC;YAEpD,IAAI,IAAI,CAACC,YAAY,EAAE;cACrBiH,GAAG,CAACzF,IAAI,CAACS,GAAG,CAACP,KAAK,CAAC;YACrB,CAAC,MAAM;cACL,MAAM4G,GAAG,GAAGrB,GAAG,CAAChF,GAAG,CAAClC,QAAQ,CAACO,OAAO,CAAC;cACrC,IAAIgI,GAAG,KAAK1I,SAAS,EAAE;gBACrB,IAAI0I,GAAG,YAAY1D,KAAK,EAAE;kBACxB0D,GAAG,CAAC9G,IAAI,CAACS,GAAG,CAACP,KAAK,CAAC;gBACrB,CAAC,MAAM;kBACLuF,GAAG,CAAChF,GAAG,CAAClC,QAAQ,CAACO,OAAO,CAAC,GAAG,CAACgI,GAAG,EAAErG,GAAG,CAACP,KAAK,CAAC;gBAC9C;cACF,CAAC,MAAM;gBACLuF,GAAG,CAAChF,GAAG,CAAClC,QAAQ,CAACO,OAAO,CAAC,GAAG2B,GAAG,CAACP,KAAK;cACvC;YACF;UACF;UAEA,IAAI,IAAI,CAAC+B,MAAM,EAAE;YACf,IAAI,IAAI,CAACnB,QAAQ,EAAE;cACjB;cACA,IAAI2E,GAAG,CAACI,YAAY,EAAE;gBACpBT,YAAY,GAAGK,GAAG;cACpB,CAAC,MAAM;gBACL,IAAI,CAACvD,IAAI,CAAC,KAAK,EAAEuD,GAAG,CAAC;cACvB;YACF,CAAC,MAAM;cACL,IAAI,CAACvD,IAAI,CAAC,KAAK,EAAEuD,GAAG,CAAC;YACvB;UACF,CAAC,MAAM;YACLN,SAAS,CAACnF,IAAI,CAACyF,GAAG,CAAC;UACrB;QACF,CAAC,CAAC;QAEF,IAAI,IAAI,CAAC3E,QAAQ,EAAE;UACjB,IAAIkF,MAAM,CAACC,IAAI,CAAC,IAAI,CAACc,UAAU,CAAC,CAAC5I,MAAM,EAAE;YACvC,KAAK,MAAMU,IAAI,IAAI,IAAI,CAACkI,UAAU,EAAE;cAClC,IAAI,CAAClM,iBAAiB,CAAC,IAAI,CAACkM,UAAU,EAAElI,IAAI,CAAC,EAAE;gBAC7C;cACF;cACA,MAAMmI,KAAK,GAAG,IAAI,CAACD,UAAU,CAAClI,IAAI,CAAC;cAEnC,IAAI;gBACFmI,KAAK,CAAC9G,KAAK,GAAGlE,cAAc,CAACgL,KAAK,CAAC/K,IAAI,CAAC,CAACgL,QAAQ,CAACD,KAAK,CAAC9G,KAAK,EAAE,IAAI,CAACmC,MAAM,CAAC6E,SAAS,CAAC;cACvF,CAAC,CAAC,OAAO5F,CAAC,EAAE;gBACVA,CAAC,CAACU,OAAO,GAAI,oCAAmCnD,IAAK,MAAKyC,CAAC,CAACU,OAAQ,EAAC;gBACrE,MAAMZ,GAAG,GAAG,IAAIzG,YAAY,CAAC2G,CAAC,EAAE,QAAQ,CAAC;gBAEzC,IAAI,CAACe,MAAM,CAACC,OAAO,CAACT,UAAU,CAAC;gBAC/B,OAAOhB,QAAQ,CAACO,GAAG,CAAC;cACtB;YACF;YAEA,MAAM+F,YAAY,GAAG,EAAE;YACvB,KAAK,MAAMtI,IAAI,IAAI,IAAI,CAACkI,UAAU,EAAE;cAClC,IAAI,CAAClM,iBAAiB,CAAC,IAAI,CAACkM,UAAU,EAAElI,IAAI,CAAC,EAAE;gBAC7C;cACF;cACA,MAAMmI,KAAK,GAAG,IAAI,CAACD,UAAU,CAAClI,IAAI,CAAC;cACnCsI,YAAY,CAACnH,IAAI,CAAE,IAAGnB,IAAK,IAAG7D,OAAO,CAACgM,KAAK,CAAC/K,IAAI,EAAE+K,KAAK,CAAE,EAAC,CAAC;YAC7D;YAEA,MAAMI,OAAO,GAAG,EAAE;YAClB,KAAK,MAAMvI,IAAI,IAAI,IAAI,CAACkI,UAAU,EAAE;cAClC,IAAI,CAAClM,iBAAiB,CAAC,IAAI,CAACkM,UAAU,EAAElI,IAAI,CAAC,EAAE;gBAC7C;cACF;cACA,MAAMmI,KAAK,GAAG,IAAI,CAACD,UAAU,CAAClI,IAAI,CAAC;cACnCuI,OAAO,CAACpH,IAAI,CAAE,IAAGnB,IAAK,MAAK5D,IAAI,CAAC+L,KAAK,CAAC9G,KAAK,EAAE8G,KAAK,CAAC/K,IAAI,EAAE+K,KAAK,CAAE,EAAC,CAAC;YACpE;YAEA,MAAMK,OAAO,GAAG,EAAE;YAClB,KAAK,MAAMxI,IAAI,IAAI,IAAI,CAACkI,UAAU,EAAE;cAClC,IAAI,CAAClM,iBAAiB,CAAC,IAAI,CAACkM,UAAU,EAAElI,IAAI,CAAC,EAAE;gBAC7C;cACF;cACA,MAAMmI,KAAK,GAAG,IAAI,CAACD,UAAU,CAAClI,IAAI,CAAC;cACnC,IAAImI,KAAK,CAACM,EAAE,KAAK,CAAC,EAAE;gBAClBD,OAAO,CAACrH,IAAI,CAAE,IAAGnB,IAAK,QAAOA,IAAK,GAAE,CAAC;cACvC;YACF;YAEAwG,cAAc,GAAGgC,OAAO,CAAClJ,MAAM,GAAG,CAAC;YAEnCsG,GAAG,CAAC8C,kBAAkB,GAAI,WAAUJ,YAAY,CAAChB,IAAI,CAAC,IAAI,CAAE,WAAUiB,OAAO,CAACjB,IAAI,CAAC,IAAI,CAAE,IAAG1B,GAAG,CAAC8C,kBAAmB,IAAGlC,cAAc,GAAK,+BAA8BgC,OAAO,CAAClB,IAAI,CAAC,IAAI,CAAE,EAAC,GAAI,EAAG,EAAC;UACrM;QACF,CAAC,MAAM;UACL,KAAK,MAAMtH,IAAI,IAAI,IAAI,CAACkI,UAAU,EAAE;YAClC,IAAI,CAAClM,iBAAiB,CAAC,IAAI,CAACkM,UAAU,EAAElI,IAAI,CAAC,EAAE;cAC7C;YACF;YACA,MAAMmI,KAAK,GAAG,IAAI,CAACD,UAAU,CAAClI,IAAI,CAAC;YACnC,IAAImI,KAAK,CAACM,EAAE,KAAK,CAAC,EAAE;cAClB7C,GAAG,CAAC+C,YAAY,CAACR,KAAK,CAACnI,IAAI,EAAE7C,cAAc,CAACgL,KAAK,CAAC/K,IAAI,CAAC,EAAEoE,mBAAmB,CAAC2G,KAAK,CAAC9G,KAAK,CAAC,EAAE;gBAAE/B,MAAM,EAAE6I,KAAK,CAAC7I,MAAM;gBAAEa,KAAK,EAAEgI,KAAK,CAAChI,KAAK;gBAAEC,SAAS,EAAE+H,KAAK,CAAC/H;cAAU,CAAC,CAAC;YACtK,CAAC,MAAM;cACLwF,GAAG,CAACgD,kBAAkB,CAACT,KAAK,CAACnI,IAAI,EAAE7C,cAAc,CAACgL,KAAK,CAAC/K,IAAI,CAAC,EAAEoE,mBAAmB,CAAC2G,KAAK,CAAC9G,KAAK,CAAC,EAAE;gBAAE/B,MAAM,EAAE6I,KAAK,CAAC7I,MAAM;gBAAEa,KAAK,EAAEgI,KAAK,CAAChI,KAAK;gBAAEC,SAAS,EAAE+H,KAAK,CAAC/H;cAAU,CAAC,CAAC;YAC5K;UACF;QACF;QAEA,IAAI;UACF4C,UAAU,CAAC,IAAI,CAACf,QAAQ,GAAG,cAAc,GAAG,SAAS,CAAC,CAAC2D,GAAG,CAAC;QAC7D,CAAC,CAAC,OAAOZ,KAAK,EAAE;UACdlC,WAAW,CAAC,IAAI,EAAEE,UAAU,EAAEgC,KAAK,CAAC;QACtC;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;;EAEE6D,QAAQA,CAAEC,SAAS,EAAE9G,QAAQ,EAAE;IAC7B,KAAK,CAAC6G,QAAQ,CAACC,SAAS,EAAEvG,GAAG,IAAI;MAC/B,IAAIA,GAAG,EAAE,OAAOP,QAAQ,CAACO,GAAG,CAAC;MAE7B,MAAM2D,UAAU,GAAG,EAAE;MACrB,MAAMC,gBAAgB,GAAG,EAAE;MAC3B,MAAMxD,MAAM,GAAG,EAAE;MACjB,MAAMC,aAAa,GAAG,CAAC,CAAC;MACxB,MAAMwD,MAAM,GAAG,CAAC,CAAC;MACjB,MAAMC,YAAY,GAAG,EAAE;MAEvB,IAAI3E,OAAO,GAAG,CAAC,CAAC;MAChB,IAAI4E,SAAS,GAAG,EAAE;MAClB,IAAIyC,WAAW,GAAG,CAAC;MACnB,IAAItC,kBAAkB,GAAG,KAAK;MAC9B,IAAIC,YAAY,GAAG,IAAI;MACvB,IAAI7D,WAAW,GAAG,KAAK;MAEvB,MAAMC,WAAW,GAAGA,CAACC,QAAQ,EAAEC,UAAU,EAAEC,IAAI,KAAK;QAClD,IAAIV,GAAG,GAAG,IAAIW,KAAK,CAACD,IAAI,CAACE,OAAO,CAAC;QACjCZ,GAAG,CAACU,IAAI,GAAGA,IAAI;QACfV,GAAG,GAAG,IAAIzG,YAAY,CAACyG,GAAG,EAAE,UAAU,CAAC;QAEvC,IAAI,IAAI,CAACa,MAAM,EAAE;UACf,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEd,GAAG,CAAC;QACzB,CAAC,MAAM;UACL,IAAIQ,QAAQ,IAAI,CAACF,WAAW,EAAE;YAC5B,IAAIG,UAAU,EAAE;cACd,KAAK,MAAMM,KAAK,IAAIV,aAAa,EAAE;gBACjCI,UAAU,CAACO,cAAc,CAACD,KAAK,EAAEV,aAAa,CAACU,KAAK,CAAC,CAAC;cACxD;cAEA,IAAI,CAACE,MAAM,CAACC,OAAO,CAACT,UAAU,CAAC;YACjC;YAEAH,WAAW,GAAG,IAAI;YAClBb,QAAQ,CAACO,GAAG,CAAC;UACf;QACF;;QAEA;QACAI,MAAM,CAACxB,IAAI,CAACoB,GAAG,CAAC;MAClB,CAAC;MAED,MAAMmB,UAAU,GAAGC,GAAG,IAAI;QACxB,IAAI,CAACN,IAAI,CAAC,MAAM,EAAE;UAChBF,OAAO,EAAEQ,GAAG,CAACR,OAAO;UACpBS,MAAM,EAAED,GAAG,CAACC,MAAM;UAClBC,KAAK,EAAEF,GAAG,CAACE,KAAK;UAChBC,KAAK,EAAEH,GAAG,CAACG,KAAK;UAChBC,UAAU,EAAEJ,GAAG,CAACI,UAAU;UAC1BC,UAAU,EAAEL,GAAG,CAACK,UAAU;UAC1BC,QAAQ,EAAEN,GAAG,CAACM;QAChB,CAAC,CAAC;MACJ,CAAC;MAED,IAAI,CAACT,MAAM,CAACU,OAAO,CAAC,IAAI,EAAE,CAAC3B,GAAG,EAAES,UAAU,EAAE2D,MAAM,KAAK;QACrD,IAAIpE,GAAG,EAAE,OAAOP,QAAQ,CAACO,GAAG,CAAC;QAE7B3G,KAAK,CAAC,yCAAyC,EAAEG,GAAG,CAACwF,GAAG,CAACyB,UAAU,CAAC,EAAEjH,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;QAEpF,IAAIqF,GAAG;QAEP,IAAI,IAAI,CAACnC,QAAQ,EAAE;UACjB7I,KAAK,CAAC,uBAAuB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;UAC7C,IAAI,CAACiC,MAAM,CAACC,OAAO,CAACT,UAAU,CAAC;UAC/B,OAAOhB,QAAQ,CAAC,IAAIlG,YAAY,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;QAC3D;QAEA,IAAI,CAAC4I,OAAO,GAAG,MAAM;UACnB9I,KAAK,CAAC,qBAAqB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;UAC3CyB,UAAU,CAAC2B,MAAM,EAAE;QACrB,CAAC;;QAED;QACA3B,UAAU,CAAC4B,EAAE,CAAC,aAAa,EAAEhC,aAAa,CAACiC,WAAW,GAAGnB,UAAU,CAAC;QACpEV,UAAU,CAAC4B,EAAE,CAAC,cAAc,EAAEhC,aAAa,CAACkC,YAAY,GAAGhC,WAAW,CAACiC,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE/B,UAAU,CAAC,CAAC;QACrGA,UAAU,CAAC4B,EAAE,CAAC,OAAO,EAAEhC,aAAa,CAACoC,KAAK,GAAGlC,WAAW,CAACiC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE/B,UAAU,CAAC,CAAC;QAEtF,IAAIpH,KAAK,CAACoN,OAAO,EAAE;UACjB;UACA,MAAMC,MAAM,GAAG9B,MAAM,CAACC,IAAI,CAAC,IAAI,CAACc,UAAU,CAAC,CAACgB,GAAG,CAACC,CAAC,IAAI,IAAI,CAACjB,UAAU,CAACiB,CAAC,CAAC,CAAC;UACxE;UACA,MAAMC,QAAQ,GAAGC,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,CAAC/J,MAAM,GAAG,EAAE,GAAG+J,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK,GAAGD,CAAC;UAC7F;UACA,MAAME,OAAO,GAAGpB,KAAK,IAAIA,KAAK,CAACnI,IAAI,GAAG,QAAQ,GAAGmI,KAAK,CAAC/K,IAAI,CAAC4C,IAAI,GAAG,GAAG;UACtE,MAAMwJ,SAAS,GAAG,CAAC,CAAC;UACpBP,MAAM,CAACpC,OAAO,CAAC4C,CAAC,IAAI;YAAED,SAAS,CAACD,OAAO,CAACE,CAAC,CAAC,CAAC,GAAGL,QAAQ,CAACK,CAAC,CAACpI,KAAK,CAAC;UAAC,CAAC,CAAC;UAClEzF,KAAK,CAAC,4BAA4B,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,EAAEuH,SAAS,EAAEU,SAAS,CAAC;QAC1E;QAEA,MAAM5D,GAAG,GAAG,IAAIlK,GAAG,CAACmG,OAAO,CAACiH,SAAS,EAAEvG,GAAG,IAAI;UAC5C;UACA,IAAIA,GAAG,KAAK,CAACI,MAAM,CAACrD,MAAM,IAAKqD,MAAM,CAACrD,MAAM,IAAIiD,GAAG,CAACY,OAAO,KAAKR,MAAM,CAACA,MAAM,CAACrD,MAAM,GAAG,CAAC,CAAC,CAAC6D,OAAQ,CAAC,EAAE;YACnGZ,GAAG,GAAG,IAAIzG,YAAY,CAACyG,GAAG,EAAE,UAAU,CAAC;YACvC,IAAI,IAAI,CAACa,MAAM,EAAE,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEd,GAAG,CAAC;YACxCI,MAAM,CAACxB,IAAI,CAACoB,GAAG,CAAC;UAClB;UAEA,OAAO,IAAI,CAACmC,OAAO;UAEnB,IAAIM,KAAK;UACT,IAAIrC,MAAM,CAACrD,MAAM,IAAI,CAAC,IAAI,CAAC8D,MAAM,EAAE;YACjC4B,KAAK,GAAGrC,MAAM,CAACwC,GAAG,EAAE;YACpBH,KAAK,CAACI,eAAe,GAAGzC,MAAM;UAChC;UAEA,IAAI,CAACE,WAAW,EAAE;YAChB,KAAK,MAAMS,KAAK,IAAIV,aAAa,EAAE;cACjCI,UAAU,CAACO,cAAc,CAACD,KAAK,EAAEV,aAAa,CAACU,KAAK,CAAC,CAAC;YACxD;YAEA,IAAI,CAACE,MAAM,CAACC,OAAO,CAACT,UAAU,CAAC;YAC/BH,WAAW,GAAG,IAAI;YAElB,IAAImC,KAAK,EAAE;cACTpJ,KAAK,CAAC,qBAAqB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,EAAEyD,KAAK,CAAC;YACpD,CAAC,MAAM;cACLpJ,KAAK,CAAC,uBAAuB,EAAEG,GAAG,CAACwF,GAAG,CAAC,IAAI,CAAC,CAAC;YAC/C;YAEA,IAAI,IAAI,CAAC6B,MAAM,EAAE;cACfpB,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAEoE,MAAM,EAAE2C,WAAW,EAAE1C,YAAY,EAAEF,gBAAgB,CAAC;YAC3E,CAAC,MAAM;cACLnE,QAAQ,CAACgD,KAAK,EAAEkB,UAAU,EAAEE,MAAM,EAAE2C,WAAW,EAAE1C,YAAY,EAAEF,gBAAgB,CAAC;YAClF;UACF;QACF,CAAC,CAAC;QAEF,IAAI,CAACJ,kBAAkB,CAACH,GAAG,CAAC;QAE5BA,GAAG,CAAChB,EAAE,CAAC,gBAAgB,EAAElF,QAAQ,IAAI;UACnCgC,OAAO,GAAGjC,aAAa,CAACC,QAAQ,EAAE,IAAI,CAACC,YAAY,CAAC;UAEpD8G,kBAAkB,GAAG,KAAK;UAC1B,IAAK/G,QAAQ,CAACJ,MAAM,KAAK,CAAC,KAAMI,QAAQ,CAAC,CAAC,CAAC,CAACO,OAAO,KAAKxD,cAAc,IAAIiD,QAAQ,CAAC,CAAC,CAAC,CAACO,OAAO,KAAKvD,aAAa,CAAC,EAAE;YAChH+J,kBAAkB,GAAG,IAAI;YACzBC,YAAY,GAAG,EAAE;UACnB;UAEA,IAAI,IAAI,CAACtD,MAAM,EAAE,IAAI,CAACC,IAAI,CAAC,WAAW,EAAE3B,OAAO,CAAC;UAChD,IAAI,IAAI,CAAC/B,YAAY,EAAEwG,gBAAgB,CAAChF,IAAI,CAACO,OAAO,CAAC;QACvD,CAAC,CAAC;QAEFkE,GAAG,CAAChB,EAAE,CAAC,KAAK,EAAElD,OAAO,IAAI;UACvB,IAAI,CAAC4E,SAAS,EAAEA,SAAS,GAAG,EAAE;UAE9B,IAAIG,kBAAkB,EAAE;YACtB,OAAOC,YAAY,CAACvF,IAAI,CAACO,OAAO,CAAC,CAAC,CAAC,CAACL,KAAK,CAAC;UAC5C;UAEA,IAAI,IAAI,CAAC1B,YAAY,EAAE;YACrBiH,GAAG,GAAG,EAAE;UACV,CAAC,MAAM;YACLA,GAAG,GAAG,CAAC,CAAC;UACV;UACA,KAAK,MAAMhF,GAAG,IAAIF,OAAO,EAAE;YACzBE,GAAG,CAACP,KAAK,GAAGD,eAAe,CAACQ,GAAG,CAACP,KAAK,EAAEO,GAAG,CAAClC,QAAQ,CAAC;YAEpD,IAAI,IAAI,CAACC,YAAY,EAAE;cACrBiH,GAAG,CAACzF,IAAI,CAACS,GAAG,CAACP,KAAK,CAAC;YACrB,CAAC,MAAM;cACL,MAAM4G,GAAG,GAAGrB,GAAG,CAAChF,GAAG,CAAClC,QAAQ,CAACO,OAAO,CAAC;cACrC,IAAIgI,GAAG,IAAI,IAAI,EAAE;gBACf,IAAIA,GAAG,YAAY1D,KAAK,EAAE;kBACxB0D,GAAG,CAAC9G,IAAI,CAACS,GAAG,CAACP,KAAK,CAAC;gBACrB,CAAC,MAAM;kBACLuF,GAAG,CAAChF,GAAG,CAAClC,QAAQ,CAACO,OAAO,CAAC,GAAG,CAACgI,GAAG,EAAErG,GAAG,CAACP,KAAK,CAAC;gBAC9C;cACF,CAAC,MAAM;gBACLuF,GAAG,CAAChF,GAAG,CAAClC,QAAQ,CAACO,OAAO,CAAC,GAAG2B,GAAG,CAACP,KAAK;cACvC;YACF;UACF;UAEA,IAAI,IAAI,CAAC+B,MAAM,EAAE;YACf,IAAI,CAACC,IAAI,CAAC,KAAK,EAAEuD,GAAG,CAAC;UACvB,CAAC,MAAM;YACLN,SAAS,CAACnF,IAAI,CAACyF,GAAG,CAAC;UACrB;QACF,CAAC,CAAC;QAEFhB,GAAG,CAAChB,EAAE,CAAC,YAAY,EAAE,CAACM,QAAQ,EAAEgC,IAAI,KAAK;UACvC,IAAIhC,QAAQ,IAAI,IAAI,EAAE;YACpBmB,YAAY,CAAClF,IAAI,CAAC+D,QAAQ,CAAC;YAC3B,IAAI,IAAI,CAAC9B,MAAM,EAAE;cACf,IAAI,CAACC,IAAI,CAAC,cAAc,EAAE6B,QAAQ,CAAC;YACrC;UACF;;UAEA;UACA,IAAIiC,MAAM,CAACC,IAAI,CAAC1F,OAAO,CAAC,CAACpC,MAAM,KAAK,CAAC,EAAE;UAEvC,IAAImH,kBAAkB,EAAE;YACtB,IAAI/E,OAAO,CAACjF,cAAc,CAAC,IAAIkK,MAAM,CAACY,SAAS,KAAK,IAAI,EAAE;cACxD,IAAI;gBACF,IAAIb,YAAY,CAACpH,MAAM,KAAK,CAAC,EAAE;kBAC7BsH,GAAG,GAAG,IAAI;gBACZ,CAAC,MAAM;kBACLA,GAAG,GAAGY,IAAI,CAACC,KAAK,CAACf,YAAY,CAACY,IAAI,CAAC,EAAE,CAAC,CAAC;gBACzC;cACF,CAAC,CAAC,OAAOI,EAAE,EAAE;gBACXd,GAAG,GAAG,IAAI;gBACV,MAAMe,GAAG,GAAG,IAAI7L,YAAY,CAAC,IAAIoH,KAAK,CAAE,kCAAiCwE,EAAE,CAACvE,OAAQ,EAAC,CAAC,EAAE,OAAO,CAAC;gBAEhG,IAAI,IAAI,CAACC,MAAM,EAAE,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEsE,GAAG,CAAC;;gBAExC;gBACAhF,MAAM,CAACxB,IAAI,CAACwG,GAAG,CAAC;cAClB;YACF,CAAC,MAAM;cACLf,GAAG,GAAG,CAAC,CAAC;cACRA,GAAG,CAACO,MAAM,CAACC,IAAI,CAAC1F,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGgF,YAAY,CAACY,IAAI,CAAC,EAAE,CAAC;YACtD;YAEAZ,YAAY,GAAG,IAAI;YAEnB,IAAI,IAAI,CAACtD,MAAM,EAAE;cACf,IAAI,CAACC,IAAI,CAAC,KAAK,EAAEuD,GAAG,CAAC;YACvB,CAAC,MAAM;cACLN,SAAS,CAACnF,IAAI,CAACyF,GAAG,CAAC;YACrB;UACF;UAEA,IAAI,CAAC,IAAI,CAACxD,MAAM,EAAE;YAChB;YACA+D,MAAM,CAACS,cAAc,CAACtB,SAAS,EAAE,SAAS,EAAE;cAC1CuB,UAAU,EAAE,KAAK;cACjBC,YAAY,EAAE,IAAI;cAClBzG,KAAK,EAAEK;YACT,CAAC,CAAC;YAEFyF,MAAM,CAACS,cAAc,CAACtB,SAAS,EAAE,SAAS,EAAE;cAC1CuB,UAAU,EAAE,KAAK;cACjBC,YAAY,EAAE,IAAI;cAClBzG,KAAKA,CAAErB,IAAI,EAAE;gBAAE,OAAO3D,KAAK,CAAC0L,aAAa,CAAC,IAAI,EAAE/H,IAAI,CAAC;cAAC;YACxD,CAAC,CAAC;YAEFkG,UAAU,CAAC/E,IAAI,CAACmF,SAAS,CAAC;UAC5B;UAEAA,SAAS,GAAG,EAAE;UACd5E,OAAO,GAAG,CAAC,CAAC;QACd,CAAC,CAAC;QAEFkE,GAAG,CAAChB,EAAE,CAAC,UAAU,EAAE,CAACM,QAAQ,EAAEgC,IAAI,EAAEwC,YAAY,KAAK;UACnDX,WAAW,GAAGW,YAAY;QAC5B,CAAC,CAAC;QAEF9D,GAAG,CAAChB,EAAE,CAAC,aAAa,EAAE,CAACoD,aAAa,EAAE3G,KAAK,EAAE3B,QAAQ,KAAK;UACxD0G,MAAM,CAAC4B,aAAa,CAAC,GAAG3G,KAAK;QAC/B,CAAC,CAAC;QAEF,KAAK,MAAMrB,IAAI,IAAI,IAAI,CAACkI,UAAU,EAAE;UAClC,IAAI,CAAClM,iBAAiB,CAAC,IAAI,CAACkM,UAAU,EAAElI,IAAI,CAAC,EAAE;YAC7C;UACF;UACA,MAAMmI,KAAK,GAAG,IAAI,CAACD,UAAU,CAAClI,IAAI,CAAC;UACnC,IAAImI,KAAK,CAACM,EAAE,KAAK,CAAC,EAAE;YAClB7C,GAAG,CAAC+C,YAAY,CAACR,KAAK,CAACnI,IAAI,EAAE7C,cAAc,CAACgL,KAAK,CAAC/K,IAAI,CAAC,EAAEoE,mBAAmB,CAAC2G,KAAK,CAAC9G,KAAK,CAAC,EAAE;cAAE/B,MAAM,EAAE6I,KAAK,CAAC7I,MAAM;cAAEa,KAAK,EAAEgI,KAAK,CAAChI,KAAK;cAAEC,SAAS,EAAE+H,KAAK,CAAC/H;YAAU,CAAC,CAAC;UACtK,CAAC,MAAM;YACLwF,GAAG,CAACgD,kBAAkB,CAACT,KAAK,CAACnI,IAAI,EAAE7C,cAAc,CAACgL,KAAK,CAAC/K,IAAI,CAAC,EAAEoE,mBAAmB,CAAC2G,KAAK,CAAC9G,KAAK,CAAC,EAAE;cAAE/B,MAAM,EAAE6I,KAAK,CAAC7I,MAAM;cAAEa,KAAK,EAAEgI,KAAK,CAAChI,KAAK;cAAEC,SAAS,EAAE+H,KAAK,CAAC/H;YAAU,CAAC,CAAC;UAC5K;QACF;QAEA4C,UAAU,CAAC2G,aAAa,CAAC/D,GAAG,CAAC;MAC/B,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEAgE,MAAMA,CAAA,EAAI;IACR,KAAK,CAACA,MAAM,EAAE;IACd,IAAI,IAAI,CAACC,eAAe,EAAE;MACxB,IAAI,CAACA,eAAe,CAACC,KAAK,EAAE;IAC9B;EACF;EAEAC,OAAOA,CAAA,EAAI;IACT,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,IAAI,CAACF,eAAe,EAAE;MACxB,IAAI,CAACA,eAAe,CAACG,MAAM,EAAE;IAC/B;EACF;AACF;AAEAC,MAAM,CAACC,OAAO,GAAGrI,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}