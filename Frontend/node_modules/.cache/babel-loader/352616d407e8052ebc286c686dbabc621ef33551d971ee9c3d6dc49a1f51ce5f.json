{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nconst SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nconst SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nconst UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\nconst ZERO_LENGTH_BUFFER = Buffer.alloc(0);\n\n/**\n  A Buffer-like class that tracks position.\n\n  As values are written, the position advances by the size of the written data.\n  When writing, automatically allocates new buffers if there's not enough space.\n */\nclass WritableTrackingBuffer {\n  constructor(initialSize, encoding, doubleSizeGrowth) {\n    this.initialSize = void 0;\n    this.encoding = void 0;\n    this.doubleSizeGrowth = void 0;\n    this.buffer = void 0;\n    this.compositeBuffer = void 0;\n    this.position = void 0;\n    this.initialSize = initialSize;\n    this.encoding = encoding || 'ucs2';\n    this.doubleSizeGrowth = doubleSizeGrowth || false;\n    this.buffer = Buffer.alloc(this.initialSize, 0);\n    this.compositeBuffer = ZERO_LENGTH_BUFFER;\n    this.position = 0;\n  }\n  get data() {\n    this.newBuffer(0);\n    return this.compositeBuffer;\n  }\n  copyFrom(buffer) {\n    const length = buffer.length;\n    this.makeRoomFor(length);\n    buffer.copy(this.buffer, this.position);\n    this.position += length;\n  }\n  makeRoomFor(requiredLength) {\n    if (this.buffer.length - this.position < requiredLength) {\n      if (this.doubleSizeGrowth) {\n        let size = Math.max(128, this.buffer.length * 2);\n        while (size < requiredLength) {\n          size *= 2;\n        }\n        this.newBuffer(size);\n      } else {\n        this.newBuffer(requiredLength);\n      }\n    }\n  }\n  newBuffer(size) {\n    const buffer = this.buffer.slice(0, this.position);\n    this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);\n    this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);\n    this.position = 0;\n  }\n  writeUInt8(value) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt8(value, this.position);\n    this.position += length;\n  }\n  writeUInt16LE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16LE(value, this.position);\n    this.position += length;\n  }\n  writeUShort(value) {\n    this.writeUInt16LE(value);\n  }\n  writeUInt16BE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16BE(value, this.position);\n    this.position += length;\n  }\n  writeUInt24LE(value) {\n    const length = 3;\n    this.makeRoomFor(length);\n    this.buffer[this.position + 2] = value >>> 16 & 0xff;\n    this.buffer[this.position + 1] = value >>> 8 & 0xff;\n    this.buffer[this.position] = value & 0xff;\n    this.position += length;\n  }\n  writeUInt32LE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32LE(value, this.position);\n    this.position += length;\n  }\n  writeBigInt64LE(value) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeBigInt64LE(value, this.position);\n    this.position += length;\n  }\n  writeInt64LE(value) {\n    this.writeBigInt64LE(BigInt(value));\n  }\n  writeUInt64LE(value) {\n    this.writeBigUInt64LE(BigInt(value));\n  }\n  writeBigUInt64LE(value) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeBigUInt64LE(value, this.position);\n    this.position += length;\n  }\n  writeUInt32BE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32BE(value, this.position);\n    this.position += length;\n  }\n  writeUInt40LE(value) {\n    // inspired by https://github.com/dpw/node-buffer-more-ints\n    this.writeInt32LE(value & -1);\n    this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));\n  }\n  writeInt8(value) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeInt8(value, this.position);\n    this.position += length;\n  }\n  writeInt16LE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16LE(value, this.position);\n    this.position += length;\n  }\n  writeInt16BE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16BE(value, this.position);\n    this.position += length;\n  }\n  writeInt32LE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32LE(value, this.position);\n    this.position += length;\n  }\n  writeInt32BE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32BE(value, this.position);\n    this.position += length;\n  }\n  writeFloatLE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeFloatLE(value, this.position);\n    this.position += length;\n  }\n  writeDoubleLE(value) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeDoubleLE(value, this.position);\n    this.position += length;\n  }\n  writeString(value, encoding) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n    const length = Buffer.byteLength(value, encoding);\n    this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n    this.buffer.write(value, this.position, encoding);\n    this.position += length;\n  }\n  writeBVarchar(value, encoding) {\n    this.writeUInt8(value.length);\n    this.writeString(value, encoding);\n  }\n  writeUsVarchar(value, encoding) {\n    this.writeUInt16LE(value.length);\n    this.writeString(value, encoding);\n  } // TODO: Figure out what types are passed in other than `Buffer`\n\n  writeUsVarbyte(value, encoding) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n    let length;\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    }\n    this.writeUInt16LE(length);\n    if (value instanceof Buffer) {\n      this.writeBuffer(value);\n    } else {\n      this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n      this.buffer.write(value, this.position, encoding);\n      this.position += length;\n    }\n  }\n  writePLPBody(value, encoding) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n    let length;\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    } // Length of all chunks.\n    // this.writeUInt64LE(length);\n    // unknown seems to work better here - might revisit later.\n\n    this.writeBuffer(UNKNOWN_PLP_LEN); // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.\n\n    if (length > 0) {\n      // One chunk.\n      this.writeUInt32LE(length);\n      if (value instanceof Buffer) {\n        this.writeBuffer(value);\n      } else {\n        this.makeRoomFor(length);\n        this.buffer.write(value, this.position, encoding);\n        this.position += length;\n      }\n    } // PLP_TERMINATOR (no more chunks).\n\n    this.writeUInt32LE(0);\n  }\n  writeBuffer(value) {\n    const length = value.length;\n    this.makeRoomFor(length);\n    value.copy(this.buffer, this.position);\n    this.position += length;\n  }\n  writeMoney(value) {\n    this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n    this.writeInt32LE(value & -1);\n  }\n}\nvar _default = WritableTrackingBuffer;\nexports.default = _default;\nmodule.exports = WritableTrackingBuffer;","map":{"version":3,"names":["SHIFT_LEFT_32","SHIFT_RIGHT_32","UNKNOWN_PLP_LEN","Buffer","from","ZERO_LENGTH_BUFFER","alloc","WritableTrackingBuffer","constructor","initialSize","encoding","doubleSizeGrowth","buffer","compositeBuffer","position","data","newBuffer","copyFrom","length","makeRoomFor","copy","requiredLength","size","Math","max","slice","concat","writeUInt8","value","writeUInt16LE","writeUShort","writeUInt16BE","writeUInt24LE","writeUInt32LE","writeBigInt64LE","writeInt64LE","BigInt","writeUInt64LE","writeBigUInt64LE","writeUInt32BE","writeUInt40LE","writeInt32LE","floor","writeInt8","writeInt16LE","writeInt16BE","writeInt32BE","writeFloatLE","writeDoubleLE","writeString","byteLength","write","writeBVarchar","writeUsVarchar","writeUsVarbyte","toString","writeBuffer","writePLPBody","writeMoney","module","exports"],"sources":["/Users/shahwalikhan/Desktop/my-app/node_modules/tedious/src/tracking-buffer/writable-tracking-buffer.ts"],"sourcesContent":["const SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nconst SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nconst UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\nconst ZERO_LENGTH_BUFFER = Buffer.alloc(0);\n\nexport type Encoding = 'utf8' | 'ucs2' | 'ascii';\n\n/**\n  A Buffer-like class that tracks position.\n\n  As values are written, the position advances by the size of the written data.\n  When writing, automatically allocates new buffers if there's not enough space.\n */\nclass WritableTrackingBuffer {\n  initialSize: number;\n  encoding: Encoding;\n  doubleSizeGrowth: boolean;\n\n  buffer: Buffer;\n  compositeBuffer: Buffer;\n\n  position: number;\n\n  constructor(initialSize: number, encoding?: Encoding | null, doubleSizeGrowth?: boolean) {\n    this.initialSize = initialSize;\n    this.encoding = encoding || 'ucs2';\n    this.doubleSizeGrowth = doubleSizeGrowth || false;\n    this.buffer = Buffer.alloc(this.initialSize, 0);\n    this.compositeBuffer = ZERO_LENGTH_BUFFER;\n    this.position = 0;\n  }\n\n  get data() {\n    this.newBuffer(0);\n    return this.compositeBuffer;\n  }\n\n  copyFrom(buffer: Buffer) {\n    const length = buffer.length;\n    this.makeRoomFor(length);\n    buffer.copy(this.buffer, this.position);\n    this.position += length;\n  }\n\n  makeRoomFor(requiredLength: number) {\n    if (this.buffer.length - this.position < requiredLength) {\n      if (this.doubleSizeGrowth) {\n        let size = Math.max(128, this.buffer.length * 2);\n        while (size < requiredLength) {\n          size *= 2;\n        }\n        this.newBuffer(size);\n      } else {\n        this.newBuffer(requiredLength);\n      }\n    }\n  }\n\n  newBuffer(size: number) {\n    const buffer = this.buffer.slice(0, this.position);\n    this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);\n    this.buffer = (size === 0) ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);\n    this.position = 0;\n  }\n\n  writeUInt8(value: number) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt8(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt16LE(value: number) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16LE(value, this.position);\n    this.position += length;\n  }\n\n  writeUShort(value: number) {\n    this.writeUInt16LE(value);\n  }\n\n  writeUInt16BE(value: number) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16BE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt24LE(value: number) {\n    const length = 3;\n    this.makeRoomFor(length);\n    this.buffer[this.position + 2] = (value >>> 16) & 0xff;\n    this.buffer[this.position + 1] = (value >>> 8) & 0xff;\n    this.buffer[this.position] = value & 0xff;\n    this.position += length;\n  }\n\n  writeUInt32LE(value: number) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32LE(value, this.position);\n    this.position += length;\n  }\n\n  writeBigInt64LE(value: bigint) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeBigInt64LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt64LE(value: number) {\n    this.writeBigInt64LE(BigInt(value));\n  }\n\n  writeUInt64LE(value: number) {\n    this.writeBigUInt64LE(BigInt(value));\n  }\n\n  writeBigUInt64LE(value: bigint) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeBigUInt64LE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt32BE(value: number) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32BE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt40LE(value: number) {\n    // inspired by https://github.com/dpw/node-buffer-more-ints\n    this.writeInt32LE(value & -1);\n    this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));\n  }\n\n  writeInt8(value: number) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeInt8(value, this.position);\n    this.position += length;\n  }\n\n  writeInt16LE(value: number) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt16BE(value: number) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16BE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt32LE(value: number) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt32BE(value: number) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32BE(value, this.position);\n    this.position += length;\n  }\n\n  writeFloatLE(value: number) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeFloatLE(value, this.position);\n    this.position += length;\n  }\n\n  writeDoubleLE(value: number) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeDoubleLE(value, this.position);\n    this.position += length;\n  }\n\n  writeString(value: string, encoding?: Encoding | null) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    const length = Buffer.byteLength(value, encoding);\n    this.makeRoomFor(length);\n\n    // $FlowFixMe https://github.com/facebook/flow/pull/5398\n    this.buffer.write(value, this.position, encoding);\n    this.position += length;\n  }\n\n  writeBVarchar(value: string, encoding?: Encoding | null) {\n    this.writeUInt8(value.length);\n    this.writeString(value, encoding);\n  }\n\n  writeUsVarchar(value: string, encoding?: Encoding | null) {\n    this.writeUInt16LE(value.length);\n    this.writeString(value, encoding);\n  }\n\n  // TODO: Figure out what types are passed in other than `Buffer`\n  writeUsVarbyte(value: any, encoding?: Encoding | null) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    let length;\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    }\n    this.writeUInt16LE(length);\n\n    if (value instanceof Buffer) {\n      this.writeBuffer(value);\n    } else {\n      this.makeRoomFor(length);\n      // $FlowFixMe https://github.com/facebook/flow/pull/5398\n      this.buffer.write(value, this.position, encoding);\n      this.position += length;\n    }\n  }\n\n  writePLPBody(value: any, encoding?: Encoding | null) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    let length;\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    }\n\n    // Length of all chunks.\n    // this.writeUInt64LE(length);\n    // unknown seems to work better here - might revisit later.\n    this.writeBuffer(UNKNOWN_PLP_LEN);\n\n    // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.\n    if (length > 0) {\n      // One chunk.\n      this.writeUInt32LE(length);\n      if (value instanceof Buffer) {\n        this.writeBuffer(value);\n      } else {\n        this.makeRoomFor(length);\n        this.buffer.write(value, this.position, encoding);\n        this.position += length;\n      }\n    }\n\n    // PLP_TERMINATOR (no more chunks).\n    this.writeUInt32LE(0);\n  }\n\n  writeBuffer(value: Buffer) {\n    const length = value.length;\n    this.makeRoomFor(length);\n    value.copy(this.buffer, this.position);\n    this.position += length;\n  }\n\n  writeMoney(value: number) {\n    this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n    this.writeInt32LE(value & -1);\n  }\n}\n\nexport default WritableTrackingBuffer;\nmodule.exports = WritableTrackingBuffer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}